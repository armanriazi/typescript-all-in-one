<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TypeScript-All-In-One(A.R)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="AboutMe.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li class="chapter-item expanded "><a href="TypeScript.html"><strong aria-hidden="true">2.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="styleguide/styleguide.html"><strong aria-hidden="true">2.1.</strong> StyleGuide</a></li><li class="chapter-item "><a href="configuration/configuration.html"><strong aria-hidden="true">2.2.</strong> Configuration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="configuration/cli.html"><strong aria-hidden="true">2.2.1.</strong> CLI</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="javascript/recap.html"><strong aria-hidden="true">3.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="javascript/equality_condition.html"><strong aria-hidden="true">3.1.</strong> Equality</a></li><li class="chapter-item "><a href="javascript/references.html"><strong aria-hidden="true">3.2.</strong> References</a></li><li class="chapter-item "><a href="javascript/this.html"><strong aria-hidden="true">3.3.</strong> this</a></li><li class="chapter-item "><a href="javascript/number.html"><strong aria-hidden="true">3.4.</strong> Number</a></li><li class="chapter-item "><a href="javascript/truthy.html"><strong aria-hidden="true">3.5.</strong> Truthy</a></li></ol></li><li class="chapter-item expanded "><a href="quick/quick.html"><strong aria-hidden="true">4.</strong> QuickStarts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="quick/quick.html"><strong aria-hidden="true">4.1.</strong> Node Browser Lib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="quick/nodejs.html"><strong aria-hidden="true">4.1.1.</strong> Node.js QuickStart</a></li><li class="chapter-item "><a href="quick/browser.html"><strong aria-hidden="true">4.1.2.</strong> Browser QuickStart</a></li><li class="chapter-item "><a href="quick/library.html"><strong aria-hidden="true">4.1.3.</strong> Library QuickStart</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="defination/defination.html"><strong aria-hidden="true">5.</strong> Var_Let_Const_Readonly_Static</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defination/let.html"><strong aria-hidden="true">5.1.</strong> let</a></li><li class="chapter-item "><a href="defination/var.html"><strong aria-hidden="true">5.2.</strong> var</a></li><li class="chapter-item "><a href="defination/const.html"><strong aria-hidden="true">5.3.</strong> const</a></li><li class="chapter-item "><a href="types/readonly/readonly.html"><strong aria-hidden="true">5.4.</strong> readonly</a></li><li class="chapter-item "><a href="types/static/static.html"><strong aria-hidden="true">5.5.</strong> static</a></li></ol></li><li class="chapter-item expanded "><a href="future-javascript.html"><strong aria-hidden="true">6.</strong> Future JavaScript Now</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/string/template-strings.html"><strong aria-hidden="true">6.1.</strong> Template Strings</a></li><li class="chapter-item "><a href="classes.html"><strong aria-hidden="true">6.2.</strong> Classes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="classes-emit.html"><strong aria-hidden="true">6.2.1.</strong> Classes Emit</a></li></ol></li><li class="chapter-item "><a href="rest-parameters.html"><strong aria-hidden="true">6.3.</strong> Rest Parameters</a></li><li class="chapter-item "><a href="spread-operator.html"><strong aria-hidden="true">6.4.</strong> Spread Operator</a></li><li class="chapter-item "><a href="for...of.html"><strong aria-hidden="true">6.5.</strong> for...of</a></li><li class="chapter-item "><a href="promise.html"><strong aria-hidden="true">6.6.</strong> Promise</a></li><li class="chapter-item "><a href="async/async.html"><strong aria-hidden="true">6.7.</strong> Async Await</a></li></ol></li><li class="chapter-item expanded "><a href="project/project.html"><strong aria-hidden="true">7.</strong> Project</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/migrating.html"><strong aria-hidden="true">7.1.</strong> JS Migration Guide</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="project/tsconfig.html"><strong aria-hidden="true">7.1.1.</strong> tsconfig.json</a></li><li class="chapter-item "><a href="project/files.html"><strong aria-hidden="true">7.1.2.</strong> Which Files?</a></li></ol></li><li class="chapter-item "><a href="project/declarationspaces.html"><strong aria-hidden="true">7.2.</strong> Declaration Spaces</a></li><li class="chapter-item "><a href="project/modules.html"><strong aria-hidden="true">7.3.</strong> Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="project/external-modules.html"><strong aria-hidden="true">7.3.1.</strong> File Module Details</a></li><li class="chapter-item "><a href="project/globals.html"><strong aria-hidden="true">7.3.2.</strong> global.d</a></li><li class="chapter-item "><a href="project/namespacing.d.html"><strong aria-hidden="true">7.3.3.</strong> namespacing.d</a></li></ol></li><li class="chapter-item "><a href="project/namespaces.html"><strong aria-hidden="true">7.4.</strong> Namespaces</a></li><li class="chapter-item "><a href="project/dynamic-import-expressions.html"><strong aria-hidden="true">7.5.</strong> Dynamic Import Expressions</a></li></ol></li><li class="chapter-item expanded "><a href="types/types.html"><strong aria-hidden="true">8.</strong> TypeScript's Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="options/intro.html"><strong aria-hidden="true">8.1.</strong> Type Checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="options/noImplicitAny.html"><strong aria-hidden="true">8.1.1.</strong> noImplicitAny</a></li><li class="chapter-item "><a href="options/strictNullChecks.html"><strong aria-hidden="true">8.1.2.</strong> strictNullChecks</a></li></ol></li><li class="chapter-item "><a href="types/primitive/primitive.html"><strong aria-hidden="true">8.2.</strong> Primitive</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/empty.html"><strong aria-hidden="true">8.2.1.</strong> Empty</a></li><li class="chapter-item "><a href="types/wrapper/wrapper.html"><strong aria-hidden="true">8.2.2.</strong> Wrapper</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/wrapper/wrapper_objects.html"><strong aria-hidden="true">8.2.2.1.</strong> Object</a></li></ol></li></ol></li><li class="chapter-item "><a href="types/compound/compound.html"><strong aria-hidden="true">8.3.</strong> Compound</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/compound/union/union.html"><strong aria-hidden="true">8.3.1.</strong> Union</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/compound/union/discriminated-unions.html"><strong aria-hidden="true">8.3.1.1.</strong> Discriminated-unions</a></li></ol></li><li class="chapter-item "><a href="types/compound/enum/enum.html"><strong aria-hidden="true">8.3.2.</strong> Enums</a></li><li class="chapter-item "><a href="types/compound/tuple/tuple.html"><strong aria-hidden="true">8.3.3.</strong> Tuple</a></li></ol></li><li class="chapter-item "><a href="types/generic/generic.html"><strong aria-hidden="true">8.4.</strong> Generic</a></li><li class="chapter-item "><a href="types/type-assertion.html"><strong aria-hidden="true">8.5.</strong> Type Assertion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/mapping.html"><strong aria-hidden="true">8.5.1.</strong> Type Mapping</a></li></ol></li><li class="chapter-item "><a href="types/freshness.html"><strong aria-hidden="true">8.6.</strong> Freshness</a></li><li class="chapter-item "><a href="types/type-inference.html"><strong aria-hidden="true">8.7.</strong> Type Inference</a></li><li class="chapter-item "><a href="types/duck/duck.html"><strong aria-hidden="true">8.8.</strong> Duck Type</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/duck/structural/structural.html"><strong aria-hidden="true">8.8.1.</strong> Structuring</a></li><li class="chapter-item "><a href="types/duck/structural/destructuring.html"><strong aria-hidden="true">8.8.2.</strong> Destructuring</a></li></ol></li><li class="chapter-item "><a href="types/narrowing/narrowing.html"><strong aria-hidden="true">8.9.</strong> Narrowing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/narrowing/guard.html"><strong aria-hidden="true">8.9.1.</strong> Guard</a></li><li class="chapter-item "><a href="types/narrowing/assertion-fn.html"><strong aria-hidden="true">8.9.2.</strong> AssertionFN</a></li><li class="chapter-item "><a href="types/narrowing/widening.html"><strong aria-hidden="true">8.9.3.</strong> Widening</a></li></ol></li><li class="chapter-item "><a href="types/literal/literal-types.html"><strong aria-hidden="true">8.10.</strong> Literal Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/inference-literal-types.html"><strong aria-hidden="true">8.10.1.</strong> Inference Literal</a></li><li class="chapter-item "><a href="types/enum-literal-type.html"><strong aria-hidden="true">8.10.2.</strong> Enum Literal</a></li><li class="chapter-item "><a href="types/inference-literal-gurad-type.html"><strong aria-hidden="true">8.10.3.</strong> Inference Gurad Literal</a></li></ol></li><li class="chapter-item "><a href="types/builtin/builtin.html"><strong aria-hidden="true">8.11.</strong> Built-in</a></li><li class="chapter-item "><a href="types/covariance_contravariance/covariance_contravariance.html"><strong aria-hidden="true">8.12.</strong> Covariance &amp; Contravariance</a></li><li class="chapter-item "><a href="types/recursive/recursive.html"><strong aria-hidden="true">8.13.</strong> Recursive</a></li><li class="chapter-item "><a href="types/exceptions/exceptions.html"><strong aria-hidden="true">8.14.</strong> Exception Handling</a></li><li class="chapter-item "><a href="types/patterns/patterns.html"><strong aria-hidden="true">8.15.</strong> Patterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/patterns/intersection/intersection.html"><strong aria-hidden="true">8.15.1.</strong> Intersection</a></li><li class="chapter-item "><a href="types/patterns/power/power.html"><strong aria-hidden="true">8.15.2.</strong> Power</a></li><li class="chapter-item "><a href="types/patterns/satisfies/satisfies.html"><strong aria-hidden="true">8.15.3.</strong> Satisfies</a></li><li class="chapter-item "><a href="types/patterns/manipulation/manipulation.html"><strong aria-hidden="true">8.15.4.</strong> Manipulation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/patterns/manipulation/conditional.html"><strong aria-hidden="true">8.15.4.1.</strong> Conditionally</a></li><li class="chapter-item "><a href="types/patterns/manipulation/transform-mapping.html"><strong aria-hidden="true">8.15.4.2.</strong> Transform Mapping</a></li></ol></li></ol></li><li class="chapter-item "><a href="types/module/@types.html"><strong aria-hidden="true">8.16.</strong> @types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/module/ambient/intro.html"><strong aria-hidden="true">8.16.1.</strong> Ambient Declarations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/module/ambient/d.ts.html"><strong aria-hidden="true">8.16.1.1.</strong> Declaration Files</a></li><li class="chapter-item "><a href="types/module/ambient/variables.html"><strong aria-hidden="true">8.16.1.2.</strong> Variables</a></li></ol></li></ol></li><li class="chapter-item "><a href="types/exchange/exchange-types.html"><strong aria-hidden="true">8.17.</strong> Ex/Import of Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/lib.d.ts.html"><strong aria-hidden="true">8.17.1.</strong> lib.d.ts</a></li><li class="chapter-item "><a href="types/functions.html"><strong aria-hidden="true">8.17.2.</strong> Functions</a></li><li class="chapter-item "><a href="types/callable.html"><strong aria-hidden="true">8.17.3.</strong> Callable</a></li><li class="chapter-item "><a href="types/type-compatibility.html"><strong aria-hidden="true">8.17.4.</strong> Type Compatibility</a></li><li class="chapter-item "><a href="types/system/index-signatures.html"><strong aria-hidden="true">8.17.5.</strong> Index Signatures</a></li><li class="chapter-item "><a href="types/moving-types.html"><strong aria-hidden="true">8.17.6.</strong> Moving Types</a></li><li class="chapter-item "><a href="types/mixins.html"><strong aria-hidden="true">8.17.7.</strong> Mixins</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="collection/collection.html"><strong aria-hidden="true">9.</strong> Collection</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collection/array.html"><strong aria-hidden="true">9.1.</strong> Array</a></li><li class="chapter-item "><a href="collection/map.html"><strong aria-hidden="true">9.2.</strong> Map</a></li><li class="chapter-item "><a href="collection/iterators.html"><strong aria-hidden="true">9.3.</strong> Iterators</a></li><li class="chapter-item "><a href="collection/generators.html"><strong aria-hidden="true">9.4.</strong> Generators</a></li></ol></li><li class="chapter-item expanded "><a href="oop/oop.html"><strong aria-hidden="true">10.</strong> Object Orianted Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/generic/generic.html"><strong aria-hidden="true">10.1.</strong> Generic</a></li><li class="chapter-item "><a href="oop/class.html"><strong aria-hidden="true">10.2.</strong> Class</a></li><li class="chapter-item "><a href="oop/interfaces.html"><strong aria-hidden="true">10.3.</strong> Interfaces</a></li><li class="chapter-item "><a href="oop/inheritance.html"><strong aria-hidden="true">10.4.</strong> Inheritance</a></li><li class="chapter-item "><a href="oop/polymorphism.html"><strong aria-hidden="true">10.5.</strong> Polymorphism</a></li><li class="chapter-item "><a href="oop/designpatterns.html"><strong aria-hidden="true">10.6.</strong> Design Patterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="oop/designpatterns/decorator/decorator.html"><strong aria-hidden="true">10.6.1.</strong> Decorators</a></li><li class="chapter-item "><a href="oop/designpatterns/observer/observer.html"><strong aria-hidden="true">10.6.2.</strong> Observer</a></li><li class="chapter-item "><a href="oop/designpatterns/singleton/singleton.html"><strong aria-hidden="true">10.6.3.</strong> Singleton</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fp/fp.html"><strong aria-hidden="true">11.</strong> Functional Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tips/functionParameters.html"><strong aria-hidden="true">11.1.</strong> Function parameters</a></li><li class="chapter-item "><a href="arrow-functions.html"><strong aria-hidden="true">11.2.</strong> Arrow Functions</a></li><li class="chapter-item "><a href="javascript/closure.html"><strong aria-hidden="true">11.3.</strong> Closure</a></li><li class="chapter-item "><a href="tips/statefulFunctions.html"><strong aria-hidden="true">11.4.</strong> Stateful Functions</a></li><li class="chapter-item "><a href="tips/currying.html"><strong aria-hidden="true">11.5.</strong> Currying</a></li><li class="chapter-item "><a href="fp/project1.html"><strong aria-hidden="true">11.6.</strong> A Sample Project 1</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fp/project1-problemstatemet.html"><strong aria-hidden="true">11.6.1.</strong> Problem Statemet</a></li></ol></li><li class="chapter-item "><a href="fp/project2.html"><strong aria-hidden="true">11.7.</strong> A Sample Project 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fp/project2-problemstatemet.html"><strong aria-hidden="true">11.7.1.</strong> Problem Statemet</a></li></ol></li><li class="chapter-item "><a href="fp/fp-additional.html"><strong aria-hidden="true">11.8.</strong> Additional</a></li><li class="chapter-item "><a href="fp/appendix.html"><strong aria-hidden="true">11.9.</strong> Appendix</a></li></ol></li><li class="chapter-item expanded "><a href="errors/main.html"><strong aria-hidden="true">12.</strong> Errors in TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="errors/common-errors.html"><strong aria-hidden="true">12.1.</strong> Common Errors</a></li><li class="chapter-item "><a href="types/conversion.html"><strong aria-hidden="true">12.2.</strong> Type Conversion</a></li><li class="chapter-item "><a href="errors/interpreting-errors.html"><strong aria-hidden="true">12.3.</strong> Interpreting Errors</a></li></ol></li><li class="chapter-item expanded "><a href="testing/intro.html"><strong aria-hidden="true">13.</strong> Testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/jest.html"><strong aria-hidden="true">13.1.</strong> Jest</a></li><li class="chapter-item "><a href="testing/cypress.html"><strong aria-hidden="true">13.2.</strong> Cypress</a></li></ol></li><li class="chapter-item expanded "><a href="jsx/tsx.html"><strong aria-hidden="true">14.</strong> JSX</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="jsx/react.html"><strong aria-hidden="true">14.1.</strong> React</a></li><li class="chapter-item "><a href="jsx/redux.html"><strong aria-hidden="true">14.2.</strong> Redux</a></li><li class="chapter-item "><a href="jsx/others.html"><strong aria-hidden="true">14.3.</strong> Non React JSX</a></li></ol></li><li class="chapter-item expanded "><a href="tools/intro.html"><strong aria-hidden="true">15.</strong> Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tools/prettier.html"><strong aria-hidden="true">15.1.</strong> Prettier</a></li><li class="chapter-item "><a href="tools/husky.html"><strong aria-hidden="true">15.2.</strong> Husky</a></li><li class="chapter-item "><a href="tools/eslint.html"><strong aria-hidden="true">15.3.</strong> ESLint</a></li><li class="chapter-item "><a href="tools/changelog.html"><strong aria-hidden="true">15.4.</strong> Changelog</a></li></ol></li><li class="chapter-item expanded "><a href="tips/main.html"><strong aria-hidden="true">16.</strong> TIPs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tips/typeInstantiation.html"><strong aria-hidden="true">16.1.</strong> Type Instantiation</a></li><li class="chapter-item "><a href="tips/stringEnums.html"><strong aria-hidden="true">16.2.</strong> String Based Enums</a></li><li class="chapter-item "><a href="tips/nominalTyping.html"><strong aria-hidden="true">16.3.</strong> Nominal Typing</a></li><li class="chapter-item "><a href="tips/lazyObjectLiteralInitialization.html"><strong aria-hidden="true">16.4.</strong> Lazy Object Literal Initialization</a></li><li class="chapter-item "><a href="tips/classesAreUseful.html"><strong aria-hidden="true">16.5.</strong> Classes are Useful</a></li><li class="chapter-item "><a href="tips/defaultIsBad.html"><strong aria-hidden="true">16.6.</strong> Avoid Export Default</a></li><li class="chapter-item "><a href="tips/propertySetters.html"><strong aria-hidden="true">16.7.</strong> Limit Property Setters</a></li><li class="chapter-item "><a href="tips/outFile.html"><strong aria-hidden="true">16.8.</strong> outFile caution</a></li><li class="chapter-item "><a href="tips/jquery.html"><strong aria-hidden="true">16.9.</strong> JQuery tips</a></li><li class="chapter-item "><a href="tips/staticConstructor.html"><strong aria-hidden="true">16.10.</strong> static constructors</a></li><li class="chapter-item "><a href="tips/build-toggles.html"><strong aria-hidden="true">16.11.</strong> Build Toggles</a></li><li class="chapter-item "><a href="tips/barrel.html"><strong aria-hidden="true">16.12.</strong> Barrel</a></li><li class="chapter-item "><a href="tips/typed-event.html"><strong aria-hidden="true">16.13.</strong> Typesafe Event Emitter</a></li></ol></li><li class="chapter-item expanded "><a href="compiler/overview.html"><strong aria-hidden="true">17.</strong> TypeScript Compiler Internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/program.html"><strong aria-hidden="true">17.1.</strong> Program</a></li><li class="chapter-item "><a href="compiler/ast.html"><strong aria-hidden="true">17.2.</strong> AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/ast-tip-children.html"><strong aria-hidden="true">17.2.1.</strong> TIP: Visit Children</a></li><li class="chapter-item "><a href="compiler/ast-tip-syntaxkind.html"><strong aria-hidden="true">17.2.2.</strong> TIP: SyntaxKind enum</a></li><li class="chapter-item "><a href="compiler/ast-trivia.html"><strong aria-hidden="true">17.2.3.</strong> Trivia</a></li></ol></li><li class="chapter-item "><a href="compiler/scanner.html"><strong aria-hidden="true">17.3.</strong> Scanner</a></li><li class="chapter-item "><a href="compiler/parser.html"><strong aria-hidden="true">17.4.</strong> Parser</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/parser-functions.html"><strong aria-hidden="true">17.4.1.</strong> Parser Functions</a></li></ol></li><li class="chapter-item "><a href="compiler/binder.html"><strong aria-hidden="true">17.5.</strong> Binder</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/binder-functions.html"><strong aria-hidden="true">17.5.1.</strong> Binder Functions</a></li><li class="chapter-item "><a href="compiler/binder-declarations.html"><strong aria-hidden="true">17.5.2.</strong> Binder Declarations</a></li><li class="chapter-item "><a href="compiler/binder-container.html"><strong aria-hidden="true">17.5.3.</strong> Binder Container</a></li><li class="chapter-item "><a href="compiler/binder-symboltable.html"><strong aria-hidden="true">17.5.4.</strong> Binder SymbolTable</a></li><li class="chapter-item "><a href="compiler/binder-diagnostics.html"><strong aria-hidden="true">17.5.5.</strong> Binder Error Reporting</a></li></ol></li><li class="chapter-item "><a href="compiler/checker.html"><strong aria-hidden="true">17.6.</strong> Checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/checker-global.html"><strong aria-hidden="true">17.6.1.</strong> Checker Diagnostics</a></li><li class="chapter-item "><a href="compiler/checker-diagnostics.html"><strong aria-hidden="true">17.6.2.</strong> Checker Error Reporting</a></li></ol></li><li class="chapter-item "><a href="compiler/emitter.html"><strong aria-hidden="true">17.7.</strong> Emitter</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compiler/emitter-functions.html"><strong aria-hidden="true">17.7.1.</strong> Emitter Functions</a></li><li class="chapter-item "><a href="compiler/emitter-sourcemaps.html"><strong aria-hidden="true">17.7.2.</strong> Emitter SourceMaps</a></li></ol></li><li class="chapter-item "><a href="compiler/contributing.html"><strong aria-hidden="true">17.8.</strong> Contributing</a></li></ol></li><li class="chapter-item expanded "><a href="GLOSSARY.html"><strong aria-hidden="true">18.</strong> GLOSSARY</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScript-All-In-One(A.R)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/armanriazi/typescript-all-in-one/tree/main/workspace" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-typescript-mdbook"><a class="header" href="#the-typescript-mdbook">The TypeScript MDBook</a></h1>
<p>The Concise TypeScript Book provides a comprehensive and succinct overview of TypeScript’s capabilities. It offers clear explanations covering all aspects found in the latest version of the language, from its powerful type system to advanced features. Whether you’re a beginner or an experienced developer, this book is an invaluable resource to enhance your understanding and proficiency in TypeScript.</p>
<p>This book is completely Free and Open Source.</p>
<p>If you found this TypeScript book valuable and wish to contribute, consider supporting my efforts via cryptocurrency. Thanks!</p>
<pre><code class="language-md">0xde5D732a5AB44832E1c69b18be30834639F44A2c
</code></pre>
<hr />
<h2 id="downloads"><a class="header" href="#downloads">Downloads</a></h2>
<p>You can also download the Epub version here:</p>
<p><a href="https://github.com/armanriazi/typescript-all-in-one/tree/main/downloads">https://github.com/armanriazi/typescript-all-in-one/tree/main/downloads</a></p>
<!-- markdownlint-disable MD004 
- [The Concise TypeScript Book](#the-concise-typescript-all-in-one)

  - [Downloads](#downloads)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [About the Author](#about-the-author)
    - [jsx](#jsx)
    - [skipLibCheck](#skiplibcheck)
    - [files](#files)
    - [include](#include)
    - [exclude](#exclude)
    - [importHelpers](#importhelpers)
    - [Migration to TypeScript Advice](#migration-to-typescript-advice)
  - [Exploring the Type System](#exploring-the-type-system)
    - [The TypeScript Language Service](#the-typescript-language-service)
    - [Structural Typing](#structural-typing)
    - [TypeScript Fundamental Comparison Rules](#typescript-fundamental-comparison-rules)
    - [Types as Sets](#types-as-sets)
    - [Assign a type: Type Declarations and Type Assertions](#assign-a-type-type-declarations-and-type-assertions)
      - [Type Declaration](#type-declaration)
      - [Type Assertion](#type-assertion)
      - [Ambient Declarations](#ambient-declarations)
    - [Property Checking and Excess Property Checking](#property-checking-and-excess-property-checking)
    - [Weak Types](#weak-types)
    - [Strict Object Literal Checking (Freshness)](#strict-object-literal-checking-freshness)
    - [Type Inference](#type-inference)
    - [More Advanced Inferences](#more-advanced-inferences)
    - [Type Widening](#type-widening)
    - [Const](#const)
      - [Const Modifier on Type Parameters](#const-modifier-on-type-parameters)
      - [Const assertion](#const-assertion)
    - [Explicit Type Annotation](#explicit-type-annotation)
    - [Type Narrowing](#type-narrowing)
      - [Conditions](#conditions)
      - [Throwing or returning](#throwing-or-returning)
      - [Discriminated Union](#discriminated-union)
      - [User-Defined Type Guards](#user-defined-type-guards)
  - [Primitive Types](#primitive-types)
    - [string](#string)
    - [boolean](#boolean)
    - [number](#number)
    - [bigInt](#bigint)
    - [Symbol](#symbol)
    - [null and undefined](#null-and-undefined)
    - [Array](#array)
    - [any](#any)
  - [Type Annotations](#type-annotations)
  - [Optional Properties](#optional-properties)
  - [Readonly Properties](#readonly-properties)
  - [Index Signatures](#index-signatures)
  - [Extending Types](#extending-types)
  - [Literal Types](#literal-types)
  - [Literal Inference](#literal-inference)
  - [strictNullChecks](#strictnullchecks)
  - [Enums](#enums)
    - [Numeric enums](#numeric-enums)
    - [String enums](#string-enums)
    - [Constant enums](#constant-enums)
    - [Reverse mapping](#reverse-mapping)
    - [Ambient enums](#ambient-enums)
    - [Computed and constant members](#computed-and-constant-members)
  - [Narrowing](#narrowing)
    - [typeof type guards](#typeof-type-guards)
    - [Truthiness narrowing](#truthiness-narrowing)
    - [Equality narrowing](#equality-narrowing)
    - [In Operator narrowing](#in-operator-narrowing)
    - [instanceof narrowing](#instanceof-narrowing)
  - [Assignments](#assignments)
  - [Control Flow Analysis](#control-flow-analysis)
  - [Type Predicates](#type-predicates)
  - [Discriminated Unions](#discriminated-unions)
  - [The never Type](#the-never-type)
  - [Exhaustiveness checking](#exhaustiveness-checking)
  - [Object Types](#object-types)
  - [Tuple Type (Anonymous)](#tuple-type-anonymous)
  - [Named Tuple Type (Labeled)](#named-tuple-type-labeled)
  - [Fixed Length Tuple](#fixed-length-tuple)
  - [Union Type](#union-type)
  - [Intersection Types](#intersection-types)
  - [Type Indexing](#type-indexing)
  - [Type from Value](#type-from-value)
  - [Type from Func Return](#type-from-func-return)
  - [Type from Module](#type-from-module)
  - [Mapped Types](#mapped-types)
  - [Mapped Type Modifiers](#mapped-type-modifiers)
  - [Conditional Types](#conditional-types)
  - [Distributive Conditional Types](#distributive-conditional-types)
  - [infer Type Inference in Conditional Types](#infer-type-inference-in-conditional-types)
  - [Predefined Conditional Types](#predefined-conditional-types)
  - [Template Union Types](#template-union-types)
  - [Any type](#any-type)
  - [Unknown type](#unknown-type)
  - [Void type](#void-type)
  - [Never type](#never-type)
  - [Interface and Type](#interface-and-type)
    - [Common Syntax](#common-syntax)
    - [Basic Types](#basic-types)
    - [Objects and Interfaces](#objects-and-interfaces)
    - [Union and Intersection Types](#union-and-intersection-types)
  - [Built-in Type Primitives](#built-in-type-primitives)
  - [Common Built-in JS Objects](#common-built-in-js-objects)
  - [Overloads](#overloads)
  - [Merging and Extension](#merging-and-extension)
  - [Differences between Type and Interface](#differences-between-type-and-interface)
  - [Class](#class)
    - [Class Common Syntax](#class-common-syntax)
    - [Constructor](#constructor)
    - [Private and Protected Constructors](#private-and-protected-constructors)
    - [Access Modifiers](#access-modifiers)
    - [Get \& Set](#get--set)
    - [Auto-Accessors in Classes](#auto-accessors-in-classes)
    - [this](#this)
    - [Parameter Properties](#parameter-properties)
    - [Abstract Classes](#abstract-classes)
    - [With Generics](#with-generics)
    - [Decorators](#decorators)
      - [Class Decorators](#class-decorators)
      - [Property Decorator](#property-decorator)
      - [Method Decorator](#method-decorator)
      - [Getter and Setter Decorators](#getter-and-setter-decorators)
      - [Decorator Metadata](#decorator-metadata)
    - [Inheritance](#inheritance)
    - [Statics](#statics)
    - [Property initialization](#property-initialization)
    - [Method overloading](#method-overloading)
  - [Generics](#generics)
    - [Generic Type](#generic-type)
    - [Generic Classes](#generic-classes)
    - [Generic Constraints](#generic-constraints)
    - [Generic contextual narrowing](#generic-contextual-narrowing)
  - [Erased Structural Types](#erased-structural-types)
  - [Namespacing](#namespacing)
  - [Symbols](#symbols)
  - [Triple-Slash Directives](#triple-slash-directives)
  - [Type Manipulation](#type-manipulation)
    - [Creating Types from Types](#creating-types-from-types)
    - [Indexed Access Types](#indexed-access-types)
    - [Utility Types](#utility-types)
      - [Awaited\<T\>](#awaitedt)
      - [Partial\<T\>](#partialt)
      - [Required\<T\>](#requiredt)
      - [Readonly\<T\>](#readonlyt)
      - [Record\<K, T\>](#recordk-t)
      - [Pick\<T, K\>](#pickt-k)
      - [Omit\<T, K\>](#omitt-k)
      - [Exclude\<T, U\>](#excludet-u)
      - [Extract\<T, U\>](#extractt-u)
      - [NonNullable\<T\>](#nonnullablet)
      - [Parameters\<T\>](#parameterst)
      - [ConstructorParameters\<T\>](#constructorparameterst)
      - [ReturnType\<T\>](#returntypet)
      - [InstanceType\<T\>](#instancetypet)
      - [ThisParameterType\<T\>](#thisparametertypet)
      - [OmitThisParameter\<T\>](#omitthisparametert)
      - [ThisType\<T\>](#thistypet)
      - [Uppercase\<T\>](#uppercaset)
      - [Lowercase\<T\>](#lowercaset)
      - [Capitalize\<T\>](#capitalizet)
      - [Uncapitalize\<T\>](#uncapitalizet)
  - [Others](#others)
    - [Errors and Exception Handling](#errors-and-exception-handling)
    - [Mixin classes](#mixin-classes)
    - [Asynchronous Language Features](#asynchronous-language-features)
    - [Iterators and Generators](#iterators-and-generators)
    - [TsDocs JSDoc Reference](#tsdocs-jsdoc-reference)
    - [@types](#types)
    - [JSX](#jsx-1)
    - [ES6 Modules](#es6-modules)
    - [ES7 Exponentiation Operator](#es7-exponentiation-operator)
    - [The for-await-of Statement](#the-for-await-of-statement)
    - [New.target](#newtarget)
    - [Dynamic Import Expressions](#dynamic-import-expressions)
    - ["tsc –watch"](#tsc-watch)
    - [Non-null Assertion Operator (Postfix !)](#non-null-assertion-operator-postfix-)
    - [Defaulted declarations](#defaulted-declarations)
    - [Optional Chaining](#optional-chaining)
    - [Nullish coalescing operator (??)](#nullish-coalescing-operator-)
    - [Template Literal Types](#template-literal-types)
    - [Function overloading](#function-overloading)
    - [Recursive Types](#recursive-types)
    - [Recursive Conditional Types](#recursive-conditional-types)
    - [ECMAScript Module Support in Node.js](#ecmascript-module-support-in-nodejs)
    - [Assertion Functions](#assertion-functions)
    - [Variadic Tuple Types](#variadic-tuple-types)
    - [Boxed types](#boxed-types)
    - [Covariance and Contravariance in TypeScript](#covariance-and-contravariance-in-typescript)
      - [Optional Variance Annotations for Type Parameters](#optional-variance-annotations-for-type-parameters)
    - [Template String Pattern Index Signatures](#template-string-pattern-index-signatures)
    - [The satisfies Operator](#the-satisfies-operator)
    - [Type-Only Imports and Export](#type-only-imports-and-export)
    - [using declaration and Explicit Resource Management](#using-declaration-and-explicit-resource-management)
      - [await using declaration](#await-using-declaration)
 markdownlint-enable MD004 -->
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Welcome to The Concise TypeScript Book! This guide equips you with essential knowledge and practical skills for effective TypeScript development. Discover key concepts and techniques to write clean, robust code. Whether you’re a beginner or an experienced developer, this book serves as both a comprehensive guide and a handy reference for leveraging TypeScript’s power in your projects.</p>
<!--This book covers TypeScript 5.2.-->
<h2 id="about-the-author"><a class="header" href="#about-the-author">About the Author</a></h2>
<p>Arman Riazi is an experienced Senior Backend-end Developer with a passion for Rust, R&amp;D and Blockchain since 2012.
You can reach Arman Riazi on the following platforms:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
LinkedIn: &lt;https://www.linkedin.com/showcase/armanriazi</li>
<li><input disabled="" type="checkbox" checked=""/>
GitHub: <a href="https://github.com/armanriazi">https://github.com/armanriazi</a></li>
<li><input disabled="" type="checkbox" checked=""/>
Twitter: <a href="https://twitter.com/armanriazi.meta">https://twitter.com/armanriazi.meta</a></li>
<li><input disabled="" type="checkbox" checked=""/>
Email: armanriyazi.github.io📧gmail.com</li>
</ul>
<!-- - [x] Instagram: <https://instagram.com/armanriazi_meta>-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>TypeScript is a superset of JavaScript. It includes all of the features of JavaScript and adds a few additional features like Generics and Interfaces. Dynamically-typed languages are those in which a variable’s type is checked during runtime. This contrasts with static-typed languages in which the variable’s type is checked during compile time. </p>
<p><strong>JavaScript is an interpreted language</strong>, and as such has benefits but also drawbacks. <strong>Interpreted languages do not have a compilation step</strong> and therefore can’t check that all code written has no minor mistakes in spelling or syntax before it is actually run. <em>TypeScript is a strongly typed, object-oriented language that uses a compiler to generate JavaScript. The compiler will identify errors within the code base even before it is run in an interpreter.</em></p>
<p>slowly start to rename js files into a ts file. The <strong>strict typing</strong> syntax is also known as <strong>syntactic sugar</strong>, which can be sprinkled on top of any JavaScript code as and when we please.
The <code>class</code> keyword in TypeScript, similar to JavaScript, is often referred to as syntactic sugar. It was introduced in ECMAScript 2015 (ES6) to offer a more familiar syntax for creating and working with objects in a class-based manner. However, it’s important to note that TypeScript, being a superset of JavaScript, ultimately compiles down to JavaScript, which remains prototype-based at its core.</p>
<h1 id="typescript-features"><a class="header" href="#typescript-features">TypeScript Features</a></h1>
<p>TypeScript can compile code to any released version of JavaScript since ECMAScript 3 (1999). This means that TypeScript can transpile code from the latest JavaScript features to older versions, a process known as Downleveling. This allows the usage of modern JavaScript while maintaining maximum compatibility with older runtime environments.</p>
<p>It’s important to note that during transpilation to an older version of JavaScript, TypeScript may generate code that could incur a performance overhead compared to native implementations.</p>
<p>Here are some of the modern JavaScript features that can be used in TypeScript:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
ECMAScript modules instead of AMD-style “define” callbacks or CommonJS “require” statements.</li>
<li><input disabled="" type="checkbox" checked=""/>
Classes instead of prototypes.</li>
<li><input disabled="" type="checkbox" checked=""/>
Variables declaration using “let” or “const” instead of “var”.</li>
<li><input disabled="" type="checkbox" checked=""/>
“for-of” loop or “.forEach” instead of the traditional “for” loop.</li>
<li><input disabled="" type="checkbox" checked=""/>
Arrow functions instead of function expressions.</li>
<li><input disabled="" type="checkbox" checked=""/>
Destructuring assignment.</li>
<li><input disabled="" type="checkbox" checked=""/>
Shorthand property/method names and computed property names.</li>
<li><input disabled="" type="checkbox" checked=""/>
Default function parameters.</li>
</ul>
<p>By leveraging these modern JavaScript features, developers can write more expressive and concise code in TypeScript.</p>
<p>When we run a TypeScript file, the TypeScript compiler is responsible for transpiling it into a corresponding JavaScript file. This process is known as transpiling, allowing us to run our TypeScript code in environments that only support JavaScript, such as a web browser or a Node server.</p>
<p>The use of the <strong>backtick (`)</strong> to delineate strings gives us the ability to inject values directly into the string, as follows:</p>
<pre><code class="language-typescript">var version = `ES6`;
console.log(`Hello ${version} TypeScript`);
</code></pre>
<h1 id="why-typescript"><a class="header" href="#why-typescript">Why TypeScript</a></h1>
<p>There are two main goals of TypeScript:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Provide an <strong>optional type system</strong> for JavaScript.</li>
<li><input disabled="" type="checkbox" checked=""/>
Provide planned features from <strong>future JavaScript editions</strong> to current JavaScript engines</li>
</ul>
<p>The desire for these goals is motivated below.</p>
<h2 id="the-typescript-type-system"><a class="header" href="#the-typescript-type-system">The TypeScript type system</a></h2>
<p>You might be wondering “<strong>Why add types to JavaScript?</strong>”</p>
<p>Types have proven ability to enhance code quality and understandability. Large teams (Google, Microsoft, Facebook) have continually arrived at this conclusion. Specifically:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Types increase your agility when doing refactoring. <em>It’s better for the compiler to catch errors than to have things fail at runtime</em>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Types are one of the best forms of documentation you can have. <em>The function signature is a theorem and the function body is the proof</em>.</li>
</ul>
<hr />
<h3 id="tsdocs-jsdoc-reference"><a class="header" href="#tsdocs-jsdoc-reference">TsDocs JSDoc Reference</a></h3>
<p>When working with a JavaScript code base, it is possible to help TypeScript to infer the right Type by using JSDoc comments with additional annotation to provide type information.</p>
<p>Example:</p>
<pre><code class="language-typescript">/**
 - [x] Computes the power of a given number
 - [x] @constructor
 - [x] @param {number} base – The base value of the expression
 - [x] @param {number} exponent – The exponent value of the expression
 */
function power(base: number, exponent: number) {
    return Math.pow(base, exponent);
}
power(10, 2); // function power(base: number, exponent: number): number
// console.log(10 ** 2) //eq. 10^2
</code></pre>
<p>Full documentation is provided to this [link](&lt;https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)</p>
<p>From version 3.7 it is possible to generate .d.ts type definitions from JavaScript JSDoc syntax.
More information can be found <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-style-guide-and-coding-conventions"><a class="header" href="#typescript-style-guide-and-coding-conventions">TypeScript Style Guide and Coding Conventions</a></h1>
<blockquote>
<p>An unofficial TypeScript Style Guide</p>
</blockquote>
<p>People have asked me for my opinions on this. Personally I don’t enforce these a lot on my teams and projects but it does help to have these mentioned as a tiebreaker when someone feels the need to have such strong consistency. There are other things that I feel much more strongly about and those are covered in the <a href="styleguide/../tips/main.html">tips chapter</a>.</p>
<p>Key Sections:</p>
<ul>
<li><a href="styleguide/styleguide.html#variable-and-function">Variable</a></li>
<li><a href="styleguide/styleguide.html#class">Class</a></li>
<li><a href="styleguide/styleguide.html#interface">Interface</a></li>
<li><a href="styleguide/styleguide.html#type">Type</a></li>
<li><a href="styleguide/styleguide.html#namespace">Namespace</a></li>
<li><a href="styleguide/styleguide.html#enum">Enum</a></li>
<li><a href="styleguide/styleguide.html#null-vs-undefined"><code>null</code> vs. <code>undefined</code></a></li>
<li><a href="styleguide/styleguide.html#formatting">Formatting</a></li>
<li><a href="styleguide/styleguide.html#quotes">Single vs. Double Quotes</a></li>
<li><a href="styleguide/styleguide.html#spaces">Tabs vs. Spaces</a></li>
<li><a href="styleguide/styleguide.html#semicolons">Use semicolons</a></li>
<li><a href="styleguide/styleguide.html#array">Annotate Arrays as <code>Type[]</code></a></li>
<li><a href="styleguide/styleguide.html#filename">File Names</a></li>
<li><a href="styleguide/styleguide.html#type-vs-interface"><code>type</code> vs <code>interface</code></a></li>
<li><a href="styleguide/styleguide.html#-or-"><code>==</code> or <code>===</code></a></li>
</ul>
<h2 id="variable-and-function"><a class="header" href="#variable-and-function">Variable and Function</a></h2>
<ul>
<li>Use <code>camelCase</code> for variable and function names</li>
</ul>
<blockquote>
<p>Reason: Conventional JavaScript</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">var FooVar;
function BarFunc() { }
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">var fooVar;
function barFunc() { }
</code></pre>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<ul>
<li>Use <code>PascalCase</code> for class names.</li>
</ul>
<blockquote>
<p>Reason: This is actually fairly conventional in standard JavaScript.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">class foo { }
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">class Foo { }
</code></pre>
<ul>
<li>Use <code>camelCase</code> of class members and methods</li>
</ul>
<blockquote>
<p>Reason: Naturally follows from variable and function naming convention.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">class Foo {
    Bar: number;
    Baz() { }
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">class Foo {
    bar: number;
    baz() { }
}
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<ul>
<li>Use <code>PascalCase</code> for name.</li>
</ul>
<blockquote>
<p>Reason: Similar to class</p>
</blockquote>
<ul>
<li>Use <code>camelCase</code> for members.</li>
</ul>
<blockquote>
<p>Reason: Similar to class</p>
</blockquote>
<ul>
<li><strong>Don’t</strong> prefix with <code>I</code></li>
</ul>
<blockquote>
<p>Reason: Unconventional. <code>lib.d.ts</code> defines important interfaces without an <code>I</code> (e.g. Window, Document etc).</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">interface IFoo {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">interface Foo {
}
</code></pre>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<ul>
<li>Use <code>PascalCase</code> for name.</li>
</ul>
<blockquote>
<p>Reason: Similar to class</p>
</blockquote>
<ul>
<li>Use <code>camelCase</code> for members.</li>
</ul>
<blockquote>
<p>Reason: Similar to class</p>
</blockquote>
<h2 id="namespace"><a class="header" href="#namespace">Namespace</a></h2>
<ul>
<li>Use <code>PascalCase</code> for names</li>
</ul>
<blockquote>
<p>Reason: Convention followed by the TypeScript team. Namespaces are effectively just a class with static members. Class names are <code>PascalCase</code> =&gt; Namespace names are <code>PascalCase</code></p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">namespace foo {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">namespace Foo {
}
</code></pre>
<h2 id="enum"><a class="header" href="#enum">Enum</a></h2>
<ul>
<li>Use <code>PascalCase</code> for enum names</li>
</ul>
<blockquote>
<p>Reason: Similar to Class. Is a Type.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">enum color {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">enum Color {
}
</code></pre>
<ul>
<li>Use <code>PascalCase</code> for enum member</li>
</ul>
<blockquote>
<p>Reason: Convention followed by TypeScript team i.e. the language creators e.g <code>SyntaxKind.StringLiteral</code>. Also helps with translation (code generation) of other languages into TypeScript.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">enum Color {
    red
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">enum Color {
    Red
}
</code></pre>
<h2 id="null-vs-undefined"><a class="header" href="#null-vs-undefined">Null vs. Undefined</a></h2>
<ul>
<li>Prefer not to use either for explicit unavailability</li>
</ul>
<blockquote>
<p>Reason: these values are commonly used to keep a consistent structure between values. In TypeScript you use <em>types</em> to denote the structure</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">let foo = { x: 123, y: undefined };
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">let foo: { x: number, y?: number } = { x:123 };
</code></pre>
<ul>
<li>Use <code>undefined</code> in general (do consider returning an object like <code>{valid:boolean, value?:Foo}</code> instead)</li>
</ul>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">return null;
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">return undefined;
</code></pre>
<ul>
<li>Use <code>null</code> where it’s a part of the API or conventional</li>
</ul>
<blockquote>
<p>Reason: It is conventional in Node.js e.g. <code>error</code> is <code>null</code> for NodeBack style callbacks.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">cb(undefined)
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">cb(null)
</code></pre>
<ul>
<li>Use <em>truthy</em> check for <strong>objects</strong> being <code>null</code> or <code>undefined</code></li>
</ul>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">if (error === null)
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">if (error)
</code></pre>
<ul>
<li>Use <code>== null</code> / <code>!= null</code> (not <code>===</code> / <code>!==</code>) to check for <code>null</code> / <code>undefined</code> on primitives as it works for both <code>null</code>/<code>undefined</code> but not other falsy values (like <code>''</code>, <code>0</code>, <code>false</code>) e.g.</li>
</ul>
<p><strong>Bad</strong></p>
<pre><code class="language-typescript">if (error !== null) // does not rule out undefined
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="language-typescript">if (error != null) // rules out both null and undefined
</code></pre>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>The TypeScript compiler ships with a very nice formatting language service. Whatever output it gives by default is good enough to reduce the cognitive overload on the team.</p>
<p>Use <a href="https://github.com/vvakame/typescript-formatter"><code>tsfmt</code></a> to automatically format your code on the command line. Also, your IDE (atom/vscode/vs/sublime) already has formatting support built-in.</p>
<p>Examples:</p>
<pre><code class="language-typescript">// Space before type i.e. foo:&lt;space&gt;string
const foo: string = &quot;hello&quot;;
</code></pre>
<h2 id="quotes"><a class="header" href="#quotes">Quotes</a></h2>
<ul>
<li>Prefer single quotes (<code>'</code>) unless escaping.</li>
</ul>
<blockquote>
<p>Reason: More JavaScript teams do this (e.g. <a href="https://github.com/airbnb/javascript">airbnb</a>, <a href="https://github.com/feross/standard">standard</a>, <a href="https://github.com/npm/npm">npm</a>, <a href="https://github.com/nodejs/node">node</a>, <a href="https://github.com/angular/angular/">google/angular</a>, <a href="https://github.com/facebook/react">facebook/react</a>). It’s easier to type (no shift needed on most keyboards). <a href="https://github.com/prettier/prettier/issues/1105">Prettier team recommends single quotes as well</a></p>
</blockquote>
<blockquote>
<p>Double quotes are not without merit: Allows easier copy paste of objects into JSON. Allows people to use other languages to work without changing their quote character. Allows you to use apostrophes e.g. <code>He's not going.</code>. But I’d rather not deviate from where the JS Community is fairly decided.</p>
</blockquote>
<ul>
<li>When you can’t use double quotes, try using back ticks (`).</li>
</ul>
<blockquote>
<p>Reason: These generally represent the intent of complex enough strings.</p>
</blockquote>
<h2 id="spaces"><a class="header" href="#spaces">Spaces</a></h2>
<ul>
<li>Use <code>2</code> spaces. Not tabs.</li>
</ul>
<blockquote>
<p>Reason: More JavaScript teams do this (e.g. <a href="https://github.com/airbnb/javascript">airbnb</a>, <a href="https://github.com/rwaldron/idiomatic.js">idiomatic</a>, <a href="https://github.com/feross/standard">standard</a>, <a href="https://github.com/npm/npm">npm</a>, <a href="https://github.com/nodejs/node">node</a>, <a href="https://github.com/angular/angular/">google/angular</a>, <a href="https://github.com/facebook/react">facebook/react</a>). The TypeScript/VSCode teams use 4 spaces but are definitely the exception in the ecosystem.</p>
</blockquote>
<h2 id="semicolons"><a class="header" href="#semicolons">Semicolons</a></h2>
<ul>
<li>Use semicolons.</li>
</ul>
<blockquote>
<p>Reasons: Explicit semicolons helps language formatting tools give consistent results. Missing ASI (automatic semicolon insertion) can trip new devs e.g. <code>foo() \n (function(){})</code> will be a single statement (not two). TC39 <a href="https://github.com/tc39/ecma262/pull/1062">warning on this as well</a>. Example teams: <a href="https://github.com/airbnb/javascript">airbnb</a>, <a href="https://github.com/rwaldron/idiomatic.js">idiomatic</a>, <a href="https://github.com/angular/angular/">google/angular</a>, <a href="https://github.com/facebook/react">facebook/react</a>, <a href="https://github.com/Microsoft/TypeScript/">Microsoft/TypeScript</a>.</p>
</blockquote>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<ul>
<li>Annotate arrays as <code>foos: Foo[]</code> instead of <code>foos: Array&lt;Foo&gt;</code>.</li>
</ul>
<blockquote>
<p>Reasons: It’s easier to read. It’s used by the TypeScript team. Makes easier to know something is an array as the mind is trained to detect <code>[]</code>.</p>
</blockquote>
<h2 id="filename"><a class="header" href="#filename">Filename</a></h2>
<p>Name files with <code>camelCase</code>. E.g. <code>utils.ts</code>, <code>map.ts</code> etc.</p>
<blockquote>
<p>Reason: Conventional across many JS teams.</p>
</blockquote>
<p>When the file exports a component and your framework (like React) wants component to be PascalCased, use pascal case file name to match e.g. <code>Accordion.tsx</code>, <code>MyControl.tsx</code>. </p>
<blockquote>
<p>Reason: Helps with consistency (little overthought required) and its what the ecosystem is doing.</p>
</blockquote>
<h2 id="-or-"><a class="header" href="#-or-"><code>==</code> or <code>===</code></a></h2>
<p>Both are <a href="https://www.youtube.com/watch?v=vBhRXMDlA18">mostly safe for TypeScript users</a>. I use <code>===</code> as that is what is used in the TypeScript codebase. </p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-typescript"><a class="header" href="#getting-started-with-typescript">Getting Started With TypeScript</a></h1>
<p>TypeScript compiles into JavaScript. JavaScript is what you are actually going to execute (either in the browser or on the server). So you are going to need the following:</p>
<ul>
<li>TypeScript compiler (OSS available <a href="https://github.com/Microsoft/TypeScript/">in source</a> and on <a href="https://www.npmjs.com/package/typescript">NPM</a>)</li>
<li>A TypeScript editor (you can use notepad if you want but I use <a href="https://code.visualstudio.com/">vscode 🌹</a> with an <a href="https://marketplace.visualstudio.com/items?itemName=armanriazi.god">extension I wrote</a>. Also <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support">lots of other IDES support it as well</a>)</li>
</ul>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<h2 id="npm-security"><a class="header" href="#npm-security">NPM Security</a></h2>
<p>The public <code>npm</code> packages are scanned by security team worldwide and issues get reported to npm team. They then release security advisories detailing the issue and potential fixes. Commonly the fix is simply updating the package. </p>
<p>You can run an audit on your node project by simply running <code>npm audit</code>. This will highlight any vulnerabilities that might exist in the package / dependencies of the package. e.g. </p>
<pre><code>┌───────────────┬──────────────────────────────────────────────────────────────┐
│ Low           │ Regular Expression Denial of Service                         │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Package       │ debug                                                        │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Dependency of │ jest [dev]                                                   │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Path          │ jest &gt; jest-cli &gt; istanbul-lib-source-maps &gt; debug           │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ More info     │ https://nodesecurity.io/advisories/534                       │
└───────────────┴──────────────────────────────────────────────────────────────┘
</code></pre>
<p>Note that commonly the issues are found in <em>development</em> dependencies (e.g. jest in this case). Since these aren’t are a part of your production deployments, most likely your production application is not vulnerable. But still good practice to keep vulnerabilities to <code>0</code>.</p>
<p>Simply add <code>npm audit</code> (the command exist with error code <code>1</code> in case of error) as a part of your deployment to ensure the projects stay up to date.</p>
<h2 id="npm-scripts"><a class="header" href="#npm-scripts">NPM Scripts</a></h2>
<h3 id="what-is-with----in-scripts"><a class="header" href="#what-is-with----in-scripts">What is with <code>--</code> in scripts</a></h3>
<p>You can build a base script with a limited set of command line arguments e.g. here is a script target that runs <code>tsc</code> for the TypeScript compiler: </p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc -p .&quot;
  }
}
</code></pre>
<p>You can create a <code>build:watch</code> target to run <code>tsc -p . -w</code> or alternatively asking npm to run <code>build</code> with the additional <code>-w</code> flag like so: </p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc -p .&quot;,
    &quot;build:watch&quot;: &quot;npm run build -- -w&quot;
  }
}
</code></pre>
<p>You can pass in as many flags as you want after <code>--</code> e.g. in the following example <code>build:more</code> has the same effect as <code>something --foo -f -d --bar</code></p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;something --foo&quot;,
    &quot;build:more&quot;: &quot;npm run build -- -f -d --bar&quot;
  }
}
</code></pre>
<h2 id="typescript-project-configuration-and-tsc-commands"><a class="header" href="#typescript-project-configuration-and-tsc-commands">TypeScript project configuration and TSC commands</a></h2>
<p>This –init option will automatically generate the tsconfig.json file within the current directory.</p>
<pre><code class="language-bash">tsc --init
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-json">{
 &quot;compilerOptions&quot;: {
 &quot;target&quot;: &quot;ES3&quot;,
 &quot;module&quot;: &quot;commonjs&quot;,
 &quot;strict&quot;: true,
 &quot;esModuleInterop&quot;: true,
 &quot;skipLibCheck&quot;: true,
 &quot;forceConsistentCasingInFileNames&quot;: true
 }
}
</code></pre>
<p>Now that we have changed the target version of JavaScript that we wish to generate for, which is now ES6( “target”: “ES6”,), let’s take a look at the output of the compiler in the file hello_typescript.js, as follows:</p>
<pre><code class="language-typescript">&quot;use strict&quot;;
var version = `ES6`;
console.log(`Hello ${version} TypeScript`);
</code></pre>
<p>Ignoring the <strong>“use strict”</strong> line at the top of this file, we can see that the generated JavaScript has not changed from our original TypeScript file.</p>
<p>This shows that the compiler is correctly <strong>generating ES6-compatible JavaScript</strong>, even though we have not modified our original TypeScript file.</p>
<pre><code class="language-bash">tsc -w hello.ts
</code></pre>
<ul>
<li><a href="configuration/cli.html#getting-started-with-typescript">Getting Started with TypeScript</a></li>
<li><a href="configuration/cli.html#typescript-version">TypeScript Version</a></li>
</ul>
<h2 id="typescript-version"><a class="header" href="#typescript-version">TypeScript Version</a></h2>
<p>Instead of using the <em>stable</em> TypeScript compiler we will be presenting a lot of new stuff in this book that may not be associated with a version number yet. I generally recommend people to use the nightly version because <strong>the compiler test suite only catches more bugs over time</strong>.</p>
<p>You can install it on the command line as</p>
<pre><code>npm install -g typescript@next
</code></pre>
<p>And now the command line <code>tsc</code> will be the latest and greatest. Various IDEs support it too, e.g.</p>
<ul>
<li>You can ask vscode to use this version by creating <code>.vscode/settings.json</code> with the following contents:</li>
</ul>
<pre><code class="language-json">{
  &quot;typescript.tsdk&quot;: &quot;./node_modules/typescript/lib&quot;
}
</code></pre>
<h2 id="getting-the-source-code"><a class="header" href="#getting-the-source-code">Getting the Source Code</a></h2>
<p>The source for this book is available in the books github repository https://github.com/armanriazi/typescript-all-in-one/tree/master/code most of the code samples can be copied into vscode and you can play with them as is. For code samples that need additional setup (e.g. npm modules), we will link you to the code sample before presenting the code. e.g.</p>
<p><code>this/will/be/the/link/to/the/code.ts</code></p>
<pre><code class="language-typescript">// This will be the code under discussion
</code></pre>
<h2 id="npm-third-party"><a class="header" href="#npm-third-party">NPM Third Party</a></h2>
<p>the package-lock.json file must also be committed to source control.</p>
<h3 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic versioning</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Patch releases: 1.0 or 1.0.x or ~1.0.4</li>
<li><input disabled="" type="checkbox" checked=""/>
Minor releases: 1 or 1.x or ^1.0.4</li>
<li><input disabled="" type="checkbox" checked=""/>
Major releases: * or x</li>
</ul>
<p>Also, the caret (^) at the start of the package version number in the package.json file. This is used to indicate what can be done if new versions of the package are found during an npm install step. If we use the caret (^), this means that npm will upgrade the package if a new minor version or patch version is found. So “^7.1.0” will upgrade if a minor version number “7.2.0” is found or if a new patch version “7.1.1” is found.</p>
<p>If we use the tilde ( ~ ) character at the start of the version number, as in “~7.1.0”, then only patch versions will be used if a new version is found. So, “~7.1.0” will upgrade if a new patch version “7.1.1” is found, but will not upgrade if a new minor version is found, as in “7.2.0”.</p>
<p>If we do not use a preceding character, and simply leave the version at “7.1.0”, then npm will not attempt to upgrade packages and will leave the version as stated.</p>
<p>When executing the <code>tsc</code> command locally, TypeScript will compile the code using the configuration specified in the nearest tsconfig.json file.</p>
<p>Here are some examples of CLI commands that run with the default settings:</p>
<pre><code class="language-shell">tsc main.ts // Compile a specific file (main.ts) to JavaScript
tsc src/*.ts // Compile any .ts files under the 'src' folder to JavaScript
tsc app.ts util.ts --outfile index.js // Compile two TypeScript files (app.ts and util.ts) into a single JavaScript file (index.js)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-javascript-is-typescript"><a class="header" href="#your-javascript-is-typescript">Your JavaScript is TypeScript</a></h1>
<p>There were (and will continue to be) a lot of competitors in <em>Some syntax</em> to <em>JavaScript</em> compilers. TypeScript is different from them in that <em>Your JavaScript is TypeScript</em>. Here’s a diagram:</p>
<p><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/venn.png" alt="JavaScript is TypeScript" /></p>
<p>However, it does mean that <em>you need to learn JavaScript</em> (the good news is <em>you <strong>only</strong> need to learn JavaScript</em>). TypeScript is just standardizing all the ways you provide <em>good documentation</em> on JavaScript.</p>
<ul>
<li>Just giving you a new syntax doesn’t help catch bugs - but might help you write cleaner / less bugs (e.g. CoffeeScript).</li>
<li>Creating a new language abstracts you too far from your runtimes and communities - but might help on-board you easier if its an already familiar flavour (e.g. Dart - closer for Java / C# devs).</li>
</ul>
<p>TypeScript is just JavaScript with docs.</p>
<blockquote>
<p>JSNext is open to interpretation - not everything proposed for the next version of JS actually makes it to browsers. TypeScript only adds support for proposals once they reach <a href="https://tc39.es/process-document/">stage 3</a>.</p>
</blockquote>
<h2 id="making-javascript-better"><a class="header" href="#making-javascript-better">Making JavaScript Better</a></h2>
<p>TypeScript will try to protect you from portions of JavaScript that never worked (so you don’t need to remember this stuff):</p>
<pre><code class="language-typescript">[] + []; // JavaScript will give you &quot;&quot; (which makes little sense), TypeScript will error

//
// other things that are nonsensical in JavaScript
// - don't give a runtime error (making debugging hard)
// - but TypeScript will give a compile time error (making debugging unnecessary)
//
{} + []; // JS : 0, TS Error
[] + {}; // JS : &quot;[object Object]&quot;, TS Error
{} + {}; // JS : NaN or [object Object][object Object] depending upon browser, TS Error
&quot;hello&quot; - 1; // JS : NaN, TS Error

function add(a,b) {
  return
    a + b; // JS : undefined, TS Error 'unreachable code detected'
}
</code></pre>
<p>Essentially TypeScript is linting JavaScript. Just doing a better job at it than other linters that don’t have <em>type information</em>.</p>
<h2 id="you-still-need-to-learn-javascript"><a class="header" href="#you-still-need-to-learn-javascript">You still need to learn JavaScript</a></h2>
<p>That said TypeScript is very pragmatic about the fact that <em>you do write JavaScript</em> so there are some things about JavaScript that you still need to know in order to not be caught off-guard. Let’s discuss them next.</p>
<blockquote>
<p>Note: TypeScript is a superset of JavaScript. Just with documentation that can actually be used by compilers / IDEs ;)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>One thing to be careful about in JavaScript is the difference between <code>==</code> and <code>===</code>. As JavaScript tries to
be resilient against programming errors <code>==</code> tries to do type coercion between two variables e.g. converts a
string to a number so that you can compare with a number as shown below:</p>
<p>However, the choices JavaScript makes are not always ideal. For example, in the below example the first statement is false
because <code>&quot;&quot;</code> and <code>&quot;0&quot;</code> are both strings and are clearly not equal. However, in the second case both <code>0</code> and the
empty string (<code>&quot;&quot;</code>) are falsy (i.e. behave like <code>false</code>) and are therefore equal with respect to <code>==</code>. Both statements
are false when you use <code>===</code>.</p>
<p>[[Error_Equality]] [[Error_TS2367]]</p>
<!-- skip -->
<pre><code class="language-typescript">console.log(5 == &quot;5&quot;); // true   , TS Error
console.log(5 === &quot;5&quot;); // false , TS Error
console.log(&quot;&quot; == &quot;0&quot;); // false , TS Error
console.log(0 == &quot;&quot;); // true , TS Error
console.log(&quot;&quot; === &quot;0&quot;); // false , TS Error
console.log(0 === &quot;&quot;); // false , TS Error

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2367: This comparison appears to be unintentional because the types 'number' and 'string' have no overlap.
</code></pre>
<blockquote>
<p>Note that <code>string == number</code> and <code>string === number</code> are both compile time errors in TypeScript, so you don’t normally need to worry about this.</p>
</blockquote>
<p>Similar to <code>==</code> vs. <code>===</code>, there is <code>!=</code> vs. <code>!==</code></p>
<p>So ProTip: Always use <code>===</code> and <code>!==</code> except for null checks, which we cover later.</p>
<h2 id="structural-equality"><a class="header" href="#structural-equality">Structural Equality</a></h2>
<p>If you want to compare two objects for structural equality <code>==</code>/<code>===</code> are <em><strong>not</strong></em> sufficient. e.g. </p>
<p><code>&gt;tags:</code> #Important [[Error_Equality]] [[Error_TS2839]]</p>
<!-- skip -->
<pre><code class="language-js">console.log({a:123} == {a:123}); // False
console.log({a:123} === {a:123}); // False
</code></pre>
<p>To do such checks use the <a href="https://www.npmjs.com/package/deep-equal">deep-equal</a> npm package e.g. </p>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2839: This condition will always return 'false' since JavaScript compares objects by reference, not value.
</code></pre>
<p>[[Library_Deep-Equal]]</p>
<pre><code class="language-typescript">import * as deepEqual from &quot;deep-equal&quot;;

console.log(deepEqual({a:123},{a:123})); // True
</code></pre>
<p>However, quite commonly you don’t need deep checks and all you really need is to check by some <code>id</code> e.g. </p>
<pre><code class="language-typescript">type IdDisplay = {
  id: string,
  display: string
}
const list: IdDisplay[] = [
  {
    id: 'foo',
    display: 'Foo Select'
  },
  {
    id: 'bar',
    display: 'Bar Select'
  },
]

const fooIndex = list.map(i =&gt; i.id).indexOf('foo');
console.log(fooIndex); // Output 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Beyond literals, any Object in JavaScript (including functions, arrays, regexp etc) are references. This means the following</p>
<h3 id="mutations-are-across-all-references"><a class="header" href="#mutations-are-across-all-references">Mutations are across all references</a></h3>
<p>[[Error_TS2339]]</p>
<pre><code class="language-js">var foo = {};
var bar = foo; // bar is a reference to the same object

foo.baz = 123;
console.log(bar.baz); // JS Result: 123, TS Result : Error
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2339: Property 'baz' does not exist on type '{}'.
</code></pre>
<h3 id="equality-is-for-references"><a class="header" href="#equality-is-for-references">Equality is for references</a></h3>
<p>[[Error_TS2304]]</p>
<pre><code class="language-js">var foo = {};
var bar = foo; // bar is a reference
var baz = {}; // baz is a *new object* distinct from `foo`

console.log(foo === bar); //JS, TS Result: true
console.log(foo === baz); //JS, TS Result: false
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2304: Cannot find name 'someglobal'.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="this"><a class="header" href="#this">this</a></h2>
<p>Any access to <code>this</code> keyword within a function is controlled by how the function is actually called. It is commonly referred to as the “calling context.”</p>
<p>Here is an example:</p>
<p>[[Error_TS2683]]</p>
<pre><code class="language-typescript">function foo() {
  console.log(this);
}
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md"> error TS2683: 'this' implicitly has type 'any' because it does not have a type annotation.
</code></pre>
<pre><code class="language-typescript">foo(); // logs out the global e.g. `window` in browsers
let bar = {
  foo
}
bar.foo(); // Logs out `bar` as `foo` was called on `bar`
</code></pre>
<p>So be mindful of your usage of <code>this</code>. If you want to disconnect <code>this</code> in a class from the calling context use an arrow function, <a href="javascript/../arrow-functions.html">more on that later</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="number"><a class="header" href="#number">Number</a></h2>
<p>Whenever you are handling numbers in any programming language you need to be aware of the idiosyncrasies of how the language handles numbers. Here are a few critical pieces of information about numbers in JavaScript that you should be aware of.</p>
<h3 id="core-type"><a class="header" href="#core-type">Core Type</a></h3>
<p>JavaScript has only one number type. It is a double-precision 64-bit <code>Number</code>. Below we discuss its limitations along with a recommended solution.</p>
<h3 id="decimal"><a class="header" href="#decimal">Decimal</a></h3>
<p>For those familiar with doubles / float in other languages, you would know that binary floating point numbers <em>do not</em> map correctly to Decimal numbers. A trivial (and famous) example with JavaScript’s built in numbers is shown below:</p>
<pre><code class="language-js">console.log(.1 + .2); // 0.30000000000000004
</code></pre>
<blockquote>
<p>For true decimal math use <code>big.js</code> mentioned below.</p>
</blockquote>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<p>The integer limits represented by the built in number type are <code>Number.MAX_SAFE_INTEGER</code> and <code>Number.MIN_SAFE_INTEGER</code>.</p>
<p>[[MAX_SAFE_INTEGER]]</p>
<pre><code class="language-js">console.log({max: Number.MAX_SAFE_INTEGER, min: Number.MIN_SAFE_INTEGER});
// {max: 9007199254740991, min: -9007199254740991}
</code></pre>
<p><strong>Safe</strong> in this context refers to the fact that the value <em>cannot be the result of a rounding error</em>.</p>
<p>The unsafe values are <code>+1 / -1</code> away from these safe values and any amount of addition / subtraction will <em>round</em> the result.</p>
<pre><code class="language-js">console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true!
console.log(Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2); // true!

console.log(Number.MAX_SAFE_INTEGER);      // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1);  // 9007199254740992 - Correct
console.log(Number.MAX_SAFE_INTEGER + 2);  // 9007199254740992 - Rounded!
console.log(Number.MAX_SAFE_INTEGER + 3);  // 9007199254740994 - Rounded - correct by luck
console.log(Number.MAX_SAFE_INTEGER + 4);  // 9007199254740996 - Rounded!
</code></pre>
<p>To check safety you can use ES6 <code>Number.isSafeInteger</code>:</p>
<pre><code class="language-js">// Safe value
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER)); // true

// Unsafe value
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)); // false

// Because it might have been rounded to it due to overflow
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 10)); // false
</code></pre>
<blockquote>
<p>JavaScript will eventually get <a href="https://developers.google.com/web/updates/2018/05/bigint">BigInt</a> support. For now, if you want arbitrary precision integer math use <code>big.js</code> mentioned below.</p>
</blockquote>
<h3 id="bigjs"><a class="header" href="#bigjs">big.js</a></h3>
<p>Whenever you use math for financial calculations (e.g. GST calculation, money with cents, addition etc) use a library like <a href="https://github.com/MikeMcl/big.js/">big.js</a> which is designed for</p>
<ul>
<li>Perfect decimal math</li>
<li>Safe out of bound integer values</li>
</ul>
<p>Installation is simple:</p>
<pre><code class="language-bash">npm install big.js @types/big.js
</code></pre>
<p>Quick Usage example:</p>
<pre><code class="language-js">import { Big } from 'big.js';

export const foo = new Big('111.11111111111111111111');
export const bar = foo.plus(new Big('0.00000000000000000001'));

// To get a number:
const x: number = Number(bar.toString()); // Loses the precision
</code></pre>
<blockquote>
<p>Do not use this library for math used for UI / performance intensive purposes e.g charts, canvas drawing etc.</p>
</blockquote>
<h3 id="nan"><a class="header" href="#nan">NaN</a></h3>
<p>When some number calculation is not representable by a valid number, JavaScript returns a special <code>NaN</code> value. A  classic example is imaginary numbers:</p>
<pre><code class="language-js">console.log(Math.sqrt(-1)); // NaN
</code></pre>
<p>Note: Equality checks <strong>don’t</strong> work on <code>NaN</code> values. Use <code>Number.isNaN</code> instead:</p>
<pre><code class="language-js">// Don't do this
console.log(NaN === NaN); // false!!

// Do this
console.log(Number.isNaN(NaN)); // true
</code></pre>
<h3 id="infinity"><a class="header" href="#infinity">Infinity</a></h3>
<p>The outer bounds of values representable in Number are available as static <code>Number.MAX_VALUE</code> and <code>-Number.MAX_VALUE</code> values.</p>
<pre><code class="language-js">console.log(Number.MAX_VALUE);  // 1.7976931348623157e+308
console.log(-Number.MAX_VALUE); // -1.7976931348623157e+308
</code></pre>
<p>Values outside the range where precision isn’t changed are clamped to these limits e.g.</p>
<pre><code class="language-js">console.log(Number.MAX_VALUE + 1 == Number.MAX_VALUE);   // true!
console.log(-Number.MAX_VALUE - 1 == -Number.MAX_VALUE); // true!
</code></pre>
<p>Values outside the range where precision is changed resolve to special values <code>Infinity</code>/<code>-Infinity</code> e.g.</p>
<pre><code class="language-js">console.log(Number.MAX_VALUE + 1e292);  // Infinity
console.log(-Number.MAX_VALUE - 1e292); // -Infinity
</code></pre>
<p>Of-course, these special infinity values also show up with arithmetic that requires it e.g.</p>
<pre><code class="language-js">console.log( 1 / 0); // Infinity
console.log(-1 / 0); // -Infinity
</code></pre>
<p>You can use these <code>Infinity</code> values manually or using static members of the <code>Number</code> class as shown below:</p>
<pre><code class="language-js">console.log(Number.POSITIVE_INFINITY === Infinity);  // true
console.log(Number.NEGATIVE_INFINITY === -Infinity); // true
</code></pre>
<p>Fortunately comparison operators (<code>&lt;</code> / <code>&gt;</code>) work reliably on infinity values:</p>
<pre><code class="language-js">console.log( Infinity &gt;  1); // true
console.log(-Infinity &lt; -1); // true
</code></pre>
<h3 id="infinitesimal"><a class="header" href="#infinitesimal">Infinitesimal</a></h3>
<p>The smallest non-zero value representable in Number is available as static <code>Number.MIN_VALUE</code></p>
<pre><code class="language-js">console.log(Number.MIN_VALUE);  // 5e-324
</code></pre>
<p>Values smaller than <code>MIN_VALUE</code> (“underflow values”) are converted to 0.</p>
<pre><code class="language-js">console.log(Number.MIN_VALUE / 10);  // 0
</code></pre>
<blockquote>
<p>Further intuition: Just like values bigger than <code>Number.MAX_VALUE</code> get clamped to INFINITY, values smaller than <code>Number.MIN_VALUE</code> get clamped to <code>0</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="truthy"><a class="header" href="#truthy">Truthy</a></h2>
<p>JavaScript has a concept of <code>truthy</code> i.e. things that evaluate like <code>true</code> would in certain positions (e.g. <code>if</code> conditions and the boolean <code>&amp;&amp;</code> <code>||</code> operators). The following things are truthy in JavaScript. An example is any number other than <code>0</code> e.g.</p>
<pre><code class="language-typescript">if (123) { // Will be treated like `true`
  console.log('Any number other than 0 is truthy');
}
</code></pre>
<p>Something that isn’t truthy is called <code>falsy</code>.</p>
<p>Here’s a handy table for your reference.</p>
<table><thead><tr><th>Variable Type</th><th>When it is <em>falsy</em></th><th>When it is <em>truthy</em></th></tr></thead><tbody>
<tr><td><code>boolean</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>string</code></td><td><code>''</code> (empty string)</td><td>any other string</td></tr>
<tr><td><code>number</code></td><td><code>0</code>  <code>NaN</code></td><td>any other number</td></tr>
<tr><td><code>null</code></td><td>always</td><td>never</td></tr>
<tr><td><code>undefined</code></td><td>always</td><td>never</td></tr>
<tr><td>Any other Object including empty ones like <code>{}</code>,<code>[]</code></td><td>never</td><td>always</td></tr>
</tbody></table>
<h3 id="being-explicit"><a class="header" href="#being-explicit">Being explicit</a></h3>
<blockquote>
<p>The <code>!!</code> pattern</p>
</blockquote>
<p>Quite commonly it helps to be explicit that the intent is to treat the value as a <code>boolean</code> and convert it into a <em>true boolean</em> (one of <code>true</code>|<code>false</code>). You can easily convert values to a true boolean by prefixing it with <code>!!</code> e.g. <code>!!foo</code>. Its just <code>!</code> used <em>twice</em>. The first <code>!</code> converts the variable (in this case <code>foo</code>) to a boolean but inverts the logic (<em>truthy</em> -<code>!</code>&gt; <code>false</code>, <em>falsy</em> -<code>!</code>&gt; <code>true</code>). The second one toggles it again to match the nature of the original object (e.g. <em>truthy</em> -<code>!</code>&gt; <code>false</code> -<code>!</code>&gt; <code>true</code>).</p>
<p>It is common to use this pattern in lots of places e.g.</p>
<pre><code class="language-js">// Direct variables
const hasName = !!name;

// As members of objects
const someObj = {
  hasName: !!name
}

// e.g. in ReactJS JSX
{!!someName &amp;&amp; &lt;div&gt;{someName}&lt;/div&gt;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-with-nodejs"><a class="header" href="#typescript-with-nodejs">TypeScript with Node.js</a></h1>
<p>TypeScript has had <em>first class</em> support for Node.js since inception. Here’s how to setup a quick Node.js project:</p>
<blockquote>
<p>Note: many of these steps are actually just common practice Node.js setup steps</p>
</blockquote>
<ol>
<li>Setup a Node.js project <code>package.json</code>. Quick one : <code>npm init -y</code></li>
<li>Add TypeScript (<code>npm install typescript --save-dev</code>)</li>
<li>Add <code>node.d.ts</code> (<code>npm install @types/node --save-dev</code>)</li>
<li>Init a <code>tsconfig.json</code> for TypeScript options with a few key options in your tsconfig.json (<code>npx tsc --init --rootDir src --outDir lib --esModuleInterop --resolveJsonModule --lib es6,dom  --module commonjs</code>)</li>
</ol>
<p>That’s it! Fire up your IDE (e.g. <code>code .</code>) and play around. Now you can use all the built in node modules (e.g. <code>import * as fs from 'fs';</code>) with all the safety and developer ergonomics of TypeScript! </p>
<p>All your TypeScript code goes in <code>src</code> and the generated JavaScript goes in <code>lib</code>. </p>
<h2 id="bonus-live-compile--run"><a class="header" href="#bonus-live-compile--run">Bonus: Live compile + run</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>ts-node</code> which we will use for live compile + run in node (<code>npm install ts-node --save-dev</code>)</li>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>nodemon</code> which will invoke <code>ts-node</code> whenever a file is changed (<code>npm install nodemon --save-dev</code>)</li>
</ul>
<blockquote>
<p>Now just add a <code>script</code> target to your <code>package.json</code> based on your application entry e.g. assuming its <code>index.ts</code>:</p>
</blockquote>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;npm run build:live&quot;,
    &quot;build&quot;: &quot;tsc -p .&quot;,
    &quot;build:live&quot;: &quot;nodemon --watch 'src/**/*.ts' --exec \&quot;ts-node\&quot; src/index.ts&quot;
  },
</code></pre>
<p>So you can now run <code>npm start</code> and as you edit <code>index.ts</code>:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
nodemon reruns its command (ts-node)</li>
<li><input disabled="" type="checkbox" checked=""/>
ts-node transpiles automatically picking up tsconfig.json and the installed TypeScript version,</li>
<li><input disabled="" type="checkbox" checked=""/>
ts-node runs the output JavaScript through Node.js.</li>
</ul>
<p>And when you are ready to deploy your JavaScript application run <code>npm run build</code>.</p>
<h2 id="node-style-callbacks"><a class="header" href="#node-style-callbacks">Node style callbacks</a></h2>
<p>Node style callback functions (e.g. <code>(err,somethingElse)=&gt;{ /* something */ }</code>) are generally called with <code>err</code> set to <code>null</code> if there isn’t an error. You generally just use a truthy check for this anyways:</p>
<pre><code class="language-typescript">fs.readFile('someFile', 'utf8', (err,data) =&gt; {
  if (err) {
    // do something
  } else {
    // no error
  }
});
</code></pre>
<p>When creating your own APIs it’s <em>okay</em> to use <code>null</code> in this case for consistency. In all sincerity for your own APIs you should look at promises, in that case you actually don’t need to bother with absent error values (you handle them with <code>.then</code> vs. <code>.catch</code>).</p>
<h2 id="bonus-points"><a class="header" href="#bonus-points">Bonus points</a></h2>
<p>Such NPM modules work just fine with browserify (using tsify) or webpack (using ts-loader).</p>
<p><a href="https://github.com/armanriazi/nodejs-projects">Nodejs-projects</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-in-the-browser"><a class="header" href="#typescript-in-the-browser">TypeScript in the browser</a></h1>
<p><a href="https://designtsx.com"><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/designtsx-banner.png" alt="DesignTSX" /></a></p>
<p>If you are using TypeScript to create a web application here are my recommendations to get a quick TypeScript + React (my UI framework of choice) project setup.</p>
<h2 id="general-machine-setup"><a class="header" href="#general-machine-setup">General Machine Setup</a></h2>
<ul>
<li>Install <a href="https://nodejs.org/en/download/">Node.js</a></li>
<li>Install <a href="https://git-scm.com/downloads">Git</a></li>
</ul>
<h2 id="project-setup-quick"><a class="header" href="#project-setup-quick">Project Setup Quick</a></h2>
<p>Use <a href="https://github.com/armanriazi/react-typescript">https://github.com/armanriazi/react-typescript</a> as a base. </p>
<pre><code>git clone https://github.com/armanriazi/react-typescript.git
cd react-typescript
npm install
</code></pre>
<p>Now use it as a base and jump to <a href="quick/browser.html#develop-your-amazing-application">develop your amazing application</a></p>
<h2 id="project-setup-detailed"><a class="header" href="#project-setup-detailed">Project Setup Detailed</a></h2>
<p>If you want to learn more about the details of how that project is created (instead of using it as a base), here are the steps on how its setup from scratch:</p>
<ul>
<li>Create a project dir:</li>
</ul>
<pre><code>mkdir your-project
cd your-project
</code></pre>
<ul>
<li>Create <code>tsconfig.json</code>:</li>
</ul>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;sourceMap&quot;: true,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;esModuleInterop&quot;: true,
    &quot;resolveJsonModule&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;target&quot;: &quot;es5&quot;,
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;lib&quot;: [
      &quot;dom&quot;,
      &quot;es6&quot;
    ]
  },
  &quot;include&quot;: [
    &quot;src&quot;
  ],
  &quot;compileOnSave&quot;: false
}
</code></pre>
<ul>
<li>Create <code>package.json</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;react-typescript&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/armanriazi/react-typescript.git&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack -p&quot;,
    &quot;start&quot;: &quot;webpack-dev-server -d --content-base ./public&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@types/react&quot;: &quot;16.4.10&quot;,
    &quot;@types/react-dom&quot;: &quot;16.0.7&quot;,
    &quot;clean-webpack-plugin&quot;: &quot;0.1.19&quot;,
    &quot;html-webpack-plugin&quot;: &quot;3.2.0&quot;,
    &quot;react&quot;: &quot;16.4.2&quot;,
    &quot;react-dom&quot;: &quot;16.4.2&quot;,
    &quot;ts-loader&quot;: &quot;4.4.2&quot;,
    &quot;typescript&quot;: &quot;3.0.1&quot;,
    &quot;webpack&quot;: &quot;4.16.5&quot;,
    &quot;webpack-cli&quot;: &quot;3.1.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;3.1.5&quot;
  }
}
</code></pre>
<ul>
<li>Create a <code>webpack.config.js</code> to bundle your modules into a single <code>app.js</code> file that contains all your resources:</li>
</ul>
<pre><code class="language-js">const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/app/app.tsx',
  plugins: [
    new CleanWebpackPlugin({
      cleanAfterEveryBuildPatterns: ['public/build']
    }),
    new HtmlWebpackPlugin({
      template: 'src/templates/index.html'
    }),
  ],
  output: {
    path: __dirname + '/public',
    filename: 'build/[name].[contenthash].js'
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.js']
  },
  module: {
    rules: [
      { test: /\.tsx?$/, loader: 'ts-loader' }
    ]
  }
}
</code></pre>
<ul>
<li><code>src/templates/index.html</code> file. It will be used as the template for the <code>index.html</code> generated by webpack. The generated file will be in the <code>public</code> folder and and then served from your webserver: </li>
</ul>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
      &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<ul>
<li><code>src/app/app.tsx</code> that is your frontend application entry point: </li>
</ul>
<pre><code class="language-js">import * as React from 'react';
import * as ReactDOM from 'react-dom';

const Hello: React.FunctionComponent&lt;{ compiler: string, framework: string }&gt; = (props) =&gt; {
  return (
    &lt;div&gt;
      &lt;div&gt;{props.compiler}&lt;/div&gt;
      &lt;div&gt;{props.framework}&lt;/div&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;Hello compiler=&quot;TypeScript&quot; framework=&quot;React&quot; /&gt;,
  document.getElementById(&quot;root&quot;)
);
</code></pre>
<h1 id="develop-your-amazing-application"><a class="header" href="#develop-your-amazing-application">Develop your amazing application</a></h1>
<blockquote>
<p>You can get the latest packages using <code>npm install typescript@latest react@latest react-dom@latest @types/react@latest @types/react-dom@latest webpack@latest webpack-dev-server@latest webpack-cli@latest ts-loader@latest clean-webpack-plugin@latest html-webpack-plugin@latest --save-exact</code></p>
</blockquote>
<ul>
<li>Do live development by running <code>npm start</code>. 
<ul>
<li>Visit <a href="http://localhost:8080">http://localhost:8080</a></li>
<li>Edit the <code>src/app/app.tsx</code> (or any ts/tsx file used in some way by <code>src/app/app.tsx</code>) and application live reloads. </li>
<li>Edit the <code>src/templates/index.html</code> and the server live reloads.</li>
</ul>
</li>
<li>Build production assets by running <code>npm run build</code>. 
<ul>
<li>Serve the <code>public</code> folder (which contains the built assets) from your server.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-typescript-node-modules"><a class="header" href="#creating-typescript-node-modules">Creating TypeScript node modules</a></h1>
<ul>
<li><a href="https://egghead.io/lessons/typescript-create-high-quality-npm-packages-using-typescript">A lesson on creating TypeScript node modules</a></li>
</ul>
<p>Using modules written in TypeScript is super fun as you get great compile time safety and autocomplete (essentially executable documentation).</p>
<p>TypeScript modules can be consumed both in the nodejs (as is) browser (with something like webpack).</p>
<p>Creating a high quality TypeScript module is simple. Assume the following desired folder structure for your package:</p>
<pre><code class="language-text">package
├─ package.json
├─ tsconfig.json
├─ src
│  ├─ index.ts
│  ├─ foo.ts
│  └─ ...All your source files (Authored)
└─ lib
  ├─ index.d.ts.map
  ├─ index.d.ts
  ├─ index.js
  ├─ foo.d.ts.map
  ├─ foo.d.ts
  ├─ foo.js
  └─ ... All your compiled files (Generated)
</code></pre>
<ul>
<li>
<p><code>src/index.ts</code>: Here you would export anything you expect to be consumed from your project. E.g <code>export { Foo } from './foo';</code>. Exporting from this file makes it available for consumption when someone does <code>import { /* Here */ } from 'example';</code></p>
</li>
<li>
<p>In your <code>tsconfig.json</code></p>
<ul>
<li>have <code>compilerOptions</code>: <code>&quot;outDir&quot;: &quot;lib&quot;</code> + <code>&quot;declaration&quot;: true</code> + <code>&quot;declarationMap&quot; : true</code> &lt; This generates <code>.js</code> (JavaScript) <code>.d.ts</code> (declarations for TypeSafety) and <code>.d.ts.map</code> (enables <code>declaration .d.ts</code> =&gt; <code>source .ts</code> IDE navigation) in the lib folder.</li>
<li>have <code>include: [&quot;src&quot;]</code> &lt; This includes all the files from the <code>src</code> dir.</li>
</ul>
</li>
<li>
<p>In your <code>package.json</code> have</p>
<ul>
<li><code>&quot;main&quot;: &quot;lib/index&quot;</code> &lt; This tells to load <code>lib/index.js</code> for runtime code.</li>
<li><code>&quot;types&quot;: &quot;lib/index&quot;</code> &lt; This tells TypeScript to load <code>lib/index.d.ts</code> for type checking. </li>
</ul>
</li>
</ul>
<p>Example package:</p>
<ul>
<li><code>npm install typestyle</code> <a href="https://www.npmjs.com/package/typestyle">for TypeStyle</a></li>
<li>Usage: <code>import { style } from 'typestyle';</code> will be completely type safe.</li>
</ul>
<h3 id="managing-dependencies"><a class="header" href="#managing-dependencies">Managing Dependencies</a></h3>
<h4 id="devdependencies"><a class="header" href="#devdependencies">devDependencies</a></h4>
<ul>
<li>If your package depends on another package while you are developing it (e.g. <code>prettier</code>) you should install them as a <code>devDependency</code>. This way they will not pollute the <code>node_modules</code> of your module’s consumers (as <code>npm i foo</code> does not install <code>devDependencies</code> of <code>foo</code>).</li>
<li><code>typescript</code> is normally a <code>devDependency</code> as you only use it to build your package. The consumers can use your package with or without TypeScript.</li>
<li>If your package depends on other JavaScript authored packages and you want to use it with type safety in your project, put their types (e.g. <code>@types/foo</code>) in <code>devDependencies</code>. JavaScript types should be managed <em>out of bound</em> from the main NPM streams. The JavaScript ecosystem breaks types without semantic versioning too commonly, so if your users need types for these they should install the <code>@types/foo</code> version that works for them. If you want to guide users to install these types you can put them in <code>peerDependencies</code> mentioned next.</li>
</ul>
<h4 id="peerdependencies"><a class="header" href="#peerdependencies">peerDependencies</a></h4>
<p>If your package depends on a package that it heavily <em>works with</em> (as opposed to <em>works using</em>) e.g. <code>react</code>, put them in <code>peerDependencies</code> just like you would with raw JS packages. To test them locally you should also put them in <code>devDependencies</code>. </p>
<p>Now: </p>
<ul>
<li>When you are developing the package you will get the version of the dependency you specified in your <code>devDependencies</code>. </li>
<li>When someone installs your package they will <em>not</em> get this dependency (as <code>npm i foo</code> does not install <code>devDependencies</code> of <code>foo</code>) but they will get a warning that they should install the missing <code>peerDependencies</code> of your package. </li>
</ul>
<h4 id="dependencies"><a class="header" href="#dependencies">dependencies</a></h4>
<p>If your package <em>wraps</em> another package (meant for internal use even after compilation) you should put them in <code>dependencies</code>. Now when someone installs your package they will get your package + any of its dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-vs-var-vs-const"><a class="header" href="#let-vs-var-vs-const">Let vs var vs const</a></h1>
<p>TypeScript uses the <em>const keyword</em>, <strong>which was introduced in ES6</strong>, in order to accomplish this.
Tip: It is best practice to use the let keyword to define variables and not to use the var keyword at all. By using <em>let keyword</em>, we are being <strong>more explicit</strong> about the intended use of these variables, which will help the compiler to pick up any mistakes in our code <strong>where these rules are broken.</strong></p>
<h1 id="readonly-vs-const"><a class="header" href="#readonly-vs-const">readonly vs const</a></h1>
<p>[Readonly difference from const](../types/readonly.md#readonly difference from const)</p>
<h2 id="strong-type-vs-dynamic-type"><a class="header" href="#strong-type-vs-dynamic-type">Strong Type vs Dynamic Type</a></h2>
<p><strong>JavaScript is not strongly typed.</strong> It is a language that is very dynamic, as it allows objects to change their types, properties, and behavior on the fly. <strong>TypeScript, however, is strongly typed</strong> and, as such, will enforce rules that govern how we use variables, functions, and objects.</p>
<p><strong>TypeScript introduces a simple notation using the colon ( : )</strong> symbol to indicate what type a variable should be.</p>
<h2 id="var"><a class="header" href="#var">Var</a></h2>
<pre><code class="language-typescript">// Declare a variable called index with a type of number and assign it the value 0
var index: number = 0;

// If index is equal to 0, create a new block scope with a new variable also called index, but with a type of number and value of 2, and log its value
if (index == 0) {
  var index: number = 2;
  console.log(`index = ${index}`);
}

// Log the value of index
console.log(`index = ${index}`);

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">index = 2
index = 2
</code></pre>
<h2 id="let"><a class="header" href="#let">Let</a></h2>
<pre><code class="language-typescript">// Declare a variable called index with a type of number and assign it the value 0
let index: number = 0;

// If index is equal to 0, create a new block scope with a new variable also called index, but with a type of number and value of 2, and log its value
if (index == 0) {
  let index: number = 2;
  console.log(`index = ${index}`);
}

// Log the value of index
console.log(`index = ${index}`);

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">index = 2
index = 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-1"><a class="header" href="#let-1">Let</a></h1>
<p><code>var</code> Variables in JavaScript are <em>function scoped</em>. This is different from many other languages (C# / Java etc.) where the variables are <em>block scoped</em>. </p>
<pre><code class="language-typescript">// Declare a variable called index with a type of number and assign it the value 0
let index: number = 0;

// If index is equal to 0, create a new block scope with a new variable also called index, but with a type of number and value of 2, and log its value
if (index == 0) {
  let index: number = 2;
  console.log(`index = ${index}`);
}

// Log the value of index
console.log(`index = ${index}`);

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">index = 2
index = 0
</code></pre>
<p><code>&gt; Example:</code></p>
<p>If you bring a <em>block scoped</em> mindset to JavaScript, you would expect the following to print <code>123</code>, but instead it will print <code>456</code>:</p>
<pre><code class="language-typescript">var foo = 123;
if (true) {
    var foo = 456;
}
console.log(foo); // 456
</code></pre>
<p>This is because <code>{</code> does not create a new <em>variable scope</em>. The variable <code>foo</code> is the same inside the if <em>block</em> as it is outside the if block. This is a common source of errors in JavaScript programming. This is why TypeScript (and ES6) introduces the <code>let</code> keyword to allow you to define variables with true <em>block scope</em>. That is if you use <code>let</code> instead of <code>var</code> you get a true unique element disconnected from what you might have defined outside the scope. The same example is demonstrated with <code>let</code>:</p>
<pre><code class="language-typescript">let foo = 123;
if (true) {
    let foo = 456;
}
console.log(foo); // 123
</code></pre>
<p>Another place where <code>let</code> would save you from errors is loops.</p>
<pre><code class="language-typescript">var index = 0;
var array = [1, 2, 3];
for (let index = 0; index &lt; array.length; index++) {
    console.log(array[index]);
}
console.log(index); // 0
</code></pre>
<p>In all sincerity we find it better to use <code>let</code> whenever possible as it leads to fewer surprises for new and existing multi-lingual developers.</p>
<h2 id="functions-create-a-new-scope"><a class="header" href="#functions-create-a-new-scope">Functions create a new scope</a></h2>
<p>Since we mentioned it, we’d like to demonstrate that functions create a new variable scope in JavaScript. Consider the following:</p>
<pre><code class="language-typescript">var foo = 123;
function test() {
    var foo = 456;
}
test();
console.log(foo); // 123
</code></pre>
<p>This behaves as you would expect. Without this it would be very difficult to write code in JavaScript.</p>
<h2 id="generated-js"><a class="header" href="#generated-js">Generated JS</a></h2>
<p>The JS generated by TypeScript is simple renaming of the <code>let</code> variable if a similar name already exists in the surrounding scope. E.g. the following is generated as is with a simple replacement of <code>let</code> with <code>var</code>:</p>
<pre><code class="language-typescript">if (true) {
    let foo = 123;
}

// becomes //

if (true) {
    var foo = 123;
}
</code></pre>
<p>However, if the variable name is already taken by the surrounding scope then a new variable name is generated as shown (notice <code>foo_1</code>):</p>
<pre><code class="language-typescript">var foo = '123';
if (true) {
    let foo = 123;
}

// becomes //

var foo = '123';
if (true) {
    var foo_1 = 123; // Renamed
}
</code></pre>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<p>You can wrap your <code>case</code> bodies in <code>{}</code> to reuse variable names reliably in different <code>case</code> statement as shown below:</p>
<pre><code class="language-typescript">switch (name) {
    case 'x': {
        let x = 5;
        // ...
        break;
    }
    case 'y': {
        let x = 10;
        // ...
        break;
    }
}
</code></pre>
<h3 id="let-in-closures"><a class="header" href="#let-in-closures">let in closures</a></h3>
<p>A common programming interview question for a JavaScript developer is what is the log of this simple file:</p>
<pre><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (var i = 0; i &lt; 3; i++) {
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j &lt; 3; j++) {
    funcs[j]();
}
</code></pre>
<p>One would have expected it to be <code>0,1,2</code>. Surprisingly it is going to be <code>3</code> for all three functions. Reason is that <strong>all three functions are using the variable <code>i</code> from the outer scope</strong> and at the time we execute them (in the second loop) <strong>the value of <code>i</code> will be <code>3</code> (that’s the termination condition for the first loop).</strong></p>
<p>[[Pattern_IIFE]] [[Important]]
A fix would be to create <strong>a new variable in each loop</strong> specific to that loop iteration. As we’ve learnt before we can create a new variable scope by creating a new function and immediately executing it (i.e. the IIFE pattern from classes <code>(function() { /* body */ })();</code>) as shown below:</p>
<pre><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (var i = 0; i &lt; 3; i++) {
    (function() {
        var local = i;
        funcs.push(function() {
            console.log(local);
        })
    })();
}
// call them
for (var j = 0; j &lt; 3; j++) {
    funcs[j]();
}
</code></pre>
<p>Here the functions close over (hence called a <code>closure</code>) the <em>local</em> variable (conveniently named <code>local</code>) and use that instead of the loop variable <code>i</code>.</p>
<blockquote>
<p>Note that closures come with a performance impact (they need to store the surrounding state).</p>
</blockquote>
<p>The ES6 <code>let</code> keyword in a loop would have the same behavior as the previous example:</p>
<pre><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (let i = 0; i &lt; 3; i++) { // Note the use of let
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j &lt; 3; j++) {
    funcs[j]();
}
</code></pre>
<p>Using a <code>let</code> instead of <code>var</code> creates a variable <code>i</code> unique to each loop iteration.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><code>let</code> is extremely useful to have for the vast majority of code. It can greatly enhance your code readability and decrease the chance of a programming error.</p>
<p><a href="https://github.com/olov/defs/blob/master/loop-closures.md">Loop-closures</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-typescript">// Declare a variable called index with a type of number and assign it the value 0
var index: number = 0;

// If index is equal to 0, create a new block scope with a new variable also called index, but with a type of number and value of 2, and log its value
if (index == 0) {
  var index: number = 2;
  console.log(`index = ${index}`);
}

// Log the value of index
console.log(`index = ${index}`);

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">index = 2
index = 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const"><a class="header" href="#const">const</a></h1>
<p><code>const</code> is a very welcomed addition offered by ES6 / TypeScript. It allows you to be immutable with variables. This is good from a documentation as well as a runtime perspective. To use const just replace <code>var</code> with <code>const</code>:</p>
<pre><code class="language-typescript">const foo = 123;
</code></pre>
<p>[[Error_TS2588]]
[[Error_Const]]</p>
<pre><code class="language-typescript">// Declare a variable called constValue with a type of string and assign it the value &quot;this should not be changed&quot;
const constValue = &quot;this should not be changed&quot;;

// Attempt to assign a new value &quot;updated&quot; to constValue
constValue = &quot;updated&quot;;
</code></pre>
<blockquote>
<p>The syntax is much better (IMHO) than other languages that force the user to type something like <code>let constant foo</code> i.e. a variable + behavior specifier.</p>
</blockquote>
<p><code>const</code> is a good practice for both readability and maintainability and avoids using <em>magic literals</em> e.g.</p>
<pre><code class="language-typescript">// Low readability
if (x &gt; 10) {
}

// Better!
const maxRows = 10;
if (x &gt; maxRows) {
}
</code></pre>
<h2 id="const-declarations-must-be-initialized"><a class="header" href="#const-declarations-must-be-initialized">const declarations must be initialized</a></h2>
<p>The following is a compiler error:</p>
<p>[[Error_TS7005]]</p>
<pre><code class="language-typescript">const foo; // ERROR: const declarations must be initialized
</code></pre>
<h2 id="left-hand-side-of-assignment-cannot-be-a-constant"><a class="header" href="#left-hand-side-of-assignment-cannot-be-a-constant">Left hand side of assignment cannot be a constant</a></h2>
<p>Constants are immutable after creation, so if you try to assign them to a new value it is a compiler error:</p>
<p>[[Error_TS2588]]</p>
<pre><code class="language-typescript">const foo = 123;
foo = 456; // ERROR: Left-hand side of an assignment expression cannot be a constant
</code></pre>
<h2 id="block-scoped"><a class="header" href="#block-scoped">Block Scoped</a></h2>
<p>A <code>const</code> is block scoped like we saw with <a href="defination/./let.html"><code>let</code></a>:</p>
<pre><code class="language-typescript">const foo = 123;
if (true) {
    const foo = 456; // Allowed as its a new variable limited to this `if` block
}
</code></pre>
<h2 id="deep-immutability"><a class="header" href="#deep-immutability">Deep immutability</a></h2>
<p>A <code>const</code> works with object literals as well, as far as protecting the variable <em>reference</em> is concerned:
What can you do in Typescript to ensure that a property isn’t mutated?Add readonly</p>
<pre><code class="language-typescript">const foo = { bar: 123 };
foo = { bar: 456 }; // ERROR : Left hand side of an assignment expression cannot be a constant
</code></pre>
<p>However, it still allows sub properties of objects to be mutated, as shown below:</p>
<pre><code class="language-typescript">const foo = { bar: 123 };
foo.bar = 456; // Allowed!
console.log(foo); // { bar: 456 }
</code></pre>
<h2 id="prefer-const"><a class="header" href="#prefer-const">Prefer const</a></h2>
<p>Always use <code>const</code>, unless you plan to either lazily initialization of a variable, or do a reassignment (use <code>let</code> for those cases).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Is it possible to prevent writing on a property by using the modifier readonlywhich makes sure that the property cannot be re-written but does not provide any guarantee of total immutability:</p>
<pre><code class="language-typescript">interface Y {
    readonly a: number;
}

type X = {
    readonly a: number;
};

type J = Readonly&lt;{
    a: number;
}&gt;;

type K = {
    readonly [index: number]: string;
};
</code></pre>
<p>TypeScript’s type system allows you to mark individual properties on an interface as <code>readonly</code>. This allows you to work in a functional way (unexpected mutation is bad):</p>
<pre><code class="language-typescript">function foo(config: {
    readonly bar: number,
    readonly bas: number
}) {
    // ..
}

let config = { bar: 123, bas: 123 };
foo(config);
// You can be sure that `config` isn't changed 🌹
</code></pre>
<p>Of course you can use <code>readonly</code> in <code>interface</code> and <code>type</code> definitions as well e.g.:</p>
<pre><code class="language-typescript">type Foo = {
    readonly bar: number;
    readonly bas: number;
}

// Initialization is okay
let foo: Foo = { bar: 123, bas: 456 };

// Mutation is not
foo.bar = 456; // Error: Left-hand side of assignment expression cannot be a constant or a read-only property
</code></pre>
<p>You can even declare a class property as <code>readonly</code>. You can initialize them at the point of declaration or in the constructor as shown below:</p>
<pre><code class="language-typescript">class Foo {
    readonly bar = 1; // OK
    readonly baz: string;
    constructor() {
        this.baz = &quot;hello&quot;; // OK
    }
}
</code></pre>
<h2 id="readonly"><a class="header" href="#readonly">Readonly</a></h2>
<p>There is a type <code>Readonly</code> that takes a type <code>T</code> and marks all of its properties as <code>readonly</code> using mapped types. Here is a demo that uses it in practice: </p>
<pre><code class="language-typescript">type Foo = {
  bar: number;
  bas: number;
}

type FooReadonly = Readonly&lt;Foo&gt;; 

let foo: Foo = {bar: 123, bas: 456};
let fooReadonly: FooReadonly = {bar: 123, bas: 456};

foo.bar = 456; // Okay
fooReadonly.bar = 456; // ERROR: bar is readonly
</code></pre>
<h4 id="modelling-existing-javascript-apis"><a class="header" href="#modelling-existing-javascript-apis">Modelling existing JavaScript APIs</a></h4>
<p>E.g. <a href="https://codemirror.net/doc/manual.html#option_readOnly">CodeMirror editor has an option <code>readOnly</code></a> that can either be a <code>boolean</code> or the literal string <code>&quot;nocursor&quot;</code> (effective valid values <code>true,false,&quot;nocursor&quot;</code>).  It can be declared as:</p>
<pre><code class="language-typescript">readOnly: boolean | 'nocursor';
</code></pre>
<h3 id="various-use-cases"><a class="header" href="#various-use-cases">Various Use Cases</a></h3>
<h4 id="reactjs"><a class="header" href="#reactjs">ReactJS</a></h4>
<p>One library that loves immutability is ReactJS, you <em>could</em> mark your <code>Props</code> and <code>State</code> to be immutable e.g.:</p>
<pre><code class="language-typescript">interface Props {
    readonly foo: number;
}
interface State {
    readonly bar: number;
}
export class Something extends React.Component&lt;Props,State&gt; {
  someMethod() {
    // You can rest assured no one is going to do
    this.props.foo = 123; // ERROR: (props are immutable)
    this.state.baz = 456; // ERROR: (one should use this.setState)  
  }
}
</code></pre>
<p>You do not need to, however, as the type definitions for React mark these as <code>readonly</code> already (by internally wrapping the passed in generic types with the <code>Readonly</code> type mentioned above).</p>
<pre><code class="language-typescript">export class Something extends React.Component&lt;{ foo: number }, { baz: number }&gt; {
  // You can rest assured no one is going to do
  someMethod() {
    this.props.foo = 123; // ERROR: (props are immutable)
    this.state.baz = 456; // ERROR: (one should use this.setState)  
  }
}
</code></pre>
<h4 id="seamless-immutable"><a class="header" href="#seamless-immutable">Seamless Immutable</a></h4>
<p>You can even mark index signatures as readonly:</p>
<pre><code class="language-typescript">/**
 * Declaration
 */
interface Foo {
    readonly[x: number]: number;
}

/**
 * Usage
 */
let foo: Foo = { 0: 123, 2: 345 };
console.log(foo[0]);   // Okay (reading)
foo[0] = 456;          // Error (mutating): Readonly
</code></pre>
<p>This is great if you want to use native JavaScript arrays in an <em>immutable</em> fashion. In fact TypeScript ships with a <code>ReadonlyArray&lt;T&gt;</code> interface to allow you to do just that:</p>
<pre><code class="language-typescript">let foo: ReadonlyArray&lt;number&gt; = [1, 2, 3];
console.log(foo[0]);   // Okay
foo.push(4);           // Error: `push` does not exist on ReadonlyArray as it mutates the array
foo = foo.concat([4]); // Okay: create a copy
</code></pre>
<h4 id="automatic-inference"><a class="header" href="#automatic-inference">Automatic Inference</a></h4>
<p>In some cases the compiler can automatically infer a particular item to be readonly e.g. within a class if you have a property that only has a getter but no setter, it is assumed readonly e.g.:</p>
<pre><code class="language-typescript">class Person {
    firstName: string = &quot;John&quot;;
    lastName: string = &quot;Doe&quot;;
    get fullName() {
        return this.firstName + this.lastName;
    }
}

const person = new Person();
console.log(person.fullName); // John Doe
person.fullName = &quot;Dear Reader&quot;; // Error! fullName is readonly
</code></pre>
<h3 id="readonly-difference-from-const"><a class="header" href="#readonly-difference-from-const">readonly difference from <code>const</code></a></h3>
<p><code>const</code></p>
<ol>
<li>is for a variable reference</li>
<li>the variable cannot be reassigned to anything else.</li>
</ol>
<p><code>readonly</code> is</p>
<ol>
<li>for a property</li>
<li>the property can be modified because of aliasing</li>
</ol>
<pre><code class="language-typescript">let foo: { readonly bar: number;} = {
        bar: 123
};

function iMutateFoo(foo: { bar: number }) {
    foo.bar = 456;
}

iMutateFoo(foo); // The foo argument is aliased by the foo parameter
console.log(foo.bar); // 456!
</code></pre>
<p>Basically <code>readonly</code> ensures that a property <em>cannot be modified by me</em>, but if you give it to someone that doesn’t have that guarantee (allowed for type compatibility reasons) they can modify it. Of course if <code>iMutateFoo</code> said that they do not mutate <code>foo.bar</code> the compiler would correctly flag it as an error as shown:</p>
<pre><code class="language-typescript">interface Foo {
    readonly bar: number;
}
let foo: Foo = {
    bar: 123
};

function iTakeFoo(foo: Foo) {
    foo.bar = 456; // Error! bar is readonly
}

iTakeFoo(foo); // The foo argument is aliased by the foo parameter
</code></pre>
<p><a href="https://github.com/Microsoft/TypeScript/pull/6532">TypeScript/pull/6532</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="statics"><a class="header" href="#statics">Statics</a></h2>
<p>TypeScript has static members. To access the static members of a class, you can use the class name followed by a dot, without the need to create an object.</p>
<pre><code class="language-typescript">class OfficeWorker {
    static memberCount: number = 0;

    constructor(private name: string) {
        OfficeWorker.memberCount++;
    }
}

const w1 = new OfficeWorker('James');
const w2 = new OfficeWorker('Simon');
const total = OfficeWorker.memberCount;
console.log(total); // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-javascript-now"><a class="header" href="#future-javascript-now">Future JavaScript: Now</a></h1>
<p>One of the main selling points of TypeScript is that it allows you to use a bunch of features from ES6 and beyond in current (ES3 and ES5 level) JavaScript engines (like current browsers and Node.js). Here we deep dive into why these features are useful followed by how these features are implemented in TypeScript.</p>
<p>Note: Not all of these features are slated for immediate addition to JavaScript but provide great utility to your code organization and maintenance. Also note that you are free to ignore any of the constructs that don’t make sense for your project, although you will end up using most of them eventually ;)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="template-literals-template-strings"><a class="header" href="#template-literals-template-strings">Template Literals (Template Strings)</a></h3>
<p>Syntactically these are strings that use backticks ( i.e. ` ) instead of single (’) or double (“) quotes. The motivation of Template Literals is three fold:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
String Interpolation</li>
<li><input disabled="" type="checkbox" checked=""/>
Multiline Strings</li>
<li><input disabled="" type="checkbox" checked=""/>
Tagged Templates</li>
</ul>
<h4 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h4>
<p>Another common use case is when you want to generate some string out of some static strings + some variables. For this you would need some <em>templating logic</em> and this is where <em>template strings</em> originally got their name from. They have since been officially renamed to <em>template literals</em>. Here’s how you would potentially generate an html string previously:</p>
<pre><code class="language-typescript">var lyrics = 'Never gonna give you up';
var html = '&lt;div&gt;' + lyrics + '&lt;/div&gt;';
</code></pre>
<p>Now with template literals you can just do:</p>
<pre><code class="language-typescript">var lyrics = 'Never gonna give you up';
var html = `&lt;div&gt;${lyrics}&lt;/div&gt;`;
</code></pre>
<p>Note that any placeholder inside the interpolation (<code>${</code> and <code>}</code>) is treated as a JavaScript expression and evaluated as such e.g. you can do fancy math.</p>
<pre><code class="language-typescript">console.log(`1 and 1 make ${1 + 1}`);
</code></pre>
<h4 id="multiline-literals"><a class="header" href="#multiline-literals">Multiline Literals</a></h4>
<p>Ever wanted to put a newline in a JavaScript string? Perhaps you wanted to embed some lyrics? You would have needed to <em>escape the literal newline</em> using our favorite escape character <code>\</code>, and then put a new line into the string manually <code>\n</code> at the next line. This is shown below:</p>
<pre><code class="language-typescript">var lyrics = &quot;Never gonna give you up \
\nNever gonna let you down&quot;;
</code></pre>
<p>With TypeScript you can just use a template string:</p>
<pre><code class="language-typescript">var lyrics = `Never gonna give you up
Never gonna let you down`;
</code></pre>
<h4 id="tagged-templates"><a class="header" href="#tagged-templates">Tagged Templates</a></h4>
<p>You can place a function (called a <code>tag</code>) before the template string and it gets the opportunity to pre process the template string literals plus the values of all the placeholder expressions and return a result. A few notes:</p>
<ul>
<li>All the static literals are passed in as an array for the first argument.</li>
<li>All the values of the placeholders expressions are passed in as the remaining arguments. Most commonly you would just use rest parameters to convert these into an array as well.</li>
</ul>
<p>Here is an example where we have a tag function (named <code>htmlEscape</code>) that escapes the html from all the placeholders:</p>
<pre><code class="language-typescript">var say = &quot;a bird in hand &gt; two in the bush&quot;;
var html = htmlEscape `&lt;div&gt; I would just like to say : ${say}&lt;/div&gt;`;

// a sample tag function
function htmlEscape(literals: TemplateStringsArray, ...placeholders: string[]) {
    let result = &quot;&quot;;

    // interleave the literals with the placeholders
    for (let i = 0; i &lt; placeholders.length; i++) {
        result += literals[i];
        result += placeholders[i]
            .replace(/&amp;/g, '&amp;amp;')
            .replace(/&quot;/g, '&amp;quot;')
            .replace(/'/g, '&amp;#39;')
            .replace(/&lt;/g, '&amp;lt;')
            .replace(/&gt;/g, '&amp;gt;');
    }

    // add the last literal
    result += literals[literals.length - 1];
    return result;
}
</code></pre>
<blockquote>
<p>Note: You can annotate <code>placeholders</code> to be any <code>[]</code>. Whatever you annotate it as, TypeScript will type check to make sure the placeholders used to call the tag match the annotation. For example if you expect to deal with <code>string</code> or <code>number</code>s you can annotate <code>...placeholders:(string | number)[]</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h4 id="whats-up-with-the-iife"><a class="header" href="#whats-up-with-the-iife">What’s up with the IIFE</a></h4>
<p>The js generated for the class could have been:</p>
<pre><code class="language-typescript">function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.add = function (point) {
    return new Point(this.x + point.x, this.y + point.y);
};
</code></pre>
<p>The reason it’s wrapped in an Immediately-Invoked Function Expression (IIFE) i.e.</p>
<pre><code class="language-typescript">(function () {

    // BODY

    return Point;
})();
</code></pre>
<p>has to do with inheritance. It allows TypeScript to capture the base class as a variable <code>_super</code> e.g.</p>
<pre><code class="language-typescript">var Point3D = (function (_super) {
    __extends(Point3D, _super);
    function Point3D(x, y, z) {
        _super.call(this, x, y);
        this.z = z;
    }
    Point3D.prototype.add = function (point) {
        var point2D = _super.prototype.add.call(this, point);
        return new Point3D(point2D.x, point2D.y, this.z + point.z);
    };
    return Point3D;
})(Point);
</code></pre>
<p>Notice that the IIFE allows TypeScript to easily capture the base class <code>Point</code> in a <code>_super</code> variable and that is used consistently in the class body.</p>
<h3 id="__extends"><a class="header" href="#__extends"><code>__extends</code></a></h3>
<p>You will notice that as soon as you inherit a class TypeScript also generates the following function:</p>
<pre><code class="language-typescript">var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
</code></pre>
<p>Here <code>d</code> refers to the derived class and <code>b</code> refers to the base class. This function does two things:</p>
<ol>
<li>copies the static members of the base class onto the child class i.e. <code>for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];</code></li>
<li>sets up the child class function’s prototype to optionally lookup members on the parent’s <code>proto</code> i.e. effectively <code>d.prototype.__proto__ = b.prototype</code></li>
</ol>
<p>People rarely have trouble understanding 1, but many people struggle with 2. So an explanation is in order.</p>
<h4 id="dprototype__proto__--bprototype"><a class="header" href="#dprototype__proto__--bprototype"><code>d.prototype.__proto__ = b.prototype</code></a></h4>
<p>After having tutored many people about this I find the following explanation to be simplest. First we will explain how the code from <code>__extends</code> is equivalent to the simple <code>d.prototype.__proto__ = b.prototype</code>, and then why this line in itself is significant. To understand all this you need to know these things:</p>
<ol>
<li><code>__proto__</code></li>
<li><code>prototype</code></li>
<li>effect of <code>new</code> on <code>this</code> inside the called function</li>
<li>effect of <code>new</code> on <code>prototype</code> and <code>__proto__</code></li>
</ol>
<p>All objects in JavaScript contain a <code>__proto__</code> member. This member is often not accessible in older browsers (sometimes documentation refers to this magical property as <code>[[prototype]]</code>). It has one objective: If a property is not found on an object during lookup (e.g. <code>obj.property</code>) then it is looked up at <code>obj.__proto__.property</code>. If it is still not found then <code>obj.__proto__.__proto__.property</code> till either: <em>it is found</em> or <em>the latest <code>.__proto__</code> itself is null</em>. This explains why JavaScript is said to support <em>prototypal inheritance</em> out of the box. This is shown in the following example, which you can run in the chrome console or Node.js:</p>
<pre><code class="language-typescript">var foo = {}

// setup on foo as well as foo.__proto__
foo.bar = 123;
foo.__proto__.bar = 456;

console.log(foo.bar); // 123
delete foo.bar; // remove from object
console.log(foo.bar); // 456
delete foo.__proto__.bar; // remove from foo.__proto__
console.log(foo.bar); // undefined
</code></pre>
<p>Cool so you understand <code>__proto__</code>. Another useful fact is that all <code>function</code>s in JavaScript have a property called <code>prototype</code> and that it has a member <code>constructor</code> pointing back to the function. This is shown below:</p>
<pre><code class="language-typescript">function Foo() { }
console.log(Foo.prototype); // {} i.e. it exists and is not undefined
console.log(Foo.prototype.constructor === Foo); // Has a member called `constructor` pointing back to the function
</code></pre>
<p>Now let’s look at <em>effect of <code>new</code> on <code>this</code> inside the called function</em>. Basically <code>this</code> inside the called function is going to point to the newly created object that will be returned from the function. It’s simple to see if you mutate a property on <code>this</code> inside the function:</p>
<pre><code class="language-typescript">function Foo() {
    this.bar = 123;
}

// call with the new operator
var newFoo = new Foo();
console.log(newFoo.bar); // 123
</code></pre>
<p>Now the only other thing you need to know is that calling <code>new</code> on a function assigns the <code>prototype</code> of the function to the <code>__proto__</code> of the newly created object that is returned from the function call. Here is the code you can run to completely understand it:</p>
<pre><code class="language-typescript">function Foo() { }

var foo = new Foo();

console.log(foo.__proto__ === Foo.prototype); // True!
</code></pre>
<p>That’s it. Now look at the following straight out of <code>__extends</code>. I’ve taken the liberty to number these lines:</p>
<pre><code class="language-typescript">1  function __() { this.constructor = d; }
2   __.prototype = b.prototype;
3   d.prototype = new __();
</code></pre>
<p>Reading this function in reverse the <code>d.prototype = new __()</code> on line 3 effectively means <code>d.prototype = {__proto__ : __.prototype}</code> (because of the effect of <code>new</code> on <code>prototype</code> and <code>__proto__</code>), combining it with the previous line (i.e. line 2 <code>__.prototype = b.prototype;</code>) you get <code>d.prototype = {__proto__ : b.prototype}</code>.</p>
<p>But wait, we wanted <code>d.prototype.__proto__</code> i.e. just the proto changed and maintain the old <code>d.prototype.constructor</code>. This is where the significance of the first line (i.e. <code>function __() { this.constructor = d; }</code>) comes in. Here we will effectively have <code>d.prototype = {__proto__ : __.prototype, constructor : d}</code> (because of the effect of <code>new</code> on <code>this</code> inside the called function). So, since we restore <code>d.prototype.constructor</code>, the only thing we have truly mutated is the <code>__proto__</code> hence <code>d.prototype.__proto__ = b.prototype</code>.</p>
<h4 id="dprototype__proto__--bprototype-significance"><a class="header" href="#dprototype__proto__--bprototype-significance"><code>d.prototype.__proto__ = b.prototype</code> significance</a></h4>
<p>The significance is that it allows you to add member functions to a child class and inherit others from the base class. This is demonstrated by the following simple example:</p>
<pre><code class="language-typescript">function Animal() { }
Animal.prototype.walk = function () { console.log('walk') };

function Bird() { }
Bird.prototype.__proto__ = Animal.prototype;
Bird.prototype.fly = function () { console.log('fly') };

var bird = new Bird();
bird.walk();
bird.fly();
</code></pre>
<p>Basically <code>bird.fly</code> will be looked up from <code>bird.__proto__.fly</code> (remember that <code>new</code> makes the <code>bird.__proto__</code> point to <code>Bird.prototype</code>) and <code>bird.walk</code> (an inherited member) will be looked up from <code>bird.__proto__.__proto__.walk</code> (as <code>bird.__proto__ == Bird.prototype</code> and <code>bird.__proto__.__proto__</code> == <code>Animal.prototype</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="rest-parameters"><a class="header" href="#rest-parameters">Rest Parameters</a></h3>
<p>Rest parameters (denoted by <code>...argumentName</code> for the last argument) allow you to quickly accept multiple arguments in your function and get them as an array. This is demonstrated in the below example.</p>
<pre><code class="language-typescript">function iTakeItAll(first, second, ...allOthers) {
    console.log(allOthers);
}
iTakeItAll('foo', 'bar'); // []
iTakeItAll('foo', 'bar', 'bas', 'qux'); // ['bas','qux']
</code></pre>
<p>Rest parameters can be used in any function be it <code>function</code>/<code>()=&gt;</code>/<code>class member</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<p>The main objective of the spread operator is to <em>spread</em> the elements of an array or object. This is best explained with examples.</p>
<h4 id="apply"><a class="header" href="#apply">Apply</a></h4>
<p>A common use case is to spread an array into the function arguments. Previously you would need to use <code>Function.prototype.apply</code>:</p>
<pre><code class="language-typescript">function foo(x, y, z) { }
var args = [0, 1, 2];
foo.apply(null, args);
</code></pre>
<p>Now you can do this simply by prefixing the arguments with <code>...</code> as shown below:</p>
<pre><code class="language-typescript">function foo(x, y, z) { }
var args = [0, 1, 2];
foo(...args);
</code></pre>
<p>Here we are <em>spreading</em> the <code>args</code> array into positional <code>arguments</code>.</p>
<h4 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h4>
<p>We’ve already seen one usage of this in <em>destructuring</em>:</p>
<pre><code class="language-typescript">var [x, y, ...remaining] = [1, 2, 3, 4];
console.log(x, y, remaining); // 1,2,[3,4]
</code></pre>
<p>The motivation here is to simply make it easy for you to capture the remaining elements of an array when destructuring.</p>
<h4 id="array-assignment"><a class="header" href="#array-assignment">Array Assignment</a></h4>
<p>The spread operator allows you to easily place an <em>expanded version</em> of an array into another array. This is demonstrated in the example below:</p>
<pre><code class="language-typescript">var list = [1, 2];
list = [...list, 3, 4];
console.log(list); // [1,2,3,4]
</code></pre>
<p>You can put the expanded array in at any position, and get the effect you’d expect:</p>
<pre><code class="language-typescript">var list = [1, 2];
list = [0, ...list, 4];
console.log(list); // [0,1,2,4]
</code></pre>
<h4 id="object-spread"><a class="header" href="#object-spread">Object spread</a></h4>
<p>You can also spread an object into another object. A common use case is to simply add a property to an object without mutating the original:</p>
<pre><code class="language-typescript">const point2D = {x: 1, y: 2};
/** Create a new object by using all the point2D props along with z */
const point3D = {...point2D, z: 3};
</code></pre>
<p>For objects, the order of where you put the spread matters.  This works something like <code>Object.assign</code>, and does what you’d expect: what comes first is ‘overridden’ by what comes later:</p>
<pre><code class="language-typescript">const point2D = {x: 1, y: 2};
const anotherPoint3D = {x: 5, z: 4, ...point2D};
console.log(anotherPoint3D); // {x: 1, y: 2, z: 4}
const yetAnotherPoint3D = {...point2D, x: 5, z: 4}
console.log(yetAnotherPoint3D); // {x: 5, y: 2, z: 4}
</code></pre>
<p>Another common use case is a simple shallow extend:</p>
<pre><code class="language-typescript">const foo = {a: 1, b: 2, c: 0};
const bar = {c: 1, d: 2};
/** Merge foo and bar */
const fooBar = {...foo, ...bar};
// fooBar is now {a: 1, b: 2, c: 1, d: 2}
</code></pre>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<p><code>apply</code> is something that you often use in JavaScript, so it’s good to have a better syntax where you don’t have that ugly <code>null</code> for the <code>this</code> argument. Also having a dedicated syntax for moving arrays out of (destructuring) or into (assignment) other arrays provides a neat syntax for when you are doing array processing on partial arrays.</p>
<p><a href="https://github.com/Microsoft/TypeScript/pull/1931"></a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="forof"><a class="header" href="#forof">for…of</a></h3>
<p>A common error experienced by beginning JavaScript developers is that <code>for...in</code> for an array does not iterate over the array items. Instead it iterates over the <em>keys</em> of the object passed in. This is demonstrated in the below example. Here you would expect <code>9,2,5</code> but you get the indexes <code>0,1,2</code>:</p>
<pre><code class="language-typescript">var someArray = [9, 2, 5];
for (var item in someArray) {
    console.log(item); // 0,1,2
}
</code></pre>
<p>This is one of the reasons why <code>for...of</code> exists in TypeScript (and ES6). The following iterates over the array correctly logging out the members as expected:</p>
<pre><code class="language-typescript">var someArray = [9, 2, 5];
for (var item of someArray) {
    console.log(item); // 9,2,5
}
</code></pre>
<p>Similarly TypeScript has no trouble going through a string character by character using <code>for...of</code>:</p>
<pre><code class="language-typescript">var hello = &quot;is it me you're looking for?&quot;;
for (var char of hello) {
    console.log(char); // is it me you're looking for?
}
</code></pre>
<h4 id="js-generation"><a class="header" href="#js-generation">JS Generation</a></h4>
<p>For pre ES6 targets TypeScript will generate the standard <code>for (var i = 0; i &lt; list.length; i++)</code> kind of loop. For example here’s what gets generated for our previous example:</p>
<pre><code class="language-typescript">var someArray = [9, 2, 5];
for (var item of someArray) {
    console.log(item);
}

// becomes //

for (var _i = 0; _i &lt; someArray.length; _i++) {
    var item = someArray[_i];
    console.log(item);
}
</code></pre>
<p>You can see that using <code>for...of</code> makes <em>intent</em> clearer and also decreases the amount of code you have to write (and variable names you need to come up with).</p>
<h4 id="limitations"><a class="header" href="#limitations">Limitations</a></h4>
<p>If you are not targeting ES6 or above, the generated code assumes the property <code>length</code> exists on the object and that the object can be indexed via numbers e.g. <code>obj[2]</code>. So it is only supported on <code>string</code> and <code>array</code> for these legacy JS engines.</p>
<p>If TypeScript can see that you are not using an array or a string it will give you a clear error <em>“is not an array type or a string type”</em>;</p>
<pre><code class="language-typescript">let articleParagraphs = document.querySelectorAll(&quot;article &gt; p&quot;);
// Error: Nodelist is not an array type or a string type
for (let paragraph of articleParagraphs) {
    paragraph.classList.add(&quot;read&quot;);
}
</code></pre>
<p>Use <code>for...of</code> only for stuff that <em>you know</em> to be an array or a string. Note that this limitation might be removed in a future version of TypeScript.</p>
<h4 id="summary-2"><a class="header" href="#summary-2">Summary</a></h4>
<p>You would be surprised at how many times you will be iterating over the elements of an array. The next time you find yourself doing that, give <code>for...of</code> a go. You might just make the next person who reviews your code happy.</p>
<div style="break-before: page; page-break-before: always;"></div><p>What is a traditional callback in TypeScript?
A function that is passed as an argument to another function and is called when the operation is complete.</p>
<h2 id="promise"><a class="header" href="#promise">Promise</a></h2>
<p>The <code>Promise</code> class is something that exists in many modern JavaScript engines and can be easily <a href="https://github.com/stefanpenner/es6-promise">polyfilled</a>. The main motivation for promises is to bring synchronous style error handling to Async / Callback style code.</p>
<h3 id="callback-style-code"><a class="header" href="#callback-style-code">Callback style code</a></h3>
<p>In order to fully appreciate promises let’s present a simple sample that proves the difficulty of creating reliable Async code with just callbacks. Consider the simple case of authoring an async version of loading JSON from a file. A synchronous version of this can be quite simple:</p>
<pre><code class="language-typescript">import fs = require('fs');

function loadJSONSync(filename: string) {
    return JSON.parse(fs.readFileSync(filename));
}

// good json file
console.log(loadJSONSync('good.json'));

// non-existent file, so fs.readFileSync fails
try {
    console.log(loadJSONSync('absent.json'));
}
catch (err) {
    console.log('absent.json error', err.message);
}

// invalid json file i.e. the file exists but contains invalid JSON so JSON.parse fails
try {
    console.log(loadJSONSync('invalid.json'));
}
catch (err) {
    console.log('invalid.json error', err.message);
}
</code></pre>
<p>There are three behaviors of this simple <code>loadJSONSync</code> function, a valid return value, a file system error or a JSON.parse error. We handle the errors with a simple try/catch as you are used to when doing synchronous programming in other languages. Now let’s make a good async version of such a function. A decent initial attempt with trivial error checking logic would be as follows:</p>
<pre><code class="language-typescript">import fs = require('fs');

// A decent initial attempt .... but not correct. We explain the reasons below
function loadJSON(filename: string, cb: (error: Error, data: any) =&gt; void) {
    fs.readFile(filename, function (err, data) {
        if (err) cb(err);
        else cb(null, JSON.parse(data));
    });
}
</code></pre>
<p>Simple enough, it takes a callback, passes any file system errors to the callback. If no file system errors, it returns the <code>JSON.parse</code> result. A few points to keep in mind when working with async functions based on callbacks are:</p>
<ol>
<li>Never call the callback twice.</li>
<li>Never throw an error.</li>
</ol>
<p>However, this simple function fails to accommodate for point two. In fact, <code>JSON.parse</code> throws an error if it is passed bad JSON and the callback never gets called and the application crashes. This is demonstrated in the below example:</p>
<pre><code class="language-typescript">import fs = require('fs');

// A decent initial attempt .... but not correct
function loadJSON(filename: string, cb: (error: Error, data: any) =&gt; void) {
    fs.readFile(filename, function (err, data) {
        if (err) cb(err);
        else cb(null, JSON.parse(data));
    });
}

// load invalid json
loadJSON('invalid.json', function (err, data) {
    // This code never executes
    if (err) console.log('bad.json error', err.message);
    else console.log(data);
});
</code></pre>
<p>A naive attempt at fixing this would be to wrap the <code>JSON.parse</code> in a try catch as shown in the below example:</p>
<pre><code class="language-typescript">import fs = require('fs');

// A better attempt ... but still not correct
function loadJSON(filename: string, cb: (error: Error) =&gt; void) {
    fs.readFile(filename, function (err, data) {
        if (err) {
            cb(err);
        }
        else {
            try {
                cb(null, JSON.parse(data));
            }
            catch (err) {
                cb(err);
            }
        }
    });
}

// load invalid json
loadJSON('invalid.json', function (err, data) {
    if (err) console.log('bad.json error', err.message);
    else console.log(data);
});
</code></pre>
<p>However, there is a subtle bug in this code. If the callback (<code>cb</code>), and not <code>JSON.parse</code>, throws an error, since we wrapped it in a <code>try</code>/<code>catch</code>, the <code>catch</code> executes and we call the callback again i.e. the callback gets called twice! This is demonstrated in the example below:</p>
<pre><code class="language-typescript">import fs = require('fs');

function loadJSON(filename: string, cb: (error: Error) =&gt; void) {
    fs.readFile(filename, function (err, data) {
        if (err) {
            cb(err);
        }
        else {
            try {
                cb(null, JSON.parse(data));
            }
            catch (err) {
                cb(err);
            }
        }
    });
}

// a good file but a bad callback ... gets called again!
loadJSON('good.json', function (err, data) {
    console.log('our callback called');

    if (err) console.log('Error:', err.message);
    else {
        // let's simulate an error by trying to access a property on an undefined variable
        var foo;
        // The following code throws `Error: Cannot read property 'bar' of undefined`
        console.log(foo.bar);
    }
});
</code></pre>
<pre><code class="language-bash">$ node asyncbadcatchdemo.js
our callback called
our callback called
Error: Cannot read property 'bar' of undefined
</code></pre>
<p>This is because our <code>loadJSON</code> function wrongfully wrapped the callback in a <code>try</code> block. There is a simple lesson to remember here.</p>
<blockquote>
<p>Simple lesson: Contain all your sync code in a try catch, except when you call the callback.</p>
</blockquote>
<p>Following this simple lesson, we have a fully functional async version of <code>loadJSON</code> as shown below:</p>
<pre><code class="language-typescript">import fs = require('fs');

function loadJSON(filename: string, cb: (error: Error) =&gt; void) {
    fs.readFile(filename, function (err, data) {
        if (err) return cb(err);
        // Contain all your sync code in a try catch
        try {
            var parsed = JSON.parse(data);
        }
        catch (err) {
            return cb(err);
        }
        // except when you call the callback
        return cb(null, parsed);
    });
}
</code></pre>
<p>Admittedly this is not hard to follow once you’ve done it a few times but nonetheless it’s a lot of boiler plate code to write simply for good error handling. Now let’s look at a better way to tackle asynchronous JavaScript using promises.</p>
<h2 id="creating-a-promise"><a class="header" href="#creating-a-promise">Creating a Promise</a></h2>
<p>A promise can be either <code>pending</code> or <code>fulfilled</code> or <code>rejected</code>.</p>
<p><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/promise%20states%20and%20fates.png" alt="promise states and fates" /></p>
<p>Let’s look at creating a promise. It’s a simple matter of calling <code>new</code> on <code>Promise</code> (the promise constructor). The promise constructor is passed <code>resolve</code> and <code>reject</code> functions for settling the promise state:</p>
<pre><code class="language-typescript">const promise = new Promise((resolve, reject) =&gt; {
    // the resolve / reject functions control the fate of the promise
});
</code></pre>
<h3 id="subscribing-to-the-fate-of-the-promise"><a class="header" href="#subscribing-to-the-fate-of-the-promise">Subscribing to the fate of the promise</a></h3>
<p>The promise fate can be subscribed to using <code>.then</code> (if resolved) or <code>.catch</code> (if rejected).</p>
<pre><code class="language-typescript">const promise = new Promise((resolve, reject) =&gt; {
    resolve(123);
});
promise.then((res) =&gt; {
    console.log('I get called:', res === 123); // I get called: true
});
promise.catch((err) =&gt; {
    // This is never called
});
</code></pre>
<pre><code class="language-typescript">const promise = new Promise((resolve, reject) =&gt; {
    reject(new Error(&quot;Something awful happened&quot;));
});
promise.then((res) =&gt; {
    // This is never called
});
promise.catch((err) =&gt; {
    console.log('I get called:', err.message); // I get called: 'Something awful happened'
});
</code></pre>
<blockquote>
<p>TIP: Promise Shortcuts</p>
</blockquote>
<ul>
<li>Quickly creating an already resolved promise: <code>Promise.resolve(result)</code></li>
<li>Quickly creating an already rejected promise: <code>Promise.reject(error)</code></li>
</ul>
<h3 id="chain-ability-of-promises"><a class="header" href="#chain-ability-of-promises">Chain-ability of Promises</a></h3>
<p>The chain-ability of promises <strong>is the heart of the benefit that promises provide</strong>. Once you have a promise, from that point on, you use the <code>then</code> function to create a chain of promises.</p>
<ul>
<li>If you return a promise from any function in the chain, <code>.then</code> is only called once the value is resolved:</li>
</ul>
<pre><code class="language-typescript">Promise.resolve(123)
    .then((res) =&gt; {
        console.log(res); // 123
        return 456;
    })
    .then((res) =&gt; {
        console.log(res); // 456
        return Promise.resolve(123); // Notice that we are returning a Promise
    })
    .then((res) =&gt; {
        console.log(res); // 123 : Notice that this `then` is called with the resolved value
        return 123;
    })
</code></pre>
<ul>
<li>You can aggregate the error handling of any preceding portion of the chain with a single <code>catch</code>:</li>
</ul>
<pre><code class="language-typescript">// Create a rejected promise
Promise.reject(new Error('something bad happened'))
    .then((res) =&gt; {
        console.log(res); // not called
        return 456;
    })
    .then((res) =&gt; {
        console.log(res); // not called
        return 123;
    })
    .then((res) =&gt; {
        console.log(res); // not called
        return 123;
    })
    .catch((err) =&gt; {
        console.log(err.message); // something bad happened
    });
</code></pre>
<ul>
<li>The <code>catch</code> actually returns a new promise (effectively creating a new promise chain):</li>
</ul>
<pre><code class="language-typescript">// Create a rejected promise
Promise.reject(new Error('something bad happened'))
    .then((res) =&gt; {
        console.log(res); // not called
        return 456;
    })
    .catch((err) =&gt; {
        console.log(err.message); // something bad happened
        return 123;
    })
    .then((res) =&gt; {
        console.log(res); // 123
    })
</code></pre>
<ul>
<li>Any synchronous errors thrown in a <code>then</code> (or <code>catch</code>) result in the returned promise to fail:</li>
</ul>
<pre><code class="language-typescript">Promise.resolve(123)
    .then((res) =&gt; {
        throw new Error('something bad happened'); // throw a synchronous error
        return 456;
    })
    .then((res) =&gt; {
        console.log(res); // never called
        return Promise.resolve(789);
    })
    .catch((err) =&gt; {
        console.log(err.message); // something bad happened
    })
</code></pre>
<ul>
<li>Only the relevant (nearest tailing) <code>catch</code> is called for a given error (as the catch starts a new promise chain).</li>
</ul>
<pre><code class="language-typescript">Promise.resolve(123)
    .then((res) =&gt; {
        throw new Error('something bad happened'); // throw a synchronous error
        return 456;
    })
    .catch((err) =&gt; {
        console.log('first catch: ' + err.message); // something bad happened
        return 123;
    })
    .then((res) =&gt; {
        console.log(res); // 123
        return Promise.resolve(789);
    })
    .catch((err) =&gt; {
        console.log('second catch: ' + err.message); // never called
    })
</code></pre>
<ul>
<li>A <code>catch</code> is only called in case of an error in the preceding chain:</li>
</ul>
<pre><code class="language-typescript">Promise.resolve(123)
    .then((res) =&gt; {
        return 456;
    })
    .catch((err) =&gt; {
        console.log(&quot;HERE&quot;); // never called
    })
</code></pre>
<p>The fact that:</p>
<ul>
<li>errors jump to the tailing <code>catch</code> (and skip any middle <code>then</code> calls) and</li>
<li>synchronous errors also get caught by any tailing <code>catch</code>.</li>
</ul>
<p>effectively provides us with an async programming paradigm that allows better error handling than raw callbacks. More on this below.</p>
<h3 id="typescript-and-promises"><a class="header" href="#typescript-and-promises">TypeScript and promises</a></h3>
<p>The great thing about TypeScript is that it understands the flow of values through a promise chain:</p>
<pre><code class="language-typescript">Promise.resolve(123)
    .then((res) =&gt; {
         // res is inferred to be of type `number`
         return true;
    })
    .then((res) =&gt; {
        // res is inferred to be of type `boolean`

    });
</code></pre>
<p>Of course it also understands unwrapping any function calls that might return a promise:</p>
<pre><code class="language-typescript">function iReturnPromiseAfter1Second(): Promise&lt;string&gt; {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; resolve(&quot;Hello world!&quot;), 1000);
    });
}

Promise.resolve(123)
    .then((res) =&gt; {
        // res is inferred to be of type `number`
        return iReturnPromiseAfter1Second(); // We are returning `Promise&lt;string&gt;`
    })
    .then((res) =&gt; {
        // res is inferred to be of type `string`
        console.log(res); // Hello world!
    });
</code></pre>
<h3 id="converting-a-callback-style-function-to-return-a-promise"><a class="header" href="#converting-a-callback-style-function-to-return-a-promise">Converting a callback style function to return a promise</a></h3>
<p>Just wrap the function call in a promise and</p>
<ul>
<li><code>reject</code> if an error occurs,</li>
<li><code>resolve</code> if it is all good.</li>
</ul>
<p>E.g. let’s wrap <code>fs.readFile</code>:</p>
<pre><code class="language-typescript">import fs = require('fs');
function readFileAsync(filename: string): Promise&lt;any&gt; {
    return new Promise((resolve,reject) =&gt; {
        fs.readFile(filename,(err,result) =&gt; {
            if (err) reject(err);
            else resolve(result);
        });
    });
}
</code></pre>
<p>The most reliable way to do this is to hand write it and it doesn’t have to be as verbose as the previous example e.g. converting <code>setTimeout</code> into a promisified <code>delay</code> function is super easy:</p>
<pre><code class="language-typescript">const delay = (ms: number) =&gt; new Promise(res =&gt; setTimeout(res, ms));
</code></pre>
<p>Note that there is a handy dandy function in NodeJS that does this <code>node style function =&gt; promise returning function</code> magic for you:</p>
<pre><code class="language-typescript">/** Sample usage */
import fs from 'fs';
import util from 'util';
const readFile = util.promisify(fs.readFile);
</code></pre>
<blockquote>
<p>Webpack supports the <code>util</code> module out of the box and you can use it in the browser as well.</p>
</blockquote>
<p>If you have a node callback style function as a <em>member</em> be sure to <code>bind</code> it as well to make sure it has the correct <code>this</code>: </p>
<pre><code class="language-typescript">const dbGet = util.promisify(db.get).bind(db);
</code></pre>
<h3 id="revisiting-the-json-example"><a class="header" href="#revisiting-the-json-example">Revisiting the JSON example</a></h3>
<p>Now let’s revisit our <code>loadJSON</code> example and rewrite an async version that uses promises. All that we need to do is read the file contents as a promise, then parse them as JSON and we are done. This is illustrated in the below example:</p>
<pre><code class="language-typescript">function loadJSONAsync(filename: string): Promise&lt;any&gt; {
    return readFileAsync(filename) // Use the function we just wrote
                .then(function (res) {
                    return JSON.parse(res);
                });
}
</code></pre>
<p>Usage (notice how similar it is to the original <code>sync</code> version introduced at the start of this section 🌹):</p>
<pre><code class="language-typescript">// good json file
loadJSONAsync('good.json')
    .then(function (val) { console.log(val); })
    .catch(function (err) {
        console.log('good.json error', err.message); // never called
    })

// non-existent json file
    .then(function () {
        return loadJSONAsync('absent.json');
    })
    .then(function (val) { console.log(val); }) // never called
    .catch(function (err) {
        console.log('absent.json error', err.message);
    })

// invalid json file
    .then(function () {
        return loadJSONAsync('invalid.json');
    })
    .then(function (val) { console.log(val); }) // never called
    .catch(function (err) {
        console.log('bad.json error', err.message);
    });
</code></pre>
<p>The reason why this function was simpler is because the “<code>loadFile</code>(async) + <code>JSON.parse</code> (sync) =&gt; <code>catch</code>” consolidation was done by the promise chain. Also the callback was not called by <em>us</em> but called by the promise chain so we didn’t have the chance of making the mistake of wrapping it in a <code>try/catch</code>.</p>
<h3 id="parallel-control-flow"><a class="header" href="#parallel-control-flow">Parallel control flow</a></h3>
<p>We have seen how trivial doing a serial sequence of async tasks is with promises. It is simply a matter of chaining <code>then</code> calls.</p>
<p>However, you might potentially want to run a series of async tasks and then do something with the results of all of these tasks. <code>Promise</code> provides a static <code>Promise.all</code> function that you can use to wait for <code>n</code> number of promises to complete. You provide it with an array of <code>n</code> promises and it gives you an array of <code>n</code> resolved values. Below we show Chaining as well as Parallel:</p>
<pre><code class="language-typescript">// an async function to simulate loading an item from some server
function loadItem(id: number): Promise&lt;{ id: number }&gt; {
    return new Promise((resolve) =&gt; {
        console.log('loading item', id);
        setTimeout(() =&gt; { // simulate a server delay
            resolve({ id: id });
        }, 1000);
    });
}

// Chained / Sequential
let item1, item2;
loadItem(1)
    .then((res) =&gt; {
        item1 = res;
        return loadItem(2);
    })
    .then((res) =&gt; {
        item2 = res;
        console.log('done');
    }); // overall time will be around 2s

// Concurrent / Parallel
Promise.all([loadItem(1), loadItem(2)])
    .then((res) =&gt; {
        [item1, item2] = res;
        console.log('done');
    }); // overall time will be around 1s
</code></pre>
<p>Sometimes, you want to run a series of async tasks, but you get all you need as long as any one of these tasks is settled. <code>Promise</code> provides a static <code>Promise.race</code> function for this scenario:</p>
<pre><code class="language-typescript">var task1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 1000, 'one');
});
var task2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 2000, 'two');
});

Promise.race([task1, task2]).then(function(value) {
  console.log(value); // &quot;one&quot;
  // Both resolve, but task1 resolves faster
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asynchronous-language-features"><a class="header" href="#asynchronous-language-features">Asynchronous Language Features</a></h2>
<p>As TypeScript is a superset of JavaScript, it has built-in asynchronous language features of JavaScript as:</p>
<p>Promises:</p>
<p>Promises are a way to handle asynchronous operations and their results using methods like <code>.then()</code> and <code>.catch()</code> to handle success and error conditions.</p>
<p>To learn more: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>
<p><code>Async/await:</code></p>
<p>Async/await keywords are a way to provide a more synchronous-looking syntax for working with Promises. The <code>async</code> keyword is used to define an asynchronous function, and the <code>await</code> keyword is used within an async function to pause execution until a Promise is resolved or rejected.</p>
<p>How does async work?
This function takes a callback function as a parameter.
we are using two callback functions, namely afterWait and executeAfterTimeout, there is only one asynchronous call in this example.This asynchronous call is the call to the setTimeout function.</p>
<pre><code class="language-typescript">function delayedResponseWithCallback(callback: () =&gt; void) {
    function executeAfterTimeout() {
      console.log(`5. executeAfterTimeout()`);
      // This line calls the callback function passed in as a parameter
      callback();
    }
  
    console.log(`2. calling setTimeout`)
  
    // This line schedules the executeAfterTimeout function to be called after 1000 ms
    setTimeout(executeAfterTimeout, 1000);
  
    console.log(`3. after calling setTimeout`)
  }
  
  function callDelayedAndWait() {

    // Define another function called afterWait
    function afterWait() {
      console.log(`6. afterWait()`);
    }
  
    // Log message to console indicating that delayedResponseWithCallback will be called
    console.log(`1. calling delayedResponseWithCallback`);
  
    // Call delayedResponseWithCallback function, passing in the afterWait function as an argument
    delayedResponseWithCallback(afterWait);
  
    // Log message to console indicating that delayedResponseWithCallback has been called
    console.log(`4. after calling delayedResponseWithCallback`);
  }
  
  // Call the callDelayedAndWait function
  callDelayedAndWait();
</code></pre>
<p>what is known as callback hell, where we have so many callbacks that are nested in other callbacks that the code becomes increasingly difficult to read and maintain.</p>
<p>e.g.,</p>
<pre><code class="language-typescript">// Import the 'fs' module and use it to read the contents of different text files.
import * as fs from &quot;fs&quot;;
// The 'readFile' function is used to read the contents of the first text file, 'test1.txt'.
fs.readFile(&quot;./test1.txt&quot;, (err, data) =&gt; {
  if (err) {
    console.log(`an error occurred : ${err}`);
  } else {
    console.log(`test1.txt contents : ${data}`);
    // The 'readFile' function is used to read the contents of the second text file, 'test1.txt'.
    fs.readFile(&quot;./test2.txt&quot;, (err, data) =&gt; {
      if (err) {
        console.log(`an error occurred : ${err}`);
      } else {
        console.log(`test2.txt contents : ${data}`);
        // The 'readFile' function is used to read the contents of the third text file, 'test1.txt'.
        fs.readFile(&quot;./test3.txt&quot;, (err, data) =&gt; {
          if (err) {
            console.log(`an error occurred : ${err}`);
          } else {
            console.log(`test3.txt contents
                : ${data}`);
          }
        });
      }
    });
  }
});
</code></pre>
<p><code>To learn more:</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await</a></p>
<p>The following API are well supported in TypeScript:</p>
<p><code>Fetch API:</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a></p>
<p><code>Web Workers:</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API</a></p>
<p><code>Shared Workers:</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker</a></p>
<p><code>WebSocket:</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a></p>
<h2 id="promise-1"><a class="header" href="#promise-1">Promise</a></h2>
<p>To make asynchronous code a lot simpler and to <strong>eliminate callback hell</strong>, many different JavaScript libraries implemented similar design patterns to make the syntax of callbacks easier to work with.
The Promise mechanism also allows us to <strong>chain multiple asynchronous calls</strong> one after another, and this technique is known as <strong>fluent syntax</strong>. Another technique is known as async and await, where we mark certain functions as asynchronous, and we can then use the await keyword to pause the execution flow of our code until the asynchronous function returns.</p>
<p>Note: A Promise-based asynchronous call is also referred to as being thenable, meaning that we can attach a then function to the original function call.</p>
<pre><code class="language-typescript">// Use the promises version of the fs module to read test1.txt
fs.promises.readFile(&quot;./test1.txt&quot;)
  // Once test1.txt is read, log the contents to the console and then read test2.txt
  .then((value) =&gt; {
    console.log(`ps test1.txt read : ${value}`);
    return fs.promises.readFile(&quot;./test2.txt&quot;);
  })
  // Once test2.txt is read, log the contents to the console and then read test3.txt
  .then((value) =&gt; {
    console.log(`ps test2.txt read : ${value}`);
    return fs.promises.readFile(&quot;./test3.txt&quot;);
  })
  // Once test3.txt is read, log the contents to the console
  .then((value) =&gt; {
    console.log(`ps test3.txt read : ${value}`);
  })
  // If an error occurs at any point in the chain, log the error to the console
  .catch((error) =&gt; {
    console.log(`an error occurred : ${error}`);
  });

</code></pre>
<p><code>Writing Promises</code></p>
<p>A Promise is an instance of a new Promise class whose constructor requires a function signature that accepts two callback functions, generally named resolve and reject.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Firstly, to use a Promise, we must return a new Promise object.</li>
<li><input disabled="" type="checkbox" checked=""/>
Secondly, a Promise object is constructed with a function that takes two callback arguments, generally named resolve and reject.</li>
</ul>
<p>We can clearly see from the output the sequence of events that our code is executing from the logged output:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Our first console log occurs just before we call the errorPromise function.</li>
<li><input disabled="" type="checkbox" checked=""/>
The second log output occurs within our Promise itself, just before we call the reject callback on the Promise.</li>
<li><input disabled="" type="checkbox" checked=""/>
The third log output message occurs within our catch block.</li>
</ul>
<p>Consider the following function definition:</p>
<pre><code class="language-typescript">// This function takes two arguments, both of which are functions.
function fnDelayedPromise(
    resolve: () =&gt; void, // This function will be called when the promise is resolved.
    reject: () =&gt; void   // This function will be called when the promise is rejected.
) {
    // This function will be called after a timeout of 1000ms (1 second).
    function afterTimeout() {
        resolve();
    }
    // Set a timeout of 1000ms and call the afterTimeout function when the timeout expires.
    setTimeout(afterTimeout, 1000);
}
// This function returns a Promise that resolves after a delay.
function delayedResponsePromise(): Promise&lt;void&gt; {
    // Create a new Promise object that takes a function as an argument.
    return new Promise&lt;void&gt;(fnDelayedPromise);
}
delayedPromise().then(() =&gt; {
  console.log(`delayed promise returned`);
});
function errorPromise(): Promise&lt;void&gt; {
 return new Promise&lt;void&gt;(
 ( // constructor
 resolve: () =&gt; void,
 reject: () =&gt; void
 ) =&gt; {
 // function definition
 console.log(`2. calling reject()`);
 reject();
 }
 )
}
console.log(`1. calling errorPromise()`);
errorPromise().then(() =&gt; { })
 .catch(() =&gt; { console.log(`3. caught an error`) });
</code></pre>
<h2 id="async-await"><a class="header" href="#async-await">Async Await</a></h2>
<blockquote>
<p><a href="https://egghead.io/courses/async-await-using-typescript">A PRO egghead video course that covers the same material</a></p>
</blockquote>
<p>As a thought experiment imagine the following: a way to tell the JavaScript runtime to pause the executing of code on the <code>await</code> keyword when used on a promise and resume <em>only</em> once (and if) the promise returned from the function is settled:</p>
<pre><code class="language-typescript">// Not actual code. A thought experiment
async function foo() {
    try {
        var val = await getMeAPromise();
        console.log(val);
    }
    catch(err) {
        console.log('Error: ', err.message);
    }
}
</code></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The await keyword will pause execution of our code block until the Promise has returned. If we need to use the - - [x] await keyword, then we must mark the function that it is used in with the async keyword.</li>
</ul>
<p>When the promise settles execution continues,</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
if it was fulfilled then await will return the value,</li>
<li><input disabled="" type="checkbox" checked=""/>
if it’s rejected an error will be thrown synchronously which we can catch.</li>
</ul>
<p>This suddenly (and magically) makes asynchronous programming as easy as synchronous programming.  Three things needed for this thought experiment are:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Ability to <strong>pause function</strong> execution.</li>
<li><input disabled="" type="checkbox" checked=""/>
Ability to <strong>put a value inside</strong> the function.</li>
<li><input disabled="" type="checkbox" checked=""/>
Ability to <strong>throw an exception inside</strong> the function.</li>
</ul>
<p>This is exactly what generators allowed us to do! The thought experiment <em>is actually real</em> and so is the <code>async</code>/<code>await</code> implementation in TypeScript / JavaScript. Under the covers it just uses generators.</p>
<h3 id="generated-javascript"><a class="header" href="#generated-javascript">Generated JavaScript</a></h3>
<p>You don’t have to understand this, but it’s fairly simple if you’ve <a href="async/../generators">read up on generators</a>. The function <code>foo</code> can be simply wrapped up as follows:</p>
<pre><code class="language-typescript">const foo = wrapToReturnPromise(function* () {
    try {
        var val = yield getMeAPromise();
        console.log(val);
    }
    catch(err) {
        console.log('Error: ', err.message);
    }
});
</code></pre>
<p>where the <code>wrapToReturnPromise</code> just executes the generator function to get the <code>generator</code> and then use <code>generator.next()</code>, if the value is a <code>promise</code> it would <code>then</code>+<code>catch</code> the promise and depending upon the result call <code>generator.next(result)</code> or <code>generator.throw(error)</code>. That’s it!</p>
<h3 id="callbacks-vs-promises-vs-async"><a class="header" href="#callbacks-vs-promises-vs-async">Callbacks vs. Promises vs. Async</a></h3>
<p><code>Callbacks</code></p>
<pre><code class="language-typescript">function usingCallbacks() {
 function afterCallbackSuccess() {
 // execute when the callback succeeds
 }
 function afterCallbackFailure() {
 // execute when the callback fails
 }
 // call a function and provide both callbacks
 invokeAsync(afterCallbackSuccess, afterCallbackFailure);
 // code here does not wait for callback to execute
}
</code></pre>
<p><code>Promise</code></p>
<pre><code class="language-typescript">function usingPromises() {
 delayedPromise().then(
 () =&gt; {
 // execute on success
 }
 ).catch(
 () =&gt; {
 // execute on error
 }
 )
 // code here does not wait for promise to return
}
</code></pre>
<p><code>Async-Await</code></p>
<pre><code class="language-typescript">async function usingAsync() {
 try {
 await delayedPromise();
 // continue to next line of code on error
 } catch(error) {
 // execute on error
 }
 // code here waits for async call to complete
}
</code></pre>
<h3 id="async-await-support-in-typescript"><a class="header" href="#async-await-support-in-typescript">Async Await Support in TypeScript</a></h3>
<p><strong>Async - Await</strong> has been supported by <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html">TypeScript since version 1.7</a>. Asynchronous functions are prefixed with the <em>async</em> keyword; <em>await</em> suspends the execution until an asynchronous function <strong>return promise</strong> is fulfilled and <strong>unwraps the value from the Promise</strong> returned.
It was only supported for <strong>target es6</strong> transpiling directly to <strong>ES6 generators</strong>.</p>
<p><strong>TypeScript 2.1</strong> <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html">added the capability to ES3 and ES5 run-times</a>, meaning you’ll be free to take advantage of it no matter what environment you’re using. It’s important to notice that we can use async / await with TypeScript 2.1 and many browsers are supported, of course, having globally added a <strong>polyfill for Promise</strong>.</p>
<p>Let’s see this example and take a look at this code to figure out how TypeScript async / await notation works: </p>
<pre><code class="language-typescript">function delay(milliseconds: number, count: number): Promise&lt;number&gt; {
    return new Promise&lt;number&gt;(resolve =&gt; {
            setTimeout(() =&gt; {
                resolve(count);
            }, milliseconds);
        });
}

// async function always returns a Promise
async function dramaticWelcome(): Promise&lt;void&gt; {
    console.log(&quot;Hello&quot;);

    for (let i = 0; i &lt; 5; i++) {
        // await is converting Promise&lt;number&gt; into number
        const count: number = await delay(500, i);
        console.log(count);
    }

    console.log(&quot;World!&quot;);
}

dramaticWelcome();
</code></pre>
<p><strong>Transpiling to ES6 (–target es6)</strong></p>
<pre><code class="language-js">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function delay(milliseconds, count) {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; {
            resolve(count);
        }, milliseconds);
    });
}
// async function always returns a Promise
function dramaticWelcome() {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(&quot;Hello&quot;);
        for (let i = 0; i &lt; 5; i++) {
            // await is converting Promise&lt;number&gt; into number
            const count = yield delay(500, i);
            console.log(count);
        }
        console.log(&quot;World!&quot;);
    });
}
dramaticWelcome();
</code></pre>
<p>You can see full example <a href="https://cdn.rawgit.com/armanriazi/typescript-all-in-one/705e4496/code/async-await/es6/asyncAwaitES6.js">here</a>.</p>
<p><strong>Transpiling to ES5 (–target es5)</strong></p>
<pre><code class="language-js">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), &quot;throw&quot;: verb(1), &quot;return&quot;: verb(2) }, typeof Symbol === &quot;function&quot; &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError(&quot;Generator is already executing.&quot;);
        while (_) try {
            if (f = 1, y &amp;&amp; (t = y[op[0] &amp; 2 ? &quot;return&quot; : op[0] ? &quot;throw&quot; : &quot;next&quot;]) &amp;&amp; !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 &amp;&amp; (!t || (op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }
                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function delay(milliseconds, count) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve(count);
        }, milliseconds);
    });
}
// async function always returns a Promise
function dramaticWelcome() {
    return __awaiter(this, void 0, void 0, function () {
        var i, count;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log(&quot;Hello&quot;);
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i &lt; 5)) return [3 /*break*/, 4];
                    return [4 /*yield*/, delay(500, i)];
                case 2:
                    count = _a.sent();
                    console.log(count);
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    console.log(&quot;World!&quot;);
                    return [2 /*return*/];
            }
        });
    });
}
dramaticWelcome();
</code></pre>
<p>You can see full example <a href="https://cdn.rawgit.com/armanriazi/typescript-all-in-one/705e4496/code/async-await/es5/asyncAwaitES5.js">here</a>.</p>
<p><strong>Note</strong>: for both target scenarios, we need to make sure our run-time has an ECMAScript-compliant Promise available globally. That might involve grabbing a polyfill for Promise. We also need to make sure that TypeScript knows Promise exists by setting our lib flag to something like “dom”, “es2015” or “dom”, “es2015.promise”, “es5”. 
<strong>We can see what browsers DO have Promise support (native and polyfilled) <a href="https://kangax.github.io/compat-table/es6/#test-Promise">here</a>.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project"><a class="header" href="#project">Project</a></h1>
<p>To create a successful project using TypeScript you need to understand the various project organization language features available. In this section we will cover “compilation context”, declaration spaces and modules.</p>
<h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>Also, the caret (^) at the start of the package version number in the package.json file. This is used to indicate what can be done if new versions of the package are found during an npm install step. If we use the caret (^), this means that npm will upgrade the package if a new minor version or patch version is found. So “^7.1.0” will upgrade if a minor version number “7.2.0” is found or if a new patch version “7.1.1” is found.</p>
<p>If we use the tilde ( ~ ) character at the start of the version number, as in “~7.1.0”, then only patch versions will be used if a new version is found. So, “~7.1.0” will upgrade if a new patch version “7.1.1” is found, but will not upgrade if a new minor version is found, as in “7.2.0”.</p>
<p>If we do not use a preceding character, and simply leave the version at “7.1.0”, then npm will not attempt to upgrade packages and will leave the version as stated.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="migrating-from-javascript"><a class="header" href="#migrating-from-javascript">Migrating From JavaScript</a></h2>
<p><strong>Boris Yankov set up a GitHub repository</strong> to house TypeScript declaration files for third-party libraries. This repository, named Definitely Typed, quickly became very popular and is now the go-to repository for declaration files.</p>
<p>The community has, over time, built a number of command-line tools to help with this, including <strong>tsd, typings, and NuGet extensions</strong>.</p>
<p>Airbnb recently went through the process of converting their existing React-based JavaScript projects to TypeScript, and have published an opensource project named <strong>ts-migrate</strong> to help other teams do the same thing.</p>
<p>Note: This popularity has also meant that the TypeScript team itself has included a tool for searching for types on their <a href="https://www.typescriptlang.org/dt/search?search=">website</a> named Type Search. Here, we can search for type declaration files and, as can be seen in the help text, declaration files that are either bundled or in the Definitely Typed repository.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Declaration files, including:
<ul>
<li>Global variables</li>
<li>JavaScript code embedded in HTML</li>
<li>Finding declaration files with npm</li>
<li>Writing declaration files</li>
<li>Using the module keyword</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Declaration file typing</li>
<li><input disabled="" type="checkbox" checked=""/>
The allowJs and outDir options</li>
<li><input disabled="" type="checkbox" checked=""/>
Compiling JavaScript</li>
<li><input disabled="" type="checkbox" checked=""/>
The declaration option</li>
</ul>
<p>Assuming:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
you know JavaScript.</li>
<li><input disabled="" type="checkbox" checked=""/>
you know patterns and build tools (e.g. webpack) used in the project. </li>
</ul>
<p>With that assumption out of the way, in general the process consists of the following steps:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Add a <code>tsconfig.json</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Change your source code file extensions from <code>.js</code> to <code>.ts</code>. Start <em>suppressing</em> errors using <code>any</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Write new code in TypeScript and make as little use of <code>any</code> as possible.</li>
<li><input disabled="" type="checkbox" checked=""/>
Go back to the old code and start adding type annotations and fix identified bugs.</li>
<li><input disabled="" type="checkbox" checked=""/>
Use ambient definitions for third party JavaScript code.</li>
</ul>
<p>Let us discuss a few of these points further.</p>
<p>Note that all JavaScript is <em>valid</em> TypeScript. That is to say that if you give the TypeScript compiler some JavaScript -&gt; the JavaScript emitted by the TypeScript compiler will behave exactly the same as the original JavaScript. This means that changing the extension from <code>.js</code> to <code>.ts</code> will not adversely affect your codebase.</p>
<h3 id="the-declaration-option"><a class="header" href="#the-declaration-option">The declaration option</a></h3>
<p>The final TypeScript compilation option that we will discuss here is the declaration option, which will generate declaration files from our source TypeScript or our source JavaScript files.</p>
<p>We can turn this option on by uncommenting it in the tsconfig.js file as follows:</p>
<pre><code class="language-json">{
 &quot;compilerOptions&quot;: {
 &quot;target&quot;: &quot;es5&quot;,
 &quot;module&quot;: &quot;commonjs&quot;,
 &quot;allowJs&quot;: true,
 &quot;declaration&quot;: true,
 ... other options
 }
}
</code></pre>
<h3 id="suppressing-errors"><a class="header" href="#suppressing-errors">Suppressing Errors</a></h3>
<p>TypeScript will immediately start TypeChecking your code and your original JavaScript code <em>might not be as neat as you thought it was</em> and hence you get diagnostic errors. Many of these errors you can suppress with using <code>any</code> e.g.:</p>
<blockquote>
<p><code>Sample of writing declaration file</code> projects of typescript-all-in-one-&gt; Ref.to ErrorHelper, ReadME</p>
</blockquote>
<pre><code class="language-typescript">var foo = 123;
var bar = 'hey';

bar = foo; // ERROR: cannot assign a number to a string
</code></pre>
<p>Even though the <strong>error is valid</strong> (and in most cases the inferred information will be better than what the original authors of different portions of the code bases imagined), your focus will probably be writing new code in TypeScript while progressively updating the old code base. Here you can suppress this error with a type assertion as shown below:</p>
<pre><code class="language-typescript">var foo = 123;
var bar = 'hey';

bar = foo as any; // Okay!
</code></pre>
<p>In other places you might want to annotate something as <code>any</code> e.g.:</p>
<pre><code class="language-typescript">function foo() {
    return 1;
}
var bar = 'hey';
bar = foo(); // ERROR: cannot assign a number to a string
</code></pre>
<p>Suppressed:</p>
<pre><code class="language-typescript">function foo(): any { // Added `any`
    return 1;
}
var bar = 'hey';
bar = foo(); // Okay!
</code></pre>
<blockquote>
<p>Note: Suppressing errors is dangerous, but it allows you to take notice of errors in your <em>new</em> TypeScript code. You might want to leave <code>// TODO:</code> comments as you go along.**</p>
</blockquote>
<h3 id="third-party-javascript"><a class="header" href="#third-party-javascript">Third Party JavaScript</a></h3>
<p>You can change your JavaScript to TypeScript, but you can’t change the whole world to use TypeScript. This is where TypeScript’s ambient definition support comes in. In the beginning we recommend you create a <code>vendor.d.ts</code> (the <code>.d.ts</code> extension specifies the fact that this is a <em>declaration file</em>) and start adding dirty stuff to it. Alternatively create a file specific for the library e.g. <code>jquery.d.ts</code> for jquery.</p>
<blockquote>
<p>Note: Well maintained and strongly typed definitions for nearly the top 90% JavaScript libraries out there exists in an OSS Repository called <a href="https://github.com/borisyankov/DefinitelyTyped">DefinitelyTyped</a>. We recommend looking there before creating your own definitions as we present here. Nevertheless this quick and dirty way is vital knowledge to decrease your initial friction with TypeScript**.</p>
</blockquote>
<p>Consider the case of <code>jquery</code>, you can create a <em>trivial</em> definition for it quite easily:</p>
<pre><code class="language-typescript">declare var $: any;
</code></pre>
<p>Sometimes you might want to add an explicit annotation on something (e.g. <code>JQuery</code>) and you need something in <strong>type declaration space</strong>. You can do that quite easily using the <code>type</code> keyword:</p>
<pre><code class="language-typescript">declare type JQuery = any;
declare var $: JQuery;
</code></pre>
<p>This provides you an easier future update path.</p>
<p>Again, a high quality <code>jquery.d.ts</code> exists at <a href="https://github.com/borisyankov/DefinitelyTyped">DefinitelyTyped</a>. But you now know how to overcome any JavaScript -&gt; TypeScript friction <em>quickly</em> when using third party JavaScript. We will look at ambient declarations in detail next.</p>
<h1 id="third-party-npm-modules"><a class="header" href="#third-party-npm-modules">Third Party NPM modules</a></h1>
<p>Similar to global variable declaration you can declare a global module quite easily. E.g. for <code>jquery</code> if you want to use it as a module (https://www.npmjs.com/package/jquery) you can write the following yourself: </p>
<pre><code class="language-typescript">declare module &quot;jquery&quot;;
</code></pre>
<p>And then you can import it in your file as needed: </p>
<pre><code class="language-typescript">import * as $ from &quot;jquery&quot;;
</code></pre>
<h2 id="external-non-js-resources"><a class="header" href="#external-non-js-resources">External non js resources</a></h2>
<p>You can even allow import of any file e.g. <code>.css</code> files (if you are using something like webpack style loaders or css modules) with a simple <code>*</code> style declaration (ideally in a <a href="types/../project/globals.html"><code>global.d.ts</code> file</a>): </p>
<pre><code class="language-typescript">declare module &quot;*.css&quot;;
</code></pre>
<p>Now people can <code>import * as foo from &quot;./some/file.css&quot;;</code></p>
<p>Similarly if you are using html templates (e.g. angular) you can: </p>
<pre><code class="language-typescript">declare module &quot;*.html&quot;;
</code></pre>
<h1 id="more"><a class="header" href="#more">More</a></h1>
<p>If you want to be more silent about your upgrade because you couldn’t get team buy in to move to TypeScript, <a href="https://devblogs.microsoft.com/typescript/how-to-upgrade-to-typescript-without-anybody-noticing-part-1/">TypeScript has a blog post on upgrading silently without having to convince your team up front</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<p>A tsconfig.json file is used to configure the TypeScript Compiler (tsc). Usually, it is added to the root of the project, together with the <code>package.json</code> file.</p>
<p>Notes:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
tsconfig.json accepts comments even if it is in json format.</li>
<li><input disabled="" type="checkbox" checked=""/>
It is advisable to use this configuration file instead of the command-line options.</li>
</ul>
<p>At the following link you can find the complete documentation and its schema:</p>
<p><a href="https://www.typescriptlang.org/tsconfig">https://www.typescriptlang.org/tsconfig</a></p>
<p><a href="http://json.schemastore.org/tsconfig">http://json.schemastore.org/tsconfig</a></p>
<p>The following represents a list of the common and useful configurations:
It is extremely easy to get started with tsconfig.json as the basic file you need is:</p>
<pre><code class="language-json">{}
</code></pre>
<p>i.e. an empty JSON file at the <em>root</em> of your project. This way TypeScript will include <em>all</em> the <code>.ts</code> files in this directory (and sub directories) as a part of the compilation context. It will also select a few sane default compiler options.</p>
<h3 id="es6-modules"><a class="header" href="#es6-modules">ES6 Modules</a></h3>
<p>TypeScript does support ES6 (ECMAScript 2015) and many subsequent versions. This means you can use ES6 syntax, such as arrow functions, template literals, classes, modules, destructuring, and more.</p>
<p>To enable ES6 features in your project, you can specify the <code>target</code> property in the tsconfig.json.</p>
<p>A configuration example:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es6&quot;,
    &quot;module&quot;: &quot;es6&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;outDir&quot;: &quot;dist&quot;
  },
  &quot;include&quot;: [&quot;src&quot;]
}
</code></pre>
<h2 id="compilation-context"><a class="header" href="#compilation-context">Compilation Context</a></h2>
<p>The compilation context is basically just a fancy term for grouping of the files that TypeScript will parse and analyze to determine what is valid and what isn’t. Along with the information about which files, the compilation context contains information about <em>which compiler options</em> are in use. A great way to define this logical grouping (we also like to use the term <em>project</em>) is using a <code>tsconfig.json</code> file.</p>
<h3 id="compileroptions"><a class="header" href="#compileroptions">compilerOptions</a></h3>
<p>You can customize the compiler options using <code>compilerOptions</code>:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {

    /* Basic Options */                       
    &quot;target&quot;: &quot;es5&quot;,                       /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */
    &quot;module&quot;: &quot;commonjs&quot;,                  /* Specify module code generation: 'commonjs', 'amd', 'system', 'umd' or 'es2015'. */
    &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation:  */
    &quot;allowJs&quot;: true,                       /* Allow JavaScript files to be compiled. */
    &quot;checkJs&quot;: true,                       /* Report errors in .js files. */
    &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    &quot;declaration&quot;: true,                   /* Generates corresponding '.d.ts' file. */
    &quot;sourceMap&quot;: true,                     /* Generates corresponding '.map' file. */
    &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */
    &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */
    &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    &quot;removeComments&quot;: true,                /* Do not emit comments to output. */
    &quot;noEmit&quot;: true,                        /* Do not emit outputs. */
    &quot;importHelpers&quot;: true,                 /* Import emit helpers from 'tslib'. */
    &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
                                              
    /* Strict Type-Checking Options */     
    /// As an example, these strict options can determine if a variable could be undefined at the time of use or if the variable itself is never used.   
    &quot;strict&quot;: true,                        /* Enable all strict type-checking options. */
    &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied 'any' type. For new projects use TypeScript configuration **noImplicitAny** which enables TypeScript to issue errors where any is used or inferred. */
    &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */
    &quot;noImplicitThis&quot;: true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */
                                              
    /* Additional Checks */                   
    &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */
    &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */
    &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */
    &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */
                                              
    /* Module Resolution Options */           
    &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */
    &quot;paths&quot;: {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */
    &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */
    &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
                                              
    /* Source Map Options */                  
    &quot;sourceRoot&quot;: &quot;./&quot;,                    /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    &quot;mapRoot&quot;: &quot;./&quot;,                       /* Specify the location where debugger should locate map files instead of generated locations. */
    &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */
    &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
                                              
    /* Experimental Options */                
    &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */
    &quot;emitDecoratorMetadata&quot;: true          /* Enables experimental support for emitting type metadata for decorators. */
  }
}
</code></pre>
<p>These (and more) compiler options will be discussed later.</p>
<h3 id="typescript-compiler"><a class="header" href="#typescript-compiler">TypeScript compiler</a></h3>
<p>Good IDEs come with built in support for on the fly <code>ts</code> to <code>js</code> compilation. However, if you want to run the TypeScript compiler manually from the command line when using <code>tsconfig.json</code>, you can do it in a few ways:</p>
<ul>
<li>Just run <code>tsc</code> and it will look for <code>tsconfig.json</code> in the current as well as all parent folders till it finds it.</li>
<li>Run <code>tsc -p ./path-to-project-directory</code>. Of course the path can be absolute or relative to the current directory.</li>
</ul>
<p>You can even start the TypeScript compiler in <em>watch</em> mode using <code>tsc -w</code> and it will watch your TypeScript project files for changes.</p>
<h4 id="target"><a class="header" href="#target">target</a></h4>
<p>The “target” property is used to specify which version of JavaScript ECMAScript version your TypeScript should emit/compile into. For modern browsers ES6 is a good option, for older browsers, ES5 is recommended.</p>
<h4 id="lib"><a class="header" href="#lib">lib</a></h4>
<p>The “lib” property is used to specify which library files to include at compilation time. TypeScript automatically includes APIs for features specified in the “target” property, but it is possible to omit or pick specific libraries for particular needs. For instance, if you are working on a server project, you could exclude the “DOM” library, which is useful only in a browser environment.</p>
<h3 id="the-declaration-option-1"><a class="header" href="#the-declaration-option-1">The declaration option</a></h3>
<p>The final TypeScript compilation option that we will discuss here is the declaration option, which will generate declaration files from our source TypeScript or our source JavaScript files.</p>
<p>We can turn this option on by uncommenting it in the tsconfig.js file as follows:</p>
<pre><code class="language-json">    &quot;outDir&quot;: &quot;dist&quot;,  
    &quot;allowJs&quot;:true,
    &quot;declaration&quot;: true,   
    &quot;declarationMap&quot;: true,
</code></pre>
<p>For example:</p>
<pre><code class="language-typescript">// Interface defining filterable object
interface IFilterable {
  name?: string;
}

// Function to filter undefined values in an array of filterable objects
function filterUndefined&lt;T extends IFilterable&gt;
  (input: Array&lt;T&gt;): Array&lt;T&gt; 
{
  let output: Array&lt;T&gt; = [];
  for (let item of input) {
    // Check if name property exists and is not null or undefined
    if (item.name?.length) {
      output.push(item);
    }
  }
  return output;
}
</code></pre>
<p>Generated declaration file</p>
<pre><code class="language-typescript">// Interface defining filterable object
interface IFilterable {
  name?: string;
}

// Function signature to filter undefined values in an array of filterable objects
declare function filterUndefined&lt;T extends IFilterable&gt;(input: Array&lt;T&gt;): Array&lt;T&gt;;

// Caption: Declare function signature to filter undefined values in an array of filterable objects based on name property.

</code></pre>
<h3 id="subdirectory-tsconfigjson"><a class="header" href="#subdirectory-tsconfigjson">Subdirectory tsconfig.json</a></h3>
<p>Let’s take a look at the tsconfig.json file in the sub1 directory:</p>
<pre><code class="language-typescript">{
 &quot;extends&quot;: &quot;../tsconfig&quot;, // point to the parent config file
 &quot;compilerOptions&quot;: {
 /* Strict Type-Checking Options */
 &quot;outDir&quot;: &quot;../dist&quot;,
 &quot;allowJs&quot;: true,
 &quot;strict&quot;: false
 }
}
</code></pre>
<h4 id="strict"><a class="header" href="#strict">strict</a></h4>
<p>The “strict” property enables stronger guarantees and enhances type safety. It is advisable to always include this property in your project’s tsconfig.json file. Enabling the “strict” property allows TypeScript to:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Emit code using “use strict” for each source file.</li>
<li><input disabled="" type="checkbox" checked=""/>
Consider “null” and “undefined” in the type checking process.</li>
<li><input disabled="" type="checkbox" checked=""/>
Disable the usage of the “any” type when no type annotations are present.</li>
<li><input disabled="" type="checkbox" checked=""/>
Raise an error on the usage of the “this” expression, which would otherwise imply the “any” type.</li>
</ul>
<h4 id="strictnullchecks"><a class="header" href="#strictnullchecks">strictNullChecks</a></h4>
<p><code>strictNullChecks</code> is a TypeScript compiler option that enforces strict null checking. When this option is enabled, variables and parameters can only be assigned <code>null</code> or <code>undefined</code> if they have been explicitly declared to be of that type using the union type <code>null</code> | <code>undefined</code>. If a variable or parameter is not explicitly declared as nullable, TypeScript will generate an error to prevent potential runtime errors. 
This means that when the variable is actually used if it <strong>has not been properly initialized</strong>, the compiler will generate an error message.</p>
<pre><code class="language-typescript">let a: number;
let b = a;
</code></pre>
<p><code>&gt;tags:</code> [[Error_TS2454]] [[Error_strictNullChecks]]</p>
<pre><code class="language-md">error TS2454: Variable 'a' is used before being assigned.
</code></pre>
<p><code>&gt; Solution:</code></p>
<pre><code class="language-typescript">let a: number | undefined;
let b = a;
</code></pre>
<h3 id="strictnullchecks-1"><a class="header" href="#strictnullchecks-1">strictNullChecks</a></h3>
<p>Back to strictNullChecks. The definition says that when the flag is not enabled, null and undefined values are in the domain of every type. In other words, null and undefined values belong to sets corresponding to every type. It means we can have null , undefined in domain types of string, number, or pipes. but when strictNullChecks to be true, it means null, undefined are known singleton type so they will categorize in different type of string, number, or pipes.</p>
<h3 id="strictpropertyinitialization"><a class="header" href="#strictpropertyinitialization">strictPropertyInitialization</a></h3>
<p>The strictPropertyInitialization compiler option will check that all properties within a class have been initialized correctly.
Ensure non-undefined class properties are initialized in the constructor.
The concept is similar to the strictNullChecks option that we just discussed, but it extends into class properties.</p>
<p>Note: In order to use the strictPropertyInitialization option, we also need to enable the strictNullChecks option at the same time, or the compiler will return an error stating this.</p>
<p>Consider the following class definition:</p>
<p><code>&gt;tags:</code> [[Error_ TS2564]] [[Error_strictPropertyInitialization]] [[Error_constructor]]</p>
<pre><code class="language-typescript">class WithoutInit {
    a: number;
    b: string;
}
</code></pre>
<p><code>&gt; Solution:</code></p>
<p>Firstly, we can use a type union, as we did with strictNullChecks, as follows:</p>
<pre><code class="language-typescript">class WithoutInit {
    a: number | undefined;
    b: string | undefined;
}
</code></pre>
<p>OR:</p>
<pre><code class="language-typescript">class WithoutInit {
    a!: number;
    b!: string;
}
</code></pre>
<p>OR:</p>
<pre><code class="language-typescript">class WithoutInit {
    a: number = 1;
    b: string = &quot;test&quot;;
}
</code></pre>
<p>OR:</p>
<pre><code class="language-typescript">class WithoutInit {
    a: number;
    b: string;
    constructor(a: number) {
        this.a = a;
        this.b = &quot;test&quot;;
    }
}
</code></pre>
<h3 id="strictbindcallapply"><a class="header" href="#strictbindcallapply">strictBindCallApply</a></h3>
<p>JavaScript provides the bind, call, and apply functions that are used to override the value of the this variable inside a function. When using the bind, call, and apply functions, we essentially provide a particular version of the object that the function should use as the value for this and then invoke the function with the parameters it requires. The strictBindCallApply option ensures that we provide these function parameters with the correct types.</p>
<h3 id="strictfunctiontypes"><a class="header" href="#strictfunctiontypes">strictFunctionTypes</a></h3>
<p>When we define types in TypeScript and then attempt to assign them to each other, the compiler makes sure that the types are consistent. Unfortunately, this strict typing rule did not apply correctly in some circumstances when dealing with functions.</p>
<p>The strictFunctionTypes option corrects this behavior.</p>
<p><code>&gt;tags:</code> [[Error_TS2322]] [[Error_TS2345]] [[Error_strictFunctionTypes]] </p>
<pre><code class="language-typescript">// Error TS2322
let numberOrString: number | string;
let numberOnly: number = numberOrString;
//OR Error TS2345
function withCallback(
    fn: (a: number | string) =&gt; void
) {
    fn(&quot;test&quot;);
}
function withNumberOnly(a: number) {
    console.log(`a : ${a}`);
}
withCallback(withNumberOnly);
</code></pre>
<h3 id="no-keys"><a class="header" href="#no-keys">no Keys</a></h3>
<p>There are also a number of compiler options that are prefixed with the word <code>no</code>. These options are similar to the strict options in that they further <strong>guard our code</strong> <em>against things like unused parameters, implicit returns, and implicit any.</em></p>
<p>In this lesson, we will take a look at these compiler options and how they can detect potential errors within our code. These parameters are similar in nature to strict parameters in that they can be turned on or off and can be introduced into a code base gradually.</p>
<p>Note: <em>If the strict compiler option has been set to true, then all of these options will be enabled as well.</em></p>
<p><code>&gt;tags:</code> [[Error_TS5055]] [[Error_noImplicitAny]]</p>
<pre><code class="language-ts">declare function testImplicityAny();
//OR
function testNoParamType(value) { }

class TestAny {
    id;
}
</code></pre>
<p><code>&gt; Solution:</code></p>
<pre><code class="language-ts">declare function testImplicityAny(): void;
//
function testNoParamType(value: string) { }

class TestAny {
    id : any;
}
</code></pre>
<h3 id="noimplicitany"><a class="header" href="#noimplicitany">noImplicitAny</a></h3>
<p>In the example below, the <strong>return type of getName is inferred as any</strong>. This means that you can break type safety not only inside the function but also in the places it’s being used.</p>
<pre><code class="language-ts">function getName(person) {
  return person.name;
}
</code></pre>
<h3 id="the-nounusedlocals-and-nounusedparameters-options"><a class="header" href="#the-nounusedlocals-and-nounusedparameters-options">The noUnusedLocals and noUnusedParameters options</a></h3>
<p>The noUnusedLocals and noUnusedParameter compiler options are used to detect variables or parameters that are not used and are, therefore, superfluous.</p>
<p><code>&gt;tags:</code> [[Error_TS5055]] [[Error_noUnusedLocals]] [[Error_noUnusedParameters]]</p>
<p>Consider the following code:</p>
<pre><code class="language-ts">function testFunction(input: string): boolean {
    let test;
    return false;
}
</code></pre>
<p>When we run the code, we can see that the compiler is detecting that we have an unused parameter and that we have an unused local variable.</p>
<ul>
<li>
<p>The parameter named input of type string is defined in the function definition but is never actually used within the function body.</p>
</li>
<li>
<p>In a similar manner, the variable named test is defined within the function body, but it is never assigned a value and is also never used.</p>
</li>
</ul>
<p>Note that while this is a trivial example and we can clearly see that these local variables and parameters are never used in this code, it may not be so easily spotted in a larger code base or larger functions, so it is best left for the compiler to find these unused variables for us.</p>
<h3 id="the-noimplicitreturns-option"><a class="header" href="#the-noimplicitreturns-option">The noImplicitReturns option#</a></h3>
<p>If a function has declared that it will return a value, then the noImplicitReturns compiler option will ensure that it does.
Running the compiler, however, with the noImplicitReturns option set to true will now generate an error. We can see the compiler is detecting that the isLargeNumber function may not return a value if the false code path is taken.</p>
<p><code>&gt;tags:</code> [[Error_TS5055]] [[Error_noImplicitReturns]]</p>
<p>Consider the following code:</p>
<pre><code class="language-ts">function isLargeNumber(value: number): boolean {
    if (value &gt; 1_000_000)
        return true;
}

console.log(`isLargeNumber(1) : ${isLargeNumber(1)}`);
</code></pre>
<p><code>&gt; Solution:</code></p>
<pre><code class="language-ts">function isLargeNumber(value: number): boolean {
    if (value &gt; 1_000_000)
        return true;
    return false;
}
</code></pre>
<h3 id="nofallthroughcasesinswitch"><a class="header" href="#nofallthroughcasesinswitch">noFallthroughCasesInSwitch</a></h3>
<p>The TypeScript compiler option named noFallthroughCasesInSwitch is used to trap a particular logic error within switch statements.</p>
<p>Consider the following code:</p>
<pre><code class="language-ts">    switch (value) {
        case SwitchEnum.ONE:
            returnValue = &quot;One&quot;;
            break; //comment this line will expose an error
        case SwitchEnum.TWO:
            returnValue = &quot;Two&quot;;
    }
</code></pre>
<h3 id="noimplicitthis"><a class="header" href="#noimplicitthis">noImplicitThis</a></h3>
<p>The noImplicitThis compiler option is used to detect logic errors when the this variable is accessed incorrectly.</p>
<p><code>&gt;tags:</code> [[Error_TS5055]] [[Error_noImplicitThis]]</p>
<p>Consider the following code:</p>
<pre><code class="language-ts">class NoImplicitThisClass {
    id: number = 1;
    printAfterWait() {
        let callback = function () {
            console.log(`this.id : ${this.id}`);
        }
        setTimeout(callback, 1000);
    }
}

let classInstance = new NoImplicitThisClass();
classInstance.printAfterWait();
</code></pre>
<p>The compiler correctly identifies that our reference to this.id within the callback function is not referencing the this property of the NoImplicitThisClass class. The this property within the callback function, therefore, has a type of any, hence the error.</p>
<p>There are two ways that we could correct this code.</p>
<ul>
<li>Using a callback function</li>
</ul>
<pre><code class="language-ts">class NoImplicitThisClass {
    id: number = 1;
    printAfterWait() {
    let callback = function (_this) {
        console.log(`this.id : ${_this.id}`);
    }
    setTimeout(callback, 1000, this);
    }
</code></pre>
<ul>
<li>Using an arrow function</li>
</ul>
<pre><code class="language-ts">    let callback = () =&gt; {
        console.log(`this.id : ${this.id}`);
    }
    setTimeout(callback, 1000);
</code></pre>
<h4 id="module"><a class="header" href="#module">module</a></h4>
<p>The “module” property sets the module system supported for the compiled program. During runtime, a module loader is used to locate and execute dependencies based on the specified module system.</p>
<p>The most common module loaders used in JavaScript are Node.js CommonJS for server-side applications and RequireJS for AMD modules in browser-based web applications. TypeScript can emit code for various module systems, including UMD, System, ESNext, ES2015/ES6, and ES2020.</p>
<p>Note: The module system should be chosen based on the target environment and the module loading mechanism available in that environment.</p>
<h4 id="moduleresolution"><a class="header" href="#moduleresolution">moduleResolution</a></h4>
<p>The “moduleResolution” property specifies the module resolution strategy. Use “node” for modern TypeScript code, the “classic” strategy is used only for old versions of TypeScript (before 1.6).</p>
<h4 id="esmoduleinterop"><a class="header" href="#esmoduleinterop">esModuleInterop</a></h4>
<p>The “esModuleInterop” property allows import default from CommonJS modules that did not export using the “default” property, this property provides a shim to ensure compatibility in the emitted JavaScript. After enabling this option we can use <code>import MyLibrary from &quot;my-library&quot;</code> instead of <code>import - [x] as MyLibrary from &quot;my-library&quot;</code>.</p>
<h4 id="jsx"><a class="header" href="#jsx">jsx</a></h4>
<p>The “jsx” property applies only to .tsx files used in ReactJS and controls how JSX constructs are compiled into JavaScript. A common option is “preserve” which will compile to a .jsx file keeping unchanged the JSX so it can be passed to different tools like Babel for further transformations.</p>
<h4 id="skiplibcheck"><a class="header" href="#skiplibcheck">skipLibCheck</a></h4>
<p>The “skipLibCheck’’ property will prevent TypeScript from type-checking the entire imported third-party packages. This property will reduce the compile time of a project. TypeScript will still check your code against the type definitions provided by these packages.</p>
<h4 id="files"><a class="header" href="#files">files</a></h4>
<p>The “files” property indicates to the compiler a list of files that must always be included in the program.</p>
<h4 id="include"><a class="header" href="#include">include</a></h4>
<!-- markdownlint-disable MD049 -->
<p>The “include” property indicates to the compiler a list of files that we would like to include. This property allows glob-like patterns, such as “*<em>” for any subdirectory, “</em>” for any file name, and “?” for optional characters.</p>
<!-- markdownlint-enable MD049 -->
<h4 id="exclude"><a class="header" href="#exclude">exclude</a></h4>
<p>The “exclude” property indicates to the compiler a list of files that should not be included in the compilation. This can include files such as “node_modules” or test files.
Note: tsconfig.json allows comments.</p>
<h3 id="importhelpers"><a class="header" href="#importhelpers">importHelpers</a></h3>
<p>TypeScript uses helper code when generating code for certain advanced or down-leveled JavaScript features. By default, these helpers are duplicated in files using them. The <code>importHelpers</code> option imports these helpers from the <code>tslib</code> module instead, making the JavaScript output more efficient.</p>
<h3 id="migration-to-typescript-advice"><a class="header" href="#migration-to-typescript-advice">Migration to TypeScript Advice</a></h3>
<p>For large projects, it is recommended to adopt a gradual transition where TypeScript and JavaScript code will initially coexist. Only small projects can be migrated to TypeScript in one go.</p>
<p>The first step of this transition is to introduce TypeScript into the build chain process. This can be done by using the “allowJs” compiler option, which permits .ts and .tsx files to coexist with existing JavaScript files. As TypeScript will fall back to a type of “any” for a variable when it cannot infer the type from JavaScript files, it is recommended to disable “noImplicitAny” in your compiler options at the beginning of the migration.</p>
<p>The second step is to ensure that your JavaScript tests work alongside TypeScript files so that you can run tests as you convert each module. If you are using Jest, consider using <code>ts-jest</code>, which allows you to test TypeScript projects with Jest.</p>
<p>The third step is to include type declarations for third-party libraries in your project. These declarations can be found either bundled or on DefinitelyTyped. You can search for them using <a href="https://www.typescriptlang.org/dt/search">https://www.typescriptlang.org/dt/search</a> and install them using:</p>
<pre><code class="language-shell">npm install --save-dev @types/package-name or yarn add --dev @types/package-name.
</code></pre>
<p>The fourth step is to migrate module by module with a bottom-up approach, following your Dependency Graph starting with the leaves. The idea is to start converting Modules that do not depend on other Modules. To visualize the dependency graphs, you can use the “madge” tool.</p>
<p>Good candidate modules for these initial conversions are utility functions and code related to external APIs or specifications. It is possible to automatically generate TypeScript type definitions from Swagger contracts, GraphQL or JSON schemas to be included in your project.</p>
<p>When there are no specifications or official schemas available, you can generate types from raw data, such as JSON returned by a server. However, it is recommended to generate types from specifications instead of data to avoid missing edge cases.</p>
<p>During the migration, refrain from code refactoring and focus only on adding types to your modules.</p>
<p>The fifth step is to enable “noImplicitAny,” which will enforce that all types are known and defined, providing a better TypeScript experience for your project.</p>
<p>During the migration, you can use the <code>@ts-check</code> directive, which enables TypeScript type checking in a JavaScript file. This directive provides a loose version of type checking and can be initially used to identify issues in JavaScript files. When <code>@ts-check</code> is included in a file, TypeScript will try to deduce definitions using JSDoc-style comments. However, consider using JSDoc annotations only at a very early stage of the migration.</p>
<p>Consider keeping the default value of <code>noEmitOnError</code> in your tsconfig.json as false. This will allow you to output JavaScript source code even if errors are reported.</p>
<h2 id="exploring-the-type-system"><a class="header" href="#exploring-the-type-system">Exploring the Type System</a></h2>
<h3 id="the-typescript-language-service"><a class="header" href="#the-typescript-language-service">The TypeScript Language Service</a></h3>
<p>The TypeScript Language Service, also known as tsserver, offers various features such as error reporting, diagnostics, compile-on-save, renaming, go to definition, completion lists, signature help, and more. It is primarily used by integrated development environments (IDEs) to provide IntelliSense support. It seamlessly integrates with Visual Studio Code and is utilized by tools like Conquer of Completion (Coc).</p>
<p>Developers can leverage a dedicated API and create their own custom language service plugins to enhance the TypeScript editing experience. This can be particularly useful for implementing special linting features or enabling auto-completion for a custom templating language.</p>
<!-- markdownlint-disable MD044 -->
<p>An example of a real-world custom plugin is “typescript-styled-plugin”, which provides syntax error reporting and IntelliSense support for CSS properties in styled components.</p>
<!-- markdownlint-enable MD044 -->
<p>For more information and quick start guides, you can refer to the official TypeScript Wiki on GitHub: <a href="https://github.com/microsoft/TypeScript/wiki/">https://github.com/microsoft/TypeScript/wiki/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="which-files"><a class="header" href="#which-files">Which files?</a></h2>
<p>Use <code>include</code> and <code>exclude</code> to specify files / folders / globs. E.g.:</p>
<pre><code class="language-json">{
    &quot;include&quot;:[
        &quot;./folder&quot;
    ],
    &quot;exclude&quot;:[
        &quot;./folder/**/*.spec.ts&quot;,
        &quot;./folder/someSubFolder&quot;
    ]
}
</code></pre>
<h3 id="globs"><a class="header" href="#globs">Globs</a></h3>
<ul>
<li>For globs : <code>**/*</code> (e.g. sample usage <code>somefolder/**/*</code>) means all folder and any files (the extensions <code>.ts</code>/<code>.tsx</code> will be assumed and if <code>allowJs:true</code> so will <code>.js</code>/<code>.jsx</code>)</li>
</ul>
<h3 id="files-option"><a class="header" href="#files-option"><code>files</code> option</a></h3>
<p>Alternatively, you can use <code>files</code> to be explicit: </p>
<pre><code class="language-json">{
    &quot;files&quot;:[
        &quot;./some/file.ts&quot;
    ]
}
</code></pre>
<p>But it is not recommended as you have to keep updating it. Instead use <code>include</code> to just add the containing folder. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="declaration-spaces"><a class="header" href="#declaration-spaces">Declaration Spaces</a></h2>
<p>There are two declaration spaces in TypeScript: the <em>variable</em> declaration space and the <em>type</em> declaration space. These concepts are explored below.</p>
<h3 id="type-declaration-space"><a class="header" href="#type-declaration-space">Type Declaration Space</a></h3>
<p>The type declaration space contains stuff that can be used as a type annotation. E.g. the following are a few type declarations:</p>
<pre><code class="language-typescript">class Foo {};
interface Bar {};
type Bas = {};
</code></pre>
<p>This means that you can use <code>Foo</code>, <code>Bar</code>, <code>Bas</code>, etc. as a type annotation. E.g.:</p>
<pre><code class="language-typescript">var foo: Foo;
var bar: Bar;
var bas: Bas;
</code></pre>
<p>Notice that even though you have <code>interface Bar</code>, <em>you can’t use it as a variable</em> because it doesn’t contribute to the <em>variable declaration space</em>. This is shown below:</p>
<pre><code class="language-typescript">interface Bar {};
var bar = Bar; // ERROR: &quot;cannot find name 'Bar'&quot;
</code></pre>
<p>The reason why it says <code>cannot find name</code> is because the name <code>Bar</code> <em>is not defined</em> in the <em>variable</em> declaration space. That brings us to the next topic “Variable Declaration Space”.</p>
<h3 id="variable-declaration-space"><a class="header" href="#variable-declaration-space">Variable Declaration Space</a></h3>
<p>The variable declaration space contains stuff that you can use as a variable. We saw that having <code>class Foo</code> contributes a type <code>Foo</code> to the <em>type</em> declaration space. Guess what? It also contributes a <em>variable</em> <code>Foo</code> to the <em>variable</em> declaration space as shown below:</p>
<pre><code class="language-typescript">class Foo {};
var someVar = Foo;
var someOtherVar = 123;
</code></pre>
<p>This is great as sometimes you want to pass classes around as variables. Remember that:</p>
<ul>
<li>we couldn’t use something like an <code>interface</code> that is <em>only</em> in the <em>type</em> declaration space as a variable.</li>
</ul>
<p>Similarly something that you declare with <code>var</code>, is <em>only</em> in the <em>variable</em> declaration space and cannot be used as a type annotation:</p>
<pre><code class="language-typescript">var foo = 123;
var bar: foo; // ERROR: &quot;cannot find name 'foo'&quot;
</code></pre>
<p>The reason why it says <code>cannot find name</code> is because the name <code>foo</code> <em>is not defined</em> in the <em>type</em> declaration space.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<h3 id="global-module"><a class="header" href="#global-module">Global Module</a></h3>
<p>By default when you start typing code in a new TypeScript file your code is in a <em>global</em> namespace. As a demo consider a file <code>foo.ts</code>:</p>
<pre><code class="language-typescript">var foo = 123;
</code></pre>
<p>If you now create a <em>new</em> file <code>bar.ts</code> in the same project, you will be <em>allowed</em> by the TypeScript type system to use the variable <code>foo</code> as if it was available globally:</p>
<pre><code class="language-typescript">var bar = foo; // allowed
</code></pre>
<p>Needless to say having a global namespace is dangerous as it opens your code up for naming conflicts. We recommend using file modules which are presented next.</p>
<h3 id="file-module"><a class="header" href="#file-module">File Module</a></h3>
<p>Also called <em>external modules</em>. If you have an <code>import</code> or an <code>export</code> at the root level of a TypeScript file then it creates a <em>local</em> scope within that file. So if we were to change the previous <code>foo.ts</code> to the following (note the <code>export</code> usage):</p>
<pre><code class="language-typescript">export var foo = 123;
</code></pre>
<p>We will no longer have <code>foo</code> in the global namespace. This can be demonstrated by creating a new file <code>bar.ts</code> as follows:</p>
<pre><code class="language-typescript">var bar = foo; // ERROR: &quot;cannot find name 'foo'&quot;
</code></pre>
<p>If you want to use stuff from <code>foo.ts</code> in <code>bar.ts</code> <em>you need to explicitly import it</em>. This is shown in an updated <code>bar.ts</code> below:</p>
<pre><code class="language-typescript">import { foo } from &quot;./foo&quot;;
var bar = foo; // allowed
</code></pre>
<p>Using an <code>import</code> in <code>bar.ts</code> not only allows you to bring in stuff from other files, but also marks the file <code>bar.ts</code> as a <em>module</em> and therefore, declarations in <code>bar.ts</code> don’t pollute the global namespace either.</p>
<p>What JavaScript is generated from a given TypeScript file that uses external modules is driven by the compiler flag called <code>module</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="external-modules"><a class="header" href="#external-modules">External modules</a></h2>
<p>There is a lot of power and usability packed into the TypeScript external module pattern. Here we discuss its power and some patterns needed to reflect real world usages.</p>
<h2 id="triple-slash-directives"><a class="header" href="#triple-slash-directives">Triple-Slash Directives</a></h2>
<p>Triple-slash directives are special comments that provide instructions to the compiler about how to process a file. These directives begin with three consecutive slashes (<code>///</code>) and are typically placed at the top of a TypeScript file and have no effects on the runtime behavior.</p>
<p>Triple-slash directives are used to reference external dependencies, specify module loading behavior, enable/disable certain compiler features, and more. Few examples:</p>
<p><code>&gt;tags:</code> [[Comment]] #load_module</p>
<p>Referencing a declaration file:</p>
<!-- skip -->
<pre><code class="language-typescript">/// &lt;reference path=&quot;path/to/declaration/file.d.ts&quot; /&gt;
</code></pre>
<p>Indicate the module format:</p>
<!-- skip -->
<pre><code class="language-typescript">/// &lt;amd|commonjs|system|umd|es6|es2015|none&gt;
</code></pre>
<p>Enable compiler options, in the following example strict mode:</p>
<!-- skip -->
<pre><code class="language-typescript">/// &lt;strict|noImplicitAny|noUnusedLocals|noUnusedParameters&gt;
</code></pre>
<h3 id="clarification-commonjs-amd-es-modules-others"><a class="header" href="#clarification-commonjs-amd-es-modules-others">Clarification: commonjs, amd, es modules, others</a></h3>
<p>First up we need to clarify the (awful) inconsistency of the module systems out there. I’ll just give you my <em>current</em> recommendation and remove the noise i.e. not show you all the <em>other</em> ways things can work.</p>
<p>From the <em>same TypeScript</em> you can generate different <em>JavaScript</em> depending upon the <code>module</code> option. Here are things you can ignore (I am not interested in explaining dead tech):</p>
<ul>
<li>AMD: Do not use. Was browser only.</li>
<li>SystemJS: Was a good experiment. Superseded by ES modules.</li>
<li>ES Modules: Not ready yet.</li>
</ul>
<p>Now these are just the options for <em>generating the JavaScript</em>. Instead of these options use <code>module:commonjs</code></p>
<p>How you <em>write</em> TypeScript modules is also a bit of a mess. Again here is how not to do it <em>today</em>:</p>
<ul>
<li><code>import foo = require('foo')</code>. i.e. <code>import/require</code>. Use ES module syntax instead.</li>
</ul>
<p>Cool, with that out of the way, lets look at the ES module syntax.</p>
<blockquote>
<p>Summary: Use <code>module:commonjs</code> and use the ES module syntax to import / export / author modules.</p>
</blockquote>
<h3 id="es-module-syntax"><a class="header" href="#es-module-syntax">ES Module syntax</a></h3>
<ul>
<li>Exporting a variable (or type) is as easy as prefixing the keyword <code>export</code> e.g.</li>
</ul>
<pre><code class="language-js">// file `foo.ts`
export let someVar = 123;
export type SomeType = {
  foo: string;
};
</code></pre>
<ul>
<li>Exporting a variable or type in a dedicated <code>export</code> statement e.g.</li>
</ul>
<pre><code class="language-js">// file `foo.ts`
let someVar = 123;
type SomeType = {
  foo: string;
};
export {
  someVar,
  SomeType
};
</code></pre>
<ul>
<li>Exporting a variable or type in a dedicated <code>export</code> statement <em>with renaming</em> e.g.</li>
</ul>
<pre><code class="language-js">// file `foo.ts`
let someVar = 123;
export { someVar as aDifferentName };
</code></pre>
<ul>
<li>Import a variable or a type using <code>import</code> e.g.</li>
</ul>
<pre><code class="language-js">// file `bar.ts`
import { someVar, SomeType } from './foo';
</code></pre>
<ul>
<li>Import a variable or a type using <code>import</code> <em>with renaming</em> e.g.</li>
</ul>
<pre><code class="language-js">// file `bar.ts`
import { someVar as aDifferentName } from './foo';
</code></pre>
<ul>
<li>Import everything from a module into a name with <code>import * as</code> e.g.</li>
</ul>
<pre><code class="language-js">// file `bar.ts`
import * as foo from './foo';
// you can use `foo.someVar` and `foo.SomeType` and anything else that foo might export.
</code></pre>
<ul>
<li>Import a file <em>only</em> for its side effect with a single import statement:</li>
</ul>
<pre><code class="language-js">import 'core-js'; // a common polyfill library
</code></pre>
<ul>
<li>Re-Exporting all the items from another module</li>
</ul>
<pre><code class="language-js">export * from './foo';
</code></pre>
<ul>
<li>Re-Exporting only some items from another module</li>
</ul>
<pre><code class="language-js">export { someVar } from './foo';
</code></pre>
<ul>
<li>Re-Exporting only some items from another module <em>with renaming</em></li>
</ul>
<pre><code class="language-js">export { someVar as aDifferentName } from './foo';
</code></pre>
<h3 id="default-exportsimports"><a class="header" href="#default-exportsimports">Default exports/imports</a></h3>
<p>As you will learn later, I am not a fan of default exports. Nevertheless here is syntax for export and using default exports</p>
<ul>
<li>Export using <code>export default</code>
<ul>
<li>before a variable (no <code>let / const / var</code> needed)</li>
<li>before a function</li>
<li>before a class</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// some var
export default someVar = 123;
// OR Some function
export default function someFunction() { }
// OR Some class
export default class SomeClass { }
</code></pre>
<ul>
<li>Import using the <code>import someName from &quot;someModule&quot;</code> syntax (you can name the import whatever you want) e.g.</li>
</ul>
<pre><code class="language-js">import someLocalNameForThisFile from &quot;../foo&quot;;
</code></pre>
<h3 id="module-paths"><a class="header" href="#module-paths">Module paths</a></h3>
<blockquote>
<p>I am just going to assume <code>moduleResolution: &quot;Node&quot;</code>. This is the option you should have in your TypeScript config. This setting is implied automatically by <code>module:commonjs</code>.</p>
</blockquote>
<p>There are two distinct kinds of modules. The distinction is driven by the path section of the import statement (e.g. <code>import foo from 'THIS IS THE PATH SECTION'</code>).</p>
<ul>
<li>Relative path modules (where path starts with <code>.</code> e.g. <code>./someFile</code> or <code>../../someFolder/someFile</code> etc.)</li>
<li>Other dynamic lookup modules (e.g. <code>'core-js'</code> or <code>'typestyle'</code> or <code>'react'</code> or even <code>'react/core'</code> etc.)</li>
</ul>
<p>The main difference is <em>how the module is resolved on the file system</em>.</p>
<blockquote>
<p>I will use a conceptual term <em>place</em> that I will explain after mentioning the lookup pattern.</p>
</blockquote>
<h4 id="relative-path-modules"><a class="header" href="#relative-path-modules">Relative path modules</a></h4>
<p>Easy, just follow the relative path :) e.g.</p>
<ul>
<li>if file <code>bar.ts</code> does <code>import * as foo from './foo';</code> then place <code>foo</code> must exist in the same folder.</li>
<li>if file <code>bar.ts</code> does <code>import * as foo from '../foo';</code> then place <code>foo</code> must exist in a folder up.</li>
<li>if file <code>bar.ts</code> does <code>import * as foo from '../someFolder/foo';</code> then one folder up, there must be a folder <code>someFolder</code> with a place <code>foo</code></li>
</ul>
<p>Or any other relative path you can think of :)</p>
<h4 id="dynamic-lookup"><a class="header" href="#dynamic-lookup">Dynamic lookup</a></h4>
<p>When the import path is <em>not</em> relative, lookup is driven by <a href="https://nodejs.org/api/modules.html#modules_all_together"><em>node style resolution</em></a>. Here I only give a simple example:</p>
<ul>
<li>
<p>You have <code>import * as foo from 'foo'</code>, the following are the places that are checked <em>in order</em></p>
<ul>
<li><code>./node_modules/foo</code></li>
<li><code>../node_modules/foo</code></li>
<li><code>../../node_modules/foo</code></li>
<li>Till root of file system</li>
</ul>
</li>
<li>
<p>You have <code>import * as foo from 'something/foo'</code>, the following are the places that are checked <em>in order</em></p>
<ul>
<li><code>./node_modules/something/foo</code></li>
<li><code>../node_modules/something/foo</code></li>
<li><code>../../node_modules/something/foo</code></li>
<li>Till root of file system</li>
</ul>
</li>
</ul>
<h3 id="what-is-place"><a class="header" href="#what-is-place">What is <em>place</em></a></h3>
<p>When I say <em>places that are checked</em> I mean that the following things are checked in that place. e.g. for a place <code>foo</code>:</p>
<ul>
<li>If the place is a file, e.g. <code>foo.ts</code>, hurray!</li>
<li>else if the place is a folder and there is a file <code>foo/index.ts</code>, hurray!</li>
<li>else if the place is a folder and there is a <code>foo/package.json</code> and a file specified in the <code>types</code> key in the package.json that exists, then hurray!</li>
<li>else if the place is a folder and there is a <code>package.json</code> and a file specified in the <code>main</code> key in the package.json that exists, then hurray!</li>
</ul>
<p>By file I actually mean <code>.ts</code> / <code>.d.ts</code> and <code>.js</code>.</p>
<p>And that’s it. You are now module lookup experts (not a small feat!).</p>
<h3 id="overturning-dynamic-lookup-just-for-types"><a class="header" href="#overturning-dynamic-lookup-just-for-types">Overturning dynamic lookup <em>just for types</em></a></h3>
<p>You can declare a module <em>globally</em> for your project by using <code>declare module 'somePath'</code> and then imports will resolve <em>magically</em> to that path</p>
<p>e.g.</p>
<pre><code class="language-typescript">// global.d.ts
declare module 'foo' {
  // Some variable declarations
  export var bar: number; /*sample*/
}
</code></pre>
<p>and then:</p>
<pre><code class="language-typescript">// anyOtherTsFileInYourProject.ts
import * as foo from 'foo';
// TypeScript assumes (without doing any lookup) that
// foo is {bar:number}

</code></pre>
<h3 id="importrequire-for-importing-type-only"><a class="header" href="#importrequire-for-importing-type-only"><code>import/require</code> for importing type only</a></h3>
<p>The following statement:</p>
<pre><code class="language-typescript">import foo = require('foo');
</code></pre>
<p>actually does <em>two</em> things:</p>
<ul>
<li>Imports the type information of the foo module.</li>
<li>Specifies a runtime dependency on the foo module.</li>
</ul>
<p>You can pick and choose so that only <em>the type information</em> is loaded and no runtime dependency occurs. Before continuing you might want to recap the <a href="project/../project/declarationspaces.html"><em>declaration spaces</em></a> section of the book.</p>
<p>If you do not use the imported name in the variable declaration space then the import is completely removed from the generated JavaScript. This is best explained with examples. Once you understand this we will present you with use cases.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example 1</a></h4>
<pre><code class="language-typescript">import foo = require('foo');
</code></pre>
<p>will generate the JavaScript:</p>
<pre><code class="language-js">
</code></pre>
<p>That’s right. An <em>empty</em> file as foo is not used.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example 2</a></h4>
<pre><code class="language-typescript">import foo = require('foo');
var bar: foo;
</code></pre>
<p>will generate the JavaScript:</p>
<pre><code class="language-js">var bar;
</code></pre>
<p>This is because <code>foo</code> (or any of its properties e.g. <code>foo.bas</code>) is never used as a variable.</p>
<h4 id="example-3"><a class="header" href="#example-3">Example 3</a></h4>
<pre><code class="language-typescript">import foo = require('foo');
var bar = foo;
</code></pre>
<p>will generate the JavaScript (assuming commonjs):</p>
<pre><code class="language-js">var foo = require('foo');
var bar = foo;
</code></pre>
<p>This is because <code>foo</code> is used as a variable.</p>
<h3 id="use-case-lazy-loading"><a class="header" href="#use-case-lazy-loading">Use case: Lazy loading</a></h3>
<p>Type inference needs to be done <em>upfront</em>. This means that if you want to use some type from a file <code>foo</code> in a file <code>bar</code> you will have to do:</p>
<pre><code class="language-typescript">import foo = require('foo');
var bar: foo.SomeType;
</code></pre>
<p>However, you might want to only load the file <code>foo</code> at runtime under certain conditions. For such cases you should use the <code>import</code>ed name only in <em>type annotations</em> and <strong>not</strong> as a <em>variable</em>. This removes any <em>upfront</em> runtime dependency code being injected by TypeScript. Then <em>manually import</em> the actual module using code that is specific to your module loader.</p>
<p>As an example, consider the following <code>commonjs</code> based code where we only load a module <code>'foo'</code> on a certain function call:</p>
<pre><code class="language-typescript">import foo = require('foo');

export function loadFoo() {
    // This is lazy loading `foo` and using the original module *only* as a type annotation
    var _foo: typeof foo = require('foo');
    // Now use `_foo` as a variable instead of `foo`.
}
</code></pre>
<p>A similar sample in <code>amd</code> (using requirejs) would be:</p>
<pre><code class="language-typescript">import foo = require('foo');

export function loadFoo() {
    // This is lazy loading `foo` and using the original module *only* as a type annotation
    require(['foo'], (_foo: typeof foo) =&gt; {
        // Now use `_foo` as a variable instead of `foo`.
    });
}
</code></pre>
<p>This pattern is commonly used:</p>
<ul>
<li>in web apps where you load certain JavaScript on particular routes,</li>
<li>in node applications where you only load certain modules if needed to speed up application bootup.</li>
</ul>
<h3 id="use-case-breaking-circular-dependencies"><a class="header" href="#use-case-breaking-circular-dependencies">Use case: Breaking Circular dependencies</a></h3>
<p>Similar to the lazy loading use case certain module loaders (commonjs/node and amd/requirejs) don’t work well with circular dependencies. In such cases it is useful to have <em>lazy loading</em> code in one direction and loading the modules upfront in the other direction.</p>
<h3 id="use-case-ensure-import"><a class="header" href="#use-case-ensure-import">Use case: Ensure Import</a></h3>
<p>Sometimes you want to load a file just for the side effect (e.g. the module might register itself with some library like <a href="https://codemirror.net/doc/manual.html#addons">CodeMirror addons</a> etc.). However, if you just do a <code>import/require</code> the transpiled JavaScript will not contain a dependency on the module and your module loader (e.g. webpack) might completely ignore the import. In such cases you can use a <code>ensureImport</code> variable to ensure that the compiled JavaScript takes a dependency on the module e.g.:</p>
<pre><code class="language-typescript">import foo = require('./foo');
import bar = require('./bar');
import bas = require('./bas');
const ensureImport: any =
    foo
    &amp;&amp; bar
    &amp;&amp; bas;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="globaldts"><a class="header" href="#globaldts">global.d.ts</a></h1>
<p>Note that over time, some JavaScript libraries have begun to include declaration files within their main package, and therefore, we do not even need to install an @types package in order to use it.</p>
<p><code>declare module 'underscore';</code></p>
<p>Here, we declare that there is a module named ‘underscore’ that we wish to use, but we don’t provide a declaration file for it. This solution is really the last resort and should be avoided when possible.</p>
<p>The reason for this is that we will not have any types declared <em>for this library</em>, and it will just be of <strong>type any</strong>.</p>
<blockquote>
<p><code>Sample project</code> Ref.To project of typescript-all-in-one-projects-&gt; ts-declare-global, ReadME</p>
</blockquote>
<p>We discussed <em>global</em> vs. <em>file</em> modules when covering <a href="project/./modules.html">projects</a> and recommended using file based modules and not polluting the global namespace.</p>
<p>Nevertheless, if you have beginner TypeScript developers you can give them a <code>global.d.ts</code> file to put interfaces / types in the global namespace to make it easy to have some <em>types</em> just <em>magically</em> available for consumption in <em>all</em> your TypeScript code.</p>
<p>Another use case for a <code>global.d.ts</code> file is to declare compile-time constants that are being injected into the source code by Webpack via the standard <a href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a> plugin.</p>
<pre><code class="language-typescript">declare const BUILD_MODE_PRODUCTION: boolean; // can be used for conditional compiling
declare const BUILD_VERSION: string;
</code></pre>
<blockquote>
<p>For any code that is going to generate <em>JavaScript</em> we highly recommend using <em>file modules</em>, and only use <code>global.d.ts</code> to declare compile-time constants and/or to extend standard type declarations declared in <code>lib.d.ts</code>.</p>
</blockquote>
<ul>
<li>Bonus: The <code>global.d.ts</code> file is also good for quick <code>declare module &quot;some-library-you-dont-care-to-get-defs-for&quot;;</code> when doing JS to TS migrations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-a-namespace"><a class="header" href="#creating-a-namespace">Creating a namespace</a></h2>
<p>Let’s take a look at the first version of a declaration file for our ErrorHelper JavaScript class in the file named globals.d.ts:</p>
<pre><code class="language-typescript">declare module ErrorHelper {
 function containsErrors(response: any): boolean; // checks if response contains any errors
 function trace(message: any): void; // logs a message for debugging purposes
}

</code></pre>
<p>This module declaration is acting as a namespace, meaning that we need to reference each of these functions by their fully qualified names, that is, <strong>ErrorHelper.containsErrors, and ErrorHelper.trace.</strong></p>
<h3 id="defining-interfaces"><a class="header" href="#defining-interfaces">Defining interfaces</a></h3>
<p>Note that even though we have declared the two functions that are available on the ErrorHelper class, we are still missing some crucial information about them.</p>
<pre><code class="language-typescript">// This code defines TypeScript interfaces and a module for error handling

interface IResponse {
 responseText: IFailureMessage;
}
interface IFailureMessage {
 failure: boolean | string;
 errorMessage?: string;
}
declare module ErrorHelper {
  function containsErrors(response: IResponse): boolean; // checks if response contains any errors
  function trace(message: IResponse | string): void; // logs a message for debugging purposes
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="namespacing"><a class="header" href="#namespacing">Namespacing</a></h2>
<p>In TypeScript, namespaces are used to organize code into logical containers, preventing naming collisions and providing a way to group related code together.
The usage of the <code>export</code> keywords allows access to the namespace in “outside” modules.</p>
<pre><code class="language-typescript">export namespace MyNamespace {
    export interface MyInterface1 {
        prop1: boolean;
    }
    export interface MyInterface2 {
        prop2: string;
    }
}

const a: MyNamespace.MyInterface1 = {
    prop1: true,
};
</code></pre>
<p>Namespaces provide you with a convenient syntax around a common pattern used in JavaScript:</p>
<p>Basically <code>something || (something = {})</code> allows an anonymous function <code>function(something) {}</code> to <em>add stuff to an existing object</em> (the <code>something ||</code> portion) or <em>start a new object then add stuff to that object</em> (the <code>|| (something = {})</code> portion). This means that you can have two such blocks split by some execution boundary:</p>
<pre><code class="language-typescript">(function(something) {

    something.foo = 123;

})(something || (something = {}))

console.log(something); // {foo:123}

(function(something) {

    something.bar = 456;

})(something || (something = {}))

console.log(something); // {foo:123, bar:456}

</code></pre>
<p>This is commonly used in  the JavaScript land for making sure that stuff doesn’t leak into the global namespace. With file based modules you don’t need to worry about this, but the pattern is still useful for <em>logical grouping</em> of a bunch of functions. Therefore TypeScript provides the <code>namespace</code> keyword to group these e.g.:</p>
<pre><code class="language-typescript">namespace Utility {
    export function log(msg) {
        console.log(msg);
    }
    export function error(msg) {
        console.error(msg);
    }
}

// usage
Utility.log('Call me');
Utility.error('maybe!');
</code></pre>
<p>The <code>namespace</code> keyword generates the same JavaScript that we saw earlier:</p>
<pre><code class="language-typescript">(function (Utility) {

// Add stuff to Utility

})(Utility || (Utility = {}));
</code></pre>
<p>One thing to note is that namespaces can be nested so you can do stuff like <code>namespace Utility.Messaging</code> to nest a <code>Messaging</code> namespace under <code>Utility</code>.</p>
<p>For most projects we recommend using external modules and using <code>namespace</code> for quick demos and porting old JavaScript code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dynamic-import-expressions"><a class="header" href="#dynamic-import-expressions">Dynamic import expressions</a></h2>
<p>It is possible to conditionally load modules or <strong>lazy load them on-demand</strong> using the ECMAScript proposal for dynamic import which is supported in TypeScript.</p>
<p>The syntax for dynamic import expressions in TypeScript is as follows:</p>
<!-- skip -->
<pre><code class="language-typescript">async function renderWidget() {
    const container = document.getElementById('widget');
    if (container !== null) {
        const widget = await import('./widget'); // Dynamic import
        widget.render(container);
    }
}

renderWidget();
</code></pre>
<p><strong>Dynamic import expressions</strong> are a new feature and part of <strong>ECMAScript</strong> that allows users to asynchronously request a module at any arbitrary point in your program.
<strong>TC39</strong> JavaScript committee has it’s own proposal which is in stage 3, and it’s called <a href="https://github.com/tc39/proposal-dynamic-import">import() proposal for JavaScript</a>.</p>
<p>Alternatively, <strong>webpack</strong> bundler has a feature called <a href="https://webpack.js.org/guides/code-splitting/"><strong>Code Splitting</strong></a> which allows you to split your bundle into chunks which can be downloaded asynchronously at a later time. For instance, this allows to serve a minimal bootstrap bundle first and to asynchronously load additional features later.</p>
<p>It’s natural to think (if we are using webpack in our dev workflow) that <a href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#dynamic-import-expressions">TypeScript 2.4 dynamic import expressions</a> will <strong>automatically produce</strong> bundle chunks and automatically code-split your JS final bundle. BUT, that is not as easy as it seems, because it depends on the <strong>tsconfig.json configuration</strong> we are working with.</p>
<p>The thing is that webpack code splitting supports two similar techniques to achieve this goal: using <strong>import()</strong> (preferred, ECMAScript proposal) and <strong>require.ensure()</strong> (legacy, webpack specific). And what that means is the expected TypeScript output is <strong>leave the import() statement as it is</strong> instead of transpile it to anything else.</p>
<p>Let’s see an example to figure out how to configure webpack + TypeScript 2.4.</p>
<p>In the following code I want to <strong>lazy load the library <em>moment</em></strong> but I am interested in code splitting as well, which means, having the moment library in a separate chunk of JS (JavaScript file) that will be loaded only when required.</p>
<pre><code class="language-typescript">import(/* webpackChunkName: &quot;momentjs&quot; */ &quot;moment&quot;)
  .then((moment) =&gt; {
      // lazyModule has all of the proper types, autocomplete works,
      // type checking works, code references work \o/
      const time = moment().format();
      console.log(&quot;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&quot;);
      console.log(time);
  })
  .catch((err) =&gt; {
      console.log(&quot;Failed to load moment&quot;, err);
  });
</code></pre>
<p>Here is the tsconfig.json:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;es5&quot;,                          
        &quot;module&quot;: &quot;esnext&quot;,                     
        &quot;lib&quot;: [
            &quot;dom&quot;,
            &quot;es5&quot;,
            &quot;scripthost&quot;,
            &quot;es2015.promise&quot;
        ],                                        
        &quot;jsx&quot;: &quot;react&quot;,                           
        &quot;declaration&quot;: false,                     
        &quot;sourceMap&quot;: true,                        
        &quot;outDir&quot;: &quot;./dist/js&quot;,                    
        &quot;strict&quot;: true,                           
        &quot;moduleResolution&quot;: &quot;node&quot;,               
        &quot;typeRoots&quot;: [
            &quot;./node_modules/@types&quot;
        ],                                        
        &quot;types&quot;: [
            &quot;node&quot;,
            &quot;react&quot;,
            &quot;react-dom&quot;
        ]                                       
    }
}
</code></pre>
<p><strong>Important notes</strong>:</p>
<ul>
<li>Using <strong>“module”: “esnext”</strong> TypeScript produces the mimic import() statement to be input for Webpack Code Splitting.</li>
<li>For further information read this article: <a href="https://blog.josequinto.com/2017/06/29/dynamic-import-expressions-and-webpack-code-splitting-integration-with-typescript-2-4/">Dynamic Import Expressions and webpack 2 Code Splitting integration with TypeScript 2.4</a>.</li>
</ul>
<p>You can see full example <a href="https://cdn.rawgit.com/armanriazi/typescript-all-in-one/705e4496/code/dynamic-import-expressions/dynamicImportExpression.js">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-as-sets"><a class="header" href="#types-as-sets">Types as Sets</a></h1>
<p>In TypeScript, a type is a set of possible values. This set is also referred to as the domain of the type. Each value of a type can be viewed as an element in a set. A type establishes the constraints that every element in the set must satisfy to be considered a member of that set.
The primary task of TypeScript is to check and verify whether one set is a subset of another.</p>
<p>TypeScript supports various types of sets:</p>
<table><thead><tr><th>Set term</th><th>TypeScript</th><th>Notes</th></tr></thead><tbody>
<tr><td>Empty set</td><td>never</td><td>“never” contains anything apart itself</td></tr>
<tr><td>Single element set</td><td>undefined / null / literal type</td><td></td></tr>
<tr><td>Finite set</td><td>boolean / union</td><td></td></tr>
<tr><td>Infinite set</td><td>string / number / object</td><td></td></tr>
<tr><td>Universal set</td><td>any / unknown</td><td>Every element is a member of “any” and every set is a subset of it / “unknown” is a type-safe counterpart of “any”</td></tr>
</tbody></table>
<p>Here few examples:</p>
<table><thead><tr><th>TypeScript</th><th>Set term</th><th>Example</th></tr></thead><tbody>
<tr><td>never</td><td>∅ (empty set)</td><td>const x: never = ‘x’; // Error: Type ‘string’ is not assignable to type ‘never’</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Literal type</td><td>Single element set</td><td>type X = ‘X’;</td></tr>
<tr><td></td><td></td><td>type Y = 7;</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>Value assignable to T</td><td>Value ∈ T (member of)</td><td>type XY = ‘X’ | ‘Y’;</td></tr>
<tr><td></td><td></td><td>const x: XY = ‘X’;</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>T1 assignable to T2</td><td>T1 ⊆ T2 (subset of)</td><td>type XY = ‘X’ | ‘Y’;</td></tr>
<tr><td></td><td></td><td>const x: XY = ‘X’;</td></tr>
<tr><td></td><td></td><td>const j: XY = ‘J’; // Type ‘“J”’ is not assignable to type ‘XY’.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>T1 extends T2</td><td>T1 ⊆ T2 (subset of)</td><td>type X = ‘X’ extends string ? true : false;</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>T1 | T2</td><td>T1 ∪ T2 (union)</td><td>type XY = ‘X’ | ‘Y’;</td></tr>
<tr><td></td><td></td><td>type JK = 1 | 2;</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>T1 &amp; T2</td><td>T1 ∩ T2 (intersection)</td><td>type X = { a: string }</td></tr>
<tr><td></td><td></td><td>type Y = { b: string }</td></tr>
<tr><td></td><td></td><td>type XY = X &amp; Y</td></tr>
<tr><td></td><td></td><td>const x: XY = { a: ‘a’, b: ‘b’ }</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>unknown</td><td>Universal set</td><td>const x: unknown = 1</td></tr>
</tbody></table>
<h1 id="sfiat"><a class="header" href="#sfiat">S.F.I.A.T</a></h1>
<p>Interfaces are a way of defining custom types. Using interfaces allows us to cover almost every possible combination of types, meaning that <strong>using the any type, in most cases, is unnecessary</strong>. We use an acronym within our programming teams, which is Simply Find an Interface for the Any Type, pronounced sveat or sweat.  While this may sound rather odd, it simply brings home the point that the any type can and should be defined <strong>as an interface</strong>, so simply find it.
In short, avoid the any type at any cost.</p>
<h1 id="inferred-typing"><a class="header" href="#inferred-typing">Inferred typing</a></h1>
<p><strong>Type inference</strong> is the automatic deduction of the data types of specific expressions in a programming language, usually done at compile time.
As a bonus, statically typed languages can offer better performance, especially for long-running applications.
Is a feature of TypeScript that allows the type of a variable or expression to be <strong>determined based on the context</strong> The process of determining the type of a variable <strong>based on its value</strong>. in which it appears rather than being explicitly specified with a type annotation.
<code>as</code> keyword in a type assertion
It provides a way to override the inferred type of a variable.</p>
<h1 id="duck-typing"><a class="header" href="#duck-typing">Duck typing</a></h1>
<p>Checks the compatibility of an object with a particular type based on <em>the presence of certain properties or methods rather than the object’s actual type.</em>
In TypeScript, objects are considered compatible based on their shape rather than the order of their properties. <strong>In other words, two variables are considered to have the same type if they have the same properties and methods.</strong> In TypeScript, objects are considered compatible based on their <strong>shape rather than the order of their properties.</strong></p>
<p>Sample of non-duck:</p>
<pre><code class="language-typescript">//*Missing property example*
// Declare a variable 'nameIdObject' and initialize it with an object that has a 'name' property, an 'id' property, and a 'print' method
var nameIdObject = { name: &quot;myName&quot;, id: 1, print() {} };
// Assign a new object to 'nameIdObject'. This object has a 'name' property and an 'id' property, but it does not have the 'print' method
// that the original object had.
nameIdObject = { id: 3, name: &quot;thirdName&quot; };
//*Dynamic object typing*
// Declare a variable 'obj1' and initialize it with an object that has an 'id' property and a 'print' method
var obj1 = { id: 1, print() { } };

// Declare a variable 'obj2' and initialize it with an object that has an 'id' property, a 'print' method, and a 'select' method
var obj2 = { id: 2, print() { }, select() { } }

// Attempt to assign 'obj2' to 'obj1'. This won't cause a type error because 'obj2' has all of the methods that are present in the type of 'obj1'
obj1 = obj2;

// Attempt to assign 'obj1' to 'obj2'. This will cause a type error because 'obj1' is missing the 'select' method that is present in the type of 'obj2'
obj2 = obj1;
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">index.ts(5,1): error TS2741: Property 'print' is missing in type '{ id: number; name: string; }' but required in type '{ name: string; id: number; print(): void; }'.
</code></pre>
<h1 id="explicit-casting"><a class="header" href="#explicit-casting">Explicit casting</a></h1>
<p>uses the angled bracket syntax, that is, <strong>&lt; type &gt;</strong>, surrounding the name of the type.  <code>&lt;any&gt;{ id: 1, name: &quot;item1&quot; }</code></p>
<h1 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h1>
<pre><code class="language-typescript">// Define a type alias for a string or number
type StringOrNumber = string | number;

// Declare a function that takes two arguments, both of type 'StringOrNumber'
function addWithTypeAlias(
  arg1: StringOrNumber,
  arg2: StringOrNumber
) {
  // Convert both arguments to strings and return the concatenation
  return arg1.toString() + arg2.toString();
}

console.log(addWithTypeAlias(1, 2)); // Output: '12'
console.log(addWithTypeAlias('Hello', ' World')); // Output: 'Hello World'

</code></pre>
<h1 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h1>
<p>TypeScript also allows us to use what are known as literals, which are almost a <strong>hybrid of enums and type aliases</strong>. A literal will limit the allowed values to a set of values specified. A literal can be made of string, number, or boolean values.</p>
<pre><code class="language-typescript">// Define a literal `AllowedStringValues` that can be either &quot;one&quot;, &quot;two&quot;, or &quot;three&quot;.
type AllowedStringValues = &quot;one&quot; | &quot;two&quot; | &quot;three&quot;;

// Define a literal `AllowedNumericValues` that can be either 1, 20, or 65535.
type AllowedNumericValues = 1 | 20 | 65535;

// The `withLiteral` function takes a parameter `input` of the union type `AllowedStringValues | AllowedNumericValues`.
function withLiteral(input: AllowedStringValues | AllowedNumericValues) {
  // Logs the string representation of `input` to the console.
  console.log(`called with : ${input}`);
}

</code></pre>
<h2 id="literal-types-vs-aliases"><a class="header" href="#literal-types-vs-aliases">Literal Types vs Aliases</a></h2>
<p>The syntax used for literals is very similar to the syntax of a type alias where we use the type keyword followed by a set of allowed values. Unlike type aliases, however, we are not specifying a set of different types. We are specifying a set of allowed values, which is similar in concept to an enum.</p>
<h1 id="comparison-rules"><a class="header" href="#comparison-rules">Comparison Rules</a></h1>
<p>The TypeScript comparison process is recursive and executed on types nested at any level.</p>
<p>A type “X” is compatible with “Y” if “Y” has at least the same members as “X”.</p>
<pre><code class="language-typescript">type X = {
    a: string;
};
type Y = {
    a: string;
    b: string;
};
const y = { a: 'A', b: 'B' }; // Valid, as it has at least the same members as X
const r: X = y;
</code></pre>
<h3 id="types-can-be-implicit"><a class="header" href="#types-can-be-implicit">Types can be Implicit</a></h3>
<p>TypeScript will try to infer as much of the type information as it can in order to give you type safety with minimal cost of productivity during code development. For example, in the following example TypeScript will know that foo is of type <code>number</code> below and will give an error on the second line as shown:</p>
<pre><code class="language-typescript">var foo = 123;
foo = '456'; // Error: cannot assign `string` to `number`

// Is foo a number or a string?
</code></pre>
<p>This type inference is well motivated. If you do stuff like shown in this example, then, in the rest of your code, you cannot be certain that <code>foo</code> is a <code>number</code> or a <code>string</code>. Such issues turn up often in large multi-file code bases. We will deep dive into the type inference rules later.</p>
<h3 id="types-can-be-explicit"><a class="header" href="#types-can-be-explicit">Types can be Explicit</a></h3>
<p>As we’ve mentioned before, TypeScript will infer as much as it can safely. However, you can use annotations to:</p>
<ol>
<li>Help along the compiler, and more importantly document stuff for the next developer who has to read your code (that might be future you!).</li>
<li>Enforce that what the compiler sees, is what you thought it should see. That is your understanding of the code matches an algorithmic analysis of the code (done by the compiler).</li>
</ol>
<p>TypeScript uses postfix type annotations popular in other <em>optionally</em> annotated languages (e.g. ActionScript and F#).</p>
<pre><code class="language-typescript">var foo: number = 123;
</code></pre>
<p>So if you do something wrong the compiler will report an error e.g.:</p>
<pre><code class="language-typescript">var foo: number = '123'; // Error: cannot assign a `string` to a `number`
</code></pre>
<p>We will discuss all the details of all the annotation syntax supported by TypeScript in a later chapter.</p>
<h3 id="assign-a-type"><a class="header" href="#assign-a-type">Assign a type</a></h3>
<p>Type Declarations and Type Assertions.In the following example, we use x: X (“: Type”) to declare a type for the variable x.</p>
<pre><code class="language-typescript">type X = {
    a: string;
};

const x: X = {
    a: 'a',
    b: 'b', // Error: Object literal may only specify known properties
};
</code></pre>
<h2 id="type-vs-interface"><a class="header" href="#type-vs-interface">Type vs Interface</a></h2>
<ul>
<li>Use <code>type</code> when you <em>might</em> need a union or intersection:</li>
</ul>
<pre><code class="language-typescript">type Foo = number | { someProperty: number }
</code></pre>
<ul>
<li>Use <code>interface</code> when you want <code>extends</code> or <code>implements</code> e.g.</li>
</ul>
<pre><code class="language-typescript">interface Foo {
  foo: string;
}
interface FooBar extends Foo {
  bar: string;
}
class X implements FooBar {
  foo: string;
  bar: string;
}
</code></pre>
<ul>
<li>Otherwise use whatever makes you happy that day. I use <a href="https://www.youtube.com/watch?v=IXAT3If0pGI">type</a></li>
</ul>
<h2 id="extending-types"><a class="header" href="#extending-types">Extending Types</a></h2>
<p>It is also possible to extend from multiple types:</p>
<pre><code class="language-typescript">interface A {
    a: string;
}
interface B {
    b: string;
}
interface Y extends A, B {
    y: string;
}
</code></pre>
<p>The <code>extends</code> keyword works only on interfaces and classes, for types use an intersection:</p>
<pre><code class="language-typescript">type A = {
    a: number;
};
type B = {
    b: number;
};
type C = A &amp; B;
</code></pre>
<p>It is possible to extend a type using an inference but not vice versa:</p>
<pre><code class="language-typescript">type A = {
    a: string;
};
interface B extends A {
    b: string;
}
</code></pre>
<h3 id="types-are-structural"><a class="header" href="#types-are-structural">Types are structural</a></h3>
<p>In some languages (specifically nominally typed ones) static typing results in unnecessary ceremony because even though <em>you know</em> that the code will work fine the language semantics force you to copy stuff around. This is why stuff like <strong>automapper</strong> for c# is <em>vital</em> for C#. In TypeScript because we really want it to be easy for JavaScript developers with a minimum cognitive overload, types are <em>structural</em>. This means that <strong>duck typing</strong> is a first class language construct. Consider the following example. The function <code>iTakePoint2D</code> will accept anything that contains all the things (<code>x</code> and <code>y</code>) it expects:</p>
<pre><code class="language-typescript">interface Point2D {
    x: number;
    y: number;
}
interface Point3D {
    x: number;
    y: number;
    z: number;
}
var point2D: Point2D = { x: 0, y: 10 }
var point3D: Point3D = { x: 0, y: 10, z: 20 }
function iTakePoint2D(point: Point2D) { /* do something */ }

iTakePoint2D(point2D); // exact match okay
iTakePoint2D(point3D); // extra information okay
iTakePoint2D({ x: 0 }); // Error: missing information `y`
</code></pre>
<p>TypeScript is based on a structural type system but excess property checking is a property of TypeScript which allows it to check whether an object has the exact properties specified in the type.</p>
<p>Excess Property Checking is performed when assigning object literals to variables or when passing them as arguments to the function’s excess property, for instance.</p>
<!-- skip -->
<pre><code class="language-typescript">type X = {
    a: string;
};
const y = { a: 'a', b: 'b' };
const x: X = y; // Valid because structural typing
const w: X = { a: 'a', b: 'b' }; // Invalid because excess property checking
</code></pre>
<h3 id="type-errors-do-not-prevent-javascript-emit"><a class="header" href="#type-errors-do-not-prevent-javascript-emit">Type errors do not prevent JavaScript emit</a></h3>
<p>To make it easy for you to migrate your JavaScript code to TypeScript, even if there are compilation errors, by default TypeScript <em>will emit valid JavaScript</em> the best that it can. e.g.</p>
<pre><code class="language-typescript">var foo = 123;
foo = '456'; // Error: cannot assign a `string` to a `number`
</code></pre>
<p>will emit the following js:</p>
<pre><code class="language-typescript">var foo = 123;
foo = '456';
</code></pre>
<p>So you can incrementally upgrade your JavaScript code to TypeScript. This is very different from how many other language compilers work and yet another reason to move to TypeScript.</p>
<h3 id="weak-types"><a class="header" href="#weak-types">Weak Types</a></h3>
<p>A type is considered weak when it contains nothing but a set of all-optional properties:</p>
<pre><code class="language-typescript">type X = {
    a?: string;
    b?: string;
};
</code></pre>
<p>TypeScript considers an error to assign anything to a weak type when there is no overlap, for instance, the following throws an error:</p>
<!-- skip -->
<pre><code class="language-typescript">type Options = {
    a?: string;
    b?: string;
};

const fn = (options: Options) =&gt; undefined;

fn({ c: 'c' }); // Invalid
</code></pre>
<p>Although not recommended, if needed, it is possible to bypass this check by using type assertion:</p>
<pre><code class="language-typescript">type Options = {
    a?: string;
    b?: string;
};
const fn = (options: Options) =&gt; undefined;
fn({ c: 'c' } as Options); // Valid
</code></pre>
<p>Or by adding <code>unknown</code> to the <a href="types/../types/system/index-signatures.html">index signatures</a> to the weak type:</p>
<pre><code class="language-typescript">type Options = {
    [prop: string]: unknown;
    a?: string;
    b?: string;
};
const fn = (options: Options) =&gt; undefined;
fn({ c: 'c' }); // Valid
</code></pre>
<h4 id="strong-type-vs-weak-type"><a class="header" href="#strong-type-vs-weak-type">Strong Type VS Weak Type</a></h4>
<p>Strong typing enforces strict type checking, while weak typing allows for more flexibility in type conversions.</p>
<h3 id="explicit-type-annotation"><a class="header" href="#explicit-type-annotation">Explicit Type Annotation</a></h3>
<p>We can be specific and pass a type, in the following example property <code>x</code> is of type <code>number</code>:</p>
<pre><code class="language-typescript">const v = {
    x: 1, // Inferred type: number (widening)
};
v.x = 3; // Valid
</code></pre>
<p>We can make the type annotation more specific by using a union of literal types:</p>
<!-- skip -->
<pre><code class="language-typescript">const v: { x: 1 | 2 | 3 } = {
    x: 1, // x is now a union of literal types: 1 | 2 | 3
};
v.x = 3; // Valid
v.x = 100; // Invalid
</code></pre>
<h3 id="type-narrowing"><a class="header" href="#type-narrowing">Type Narrowing</a></h3>
<p>Type Narrowing is the process in TypeScript where a general type is narrowed down to a more specific type. This occurs when TypeScript analyzes the code and determines that certain conditions or operations can refine the type information.(instanceof, in, typeof, const)</p>
<h3 id="indexed-access-types"><a class="header" href="#indexed-access-types">Indexed Access Types</a></h3>
<p>In TypeScript is it possible to access and manipulate  the types of properties within another type using an index, <code>Type[Key]</code>.</p>
<pre><code class="language-typescript">type Person = {
    name: string;
    age: number;
};

type AgeType = Person['age']; // number
</code></pre>
<pre><code class="language-typescript">type MyTuple = [string, number, boolean];
type MyType = MyTuple[2]; // boolean
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>On variables declared using <code>var</code>, <code>let</code> and <code>const</code>, it is possible to optionally add a type:</p>
<pre><code class="language-typescript">const x: number = 1;
</code></pre>
<p>TypeScript does a good job of inferring types, especially when simple one, so these declarations in most cases are not necessary.</p>
<p>On functions is possible to add type annotations to parameters:</p>
<pre><code class="language-typescript">function sum(a: number, b: number) {
    return a + b;
}
</code></pre>
<p>The following is an example using a anonymous functions (so called lambda function):</p>
<pre><code class="language-typescript">const sum = (a: number, b: number) =&gt; a + b;
</code></pre>
<p>These annotation can be avoided when a default value for a parameter is present:</p>
<pre><code class="language-typescript">const sum = (a = 10, b: number) =&gt; a + b;
</code></pre>
<p>Return type annotations can be added to functions:</p>
<pre><code class="language-typescript">const sum = (a = 10, b: number): number =&gt; a + b;
</code></pre>
<p>This is useful especially for  more complex functions as writing expliciting the return type before an implementation can help better think about the function.</p>
<p>Generally consider annotating type signatures but not the body local variables and add types always to object literals.</p>
<p>TypeScript provides convenient syntax for providing names for type annotations that you would like to use in more than one place. The aliases are created using the <code>type SomeName = someValidTypeAnnotation</code> syntax. An example is demonstrated below:</p>
<pre><code class="language-typescript">type StrOrNum = string|number;

// Usage: just like any other notation
var sample: StrOrNum;
sample = 123;
sample = '123';

// Just checking
sample = true; // Error!
</code></pre>
<p>Unlike an <code>interface</code> you can give a type alias to literally any type annotation (useful for stuff like union and intersection types). Here are a few more examples to make you familiar with the syntax:</p>
<pre><code class="language-typescript">type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) =&gt; void;
</code></pre>
<p><code>&gt; TIP:</code> If you need to have hierarchies of Type annotations use an <code>interface</code>. They can be used with <code>implements</code> and <code>extends</code></p>
<p><code>&gt; TIP:</code> Use a type alias for simpler object structures (like <code>Coordinates</code>) just to give them a semantic name. Also when you want to give semantic names to <strong>Union or Intersection types</strong>, a Type alias is the way to go.</p>
<h2 id="object-type"><a class="header" href="#object-type">Object Type</a></h2>
<p>TypeScript introduces the object type to cover types that are not primitive types. This includes any type that is not number, boolean, string, null, symbol, or undefined.</p>
<pre><code class="language-typescript">let structuredObject: object = {
  name: &quot;myObject&quot;,
  properties: {
    id: 1,
    type: &quot;AnObject&quot;
  }
};

// Define a function that takes an object as an argument and logs its string representation
function printObjectType(a: object) {
  console.log(`a: ${JSON.stringify(a)}`);
}

printObjectType(structuredObject);
printObjectType(&quot;this is a string&quot;);

</code></pre>
<h3 id="conditional-type"><a class="header" href="#conditional-type">Conditional Type</a></h3>
<pre><code class="language-typescript">type IsArray&lt;T&gt; = T extends any[] ? true : false;
const myArray = [1, 2, 3];
const myNumber = 42;
type IsMyArrayAnArray = IsArray&lt;typeof myArray&gt;; // Type true
type IsMyNumberAnArray = IsArray&lt;typeof myNumber&gt;; 
</code></pre>
<h4 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h4>
<p>conditional type inference in TypeScript is a feature that allows TypeScript to <strong>infer different types based on conditions</strong>.
Which statement best describes type inference in TypeScript?
A process by which TypeScript <strong>automatically</strong> infers the types of variables and expressions from their usage in code.</p>
<p>Better <strong>runtime performance is not</strong> a benefit of advanced type inference in TypeScript.</p>
<h3 id="ambient-declarations"><a class="header" href="#ambient-declarations">Ambient Declarations</a></h3>
<p><a href="types/./module/@types.html">’@’types</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convenience-vs-soundness"><a class="header" href="#convenience-vs-soundness">Convenience vs. Soundness</a></h1>
<p>There are a few things that TypeScript prevents you from doing out of the box e.g. using a variable that <em>isn’t ever declared</em> (of course you can use a <em>declaration file</em> for external systems).</p>
<p>That said, traditionally programming languages have a hard boundary between what is and isn’t allowed by the type system. TypeScript is different in that it gives you control over where you put the slider. This is really to allow you to use the JavaScript you know and love with as much safety as <strong>you</strong> want. There are lots of compiler options to control exactly this slider so let’s have a look.</p>
<h2 id="boolean-options"><a class="header" href="#boolean-options">Boolean Options</a></h2>
<p><code>compilerOptions</code> that are <code>boolean</code> can be specified as <code>compilerOptions</code> in <code>tsconfig.json</code>:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;someBooleanOption&quot;: true
    }
}
</code></pre>
<p>or on the command line</p>
<pre><code class="language-sh">tsc --someBooleanOption
</code></pre>
<blockquote>
<p>All of these are <code>false</code> by default.</p>
</blockquote>
<p>Click <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">here</a> to see all compiler options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noimplicitany-1"><a class="header" href="#noimplicitany-1">noImplicitAny</a></h1>
<p>There are some things that cannot be inferred or inferring them might result in unexpected errors. A fine example is function arguments. If you don’t annotate them, its unclear what should and shouldn’t be valid e.g.</p>
<pre><code class="language-typescript">function log(someArg) {
  sendDataToServer(someArg);
}

// What arg is valid and what isn't?
log(123);
log('hello world');
</code></pre>
<p>So if you don’t annotate some function argument, TypeScript assumes <code>any</code> and moves on. This essentially turns off type checking for such cases, which is what a JavaScript dev would expect. But this can catch people that want high safety off guard. Hence there is an option, <code>noImplicitAny</code>, that when switched on will flag the cases where the type cannot be inferred e.g.</p>
<pre><code class="language-typescript">function log(someArg) { // Error : someArg has an implicit `any` type
  sendDataToServer(someArg);
}
</code></pre>
<p>Of course you can then go ahead and annotate:</p>
<pre><code class="language-typescript">function log(someArg: number) {
  sendDataToServer(someArg);
}
</code></pre>
<p>And if you truly want <em>zero safety</em> you can mark it <em>explicitly</em> as <code>any</code>:</p>
<pre><code class="language-typescript">function log(someArg: any) {
  sendDataToServer(someArg);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strictnullchecks-2"><a class="header" href="#strictnullchecks-2"><code>strictNullChecks</code></a></h1>
<p>By default <code>null</code> and <code>undefined</code> are assignable to all types in TypeScript e.g.</p>
<pre><code class="language-typescript">let foo: number = 123;
foo = null; // Okay
foo = undefined; // Okay
</code></pre>
<p>This is modelled after how a lot of people write JavaScript. However, like all things, TypeScript allows you to be <em>explicit</em> about what <em>can and cannot be</em> assigned a <code>null</code> or <code>undefined</code>.</p>
<p>In strict null checking mode, <code>null</code> and <code>undefined</code> are different:</p>
<pre><code class="language-typescript">let foo = undefined;
foo = null; // NOT Okay
</code></pre>
<p>Let’s say we have a <code>Member</code> interface:</p>
<pre><code class="language-typescript">interface Member {
  name: string,
  age?: number
}
</code></pre>
<p>Not every <code>Member</code> will provide their age, so <code>age</code> is an optional property, meaning the value of <code>age</code> may or may not be <code>undefined</code>.</p>
<p><code>undefined</code> is the root of all evil. It often leads to runtime errors. It is easy to write code that will throw <code>Error</code> at runtime:</p>
<pre><code class="language-typescript">getMember()
  .then(member: Member =&gt; {
    const stringifyAge = member.age.toString() // Cannot read property 'toString' of undefined
  })
</code></pre>
<p>But in strict null checking mode, this error will be caught at compile time:</p>
<pre><code class="language-typescript">getMember()
  .then(member: Member =&gt; {
    const stringifyAge = member.age.toString() // Object is possibly 'undefined'
  })
</code></pre>
<h2 id="non-null-assertion-operator"><a class="header" href="#non-null-assertion-operator">Non-Null Assertion Operator</a></h2>
<p><code>definite assignment</code></p>
<p>A new <code>!</code> post-fix expression operator may be used to assert that its operand is <strong>non-null and non-undefined</strong> in contexts where the type checker is unable to conclude that fact. For example:</p>
<pre><code class="language-typescript">// Compiled with --strictNullChecks
function validateEntity(e?: Entity) {
    // Throw exception if e is null or invalid entity
}

function processEntity(e?: Entity) {
    validateEntity(e);
    let a = e.name;  // TS ERROR: e may be null.
    let b = e!.name;  // OKAY. We are asserting that e is non-null.
}
</code></pre>
<blockquote>
<p>Note that it is just an assertion, and just like type assertions <strong>you are responsible</strong>* for making sure the value is not null. A non-null assertion is essentially you telling the compiler “I know it’s not null so let me use it as though it’s not null”.</p>
</blockquote>
<p><code>Next Example</code></p>
<p>We have placed an exclamation mark (!) after the use of the globalString variable on line 8, which has now become globalString!. This will tell the compiler that we are overriding its type-checking rules and are willing to let it use the globalString variable even though it thinks it has not been assigned.</p>
<pre><code class="language-typescript">// Declare a variable named &quot;globalString&quot; with the type of &quot;string&quot;
var globalString: string;

// Call the function &quot;setGlobalString&quot; and pass in the argument &quot;this string is set&quot;
setGlobalString(&quot;this string is set&quot;);

// Log the current value of the &quot;globalString&quot; variable to the console, using the definite assignment assertion syntax to indicate that the variable has been assigned a value before this point.
console.log(`globalString = ${globalString!}`); // added ! to globalString without ! will expose `error TS2454: Variable 'globalString' is used before being assigned.`

// Define a function named &quot;setGlobalString&quot; that takes in a parameter named &quot;value&quot; with the type &quot;string&quot;
function setGlobalString(value: string) {
  // Assign the value of the &quot;value&quot; parameter to the &quot;globalString&quot; variable
  globalString = value;
}
</code></pre>
<h3 id="definite-assignment-assertion-operator"><a class="header" href="#definite-assignment-assertion-operator">Definite Assignment Assertion Operator</a></h3>
<p>TypeScript will also complain about properties in classes not being initialized e.g.:</p>
<pre><code class="language-typescript">class C {
  foo: number; // OKAY as assigned in constructor
  bar: string = &quot;hello&quot;; // OKAY as has property initializer
  baz: boolean; // TS ERROR: Property 'baz' has no initializer and is not assigned directly in the constructor.
  constructor() {
    this.foo = 42;
  }
}
</code></pre>
<p>You can use the definite assignment assertion postfixed to the property name to tell TypeScript that you are initializing it somewhere other than the constructor e.g.</p>
<pre><code class="language-typescript">class C {
  foo!: number;
  // ^
  // Notice this exclamation point!
  // This is the &quot;definite assignment assertion&quot; modifier.
  
  constructor() {
    this.initialize();
  }
  initialize() {
    this.foo = 0;
  }
}
</code></pre>
<p>You can also use this assertion with simple variable declarations e.g.:</p>
<pre><code class="language-typescript">let a: number[]; // No assertion
let b!: number[]; // Assert

initialize();

a.push(4); // TS ERROR: variable used before assignment
b.push(4); // OKAY: because of the assertion

function initialize() {
  a = [0, 1, 2, 3];
  b = [0, 1, 2, 3];
}
</code></pre>
<blockquote>
<p>Like all assertions, you are telling the compiler to trust you. The compiler will not complain even if the code doesn’t actually always assign the property.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>TypeScript supports 7 primitive types. A primitive data type refers to a type that is not an object and does not have any methods associated with it. In TypeScript, all primitive types are immutable, meaning their values cannot be changed once they are assigned.</p>
<h3 id="symbols"><a class="header" href="#symbols">Symbols</a></h3>
<p>Symbols are a primitive data type that represents an immutable value which is guaranteed to be globally unique throughout the lifetime of the program.</p>
<p>Symbols can be used as keys for object properties and provide a way to create non-enumerable properties.</p>
<pre><code class="language-typescript">const key1: symbol = Symbol('key1');
const key2: symbol = Symbol('key2');

const obj = {
    [key1]: 'value 1',
    [key2]: 'value 2',
};

console.log(obj[key1]); // value 1
console.log(obj[key2]); // value 2
</code></pre>
<p>In WeakMaps and WeakSets, symbols are now permissible as keys.</p>
<p>Symbols are unique identifiers that can be used as property keys in objects to prevent naming conflicts.</p>
<pre><code class="language-typescript">type Obj = {
    [sym: symbol]: number;
};

const a = Symbol('a');
const b = Symbol('b');
let obj: Obj = {};
obj[a] = 123;
obj[b] = 456;

console.log(obj[a]); // 123
console.log(obj[b]); // 456
</code></pre>
<h4 id="template-string-pattern-index-signatures"><a class="header" href="#template-string-pattern-index-signatures">Template String Pattern Index Signatures</a></h4>
<p>Template string pattern index signatures allow us to define flexible index signatures using template string patterns. This feature enables us to create objects that can be indexed with specific patterns of string keys, providing more control and specificity when accessing and manipulating properties.</p>
<p>TypeScript from version 4.4 allows index signatures for symbols and template string patterns.</p>
<pre><code class="language-typescript">const uniqueSymbol = Symbol('description');

type MyKeys = `key-${string}`;

type MyObject = {
    [uniqueSymbol]: string;
    [key: MyKeys]: number;
};

const obj: MyObject = {
    [uniqueSymbol]: 'Unique symbol key',
    'key-a': 123,
    'key-b': 456,
};

console.log(obj[uniqueSymbol]); // Unique symbol key
console.log(obj['key-a']); // 123
console.log(obj['key-b']); // 456
</code></pre>
<h4 id="using-declaration-and-explicit-resource-management"><a class="header" href="#using-declaration-and-explicit-resource-management">using declaration and Explicit Resource Management</a></h4>
<p>A <code>using</code> declaration is a block-scoped, immutable binding, similar to <code>const</code>, used for managing disposable resources. When initialized with a value, the <code>Symbol.dispose</code> method of that value is recorded and subsequently executed upon exiting the enclosing block scope.</p>
<p>This is based on ECMAScript’s Resource Management feature, which is useful for performing essential cleanup tasks after object creation, such as closing connections, deleting files, and releasing memory.</p>
<p><code>&gt;tags:</code> [[Important]] [[SuppressedError]] [[Disposal]]</p>
<p>Notes:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Due to its recent introduction in TypeScript version 5.2, most runtimes lack native support. You’ll need polyfills for: <code>Symbol.dispose</code>, <code>Symbol.asyncDispose</code>, <code>DisposableStack</code>, <code>AsyncDisposableStack</code>, <code>SuppressedError</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Additionally, you will need to configure your tsconfig.json as follows:</li>
</ul>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;es2022&quot;,
        &quot;lib&quot;: [&quot;es2022&quot;, &quot;esnext.disposable&quot;, &quot;dom&quot;]
    }
}
</code></pre>
<p>Example:</p>
<p><code>&gt;tags:</code> [[Important]] [[Error_Dispose]] [[Error]] [[Symbol]] #Polify</p>
<!-- skip -->
<pre><code class="language-typescript">//@ts-ignore
Symbol.dispose ??= Symbol('Symbol.dispose'); // Simple polify

const doWork = (): Disposable =&gt; {
    return {
        [Symbol.dispose]: () =&gt; {
            console.log('disposed');
        },
    };
};

console.log(1);

{
    using work = doWork(); // Resource is declared
    console.log(2);
} // Resource is disposed (e.g., `work[Symbol.dispose]()` is evaluated)

console.log(3);
</code></pre>
<p>The code will log:</p>
<pre><code class="language-md">1
2
disposed
3
</code></pre>
<p>A resource eligible for disposal must adhere to the <code>Disposable</code> interface:</p>
<pre><code class="language-typescript">// lib.esnext.disposable.d.ts
interface Disposable {
    [Symbol.dispose](): void;
}
</code></pre>
<p>The <code>using</code> declarations record resource disposal operations in a stack, ensuring they are disposed in reverse order of declaration:</p>
<!-- skip -->
<pre><code class="language-typescript">{
    using j = getA(),
        y = getB();
    using k = getC();
} // disposes `C`, then `B`, then `A`.
</code></pre>
<p>Resources are guaranteed to be disposed, even if subsequent code or exceptions occur. This may lead to disposal potentially throwing an exception, possibly suppressing another. To retain information on suppressed errors, a new native exception, <code>SuppressedError</code>, is introduced.</p>
<h4 id="await-using-declaration"><a class="header" href="#await-using-declaration">await using declaration</a></h4>
<p>An <code>await using</code> declaration handles an asynchronously disposable resource. The value must have a <code>Symbol.asyncDispose</code> method, which will be awaited at the block’s end.</p>
<!-- skip -->
<pre><code class="language-typescript">async function doWorkAsync() {
    await using work = doWorkAsync(); // Resource is declared
} // Resource is disposed (e.g., `await work[Symbol.asyncDispose]()` is evaluated)
</code></pre>
<p>For an asynchronously disposable resource, it must adhere to either the <code>Disposable</code> or <code>AsyncDisposable</code> interface:</p>
<pre><code class="language-typescript">// lib.esnext.disposable.d.ts
interface AsyncDisposable {
    [Symbol.asyncDispose](): Promise&lt;void&gt;;
}
</code></pre>
<!-- skip -->
<pre><code class="language-typescript">//@ts-ignore
Symbol.asyncDispose ??= Symbol('Symbol.asyncDispose'); // Simple polify

class DatabaseConnection implements AsyncDisposable {
    // A method that is called when the object is disposed asynchronously
    [Symbol.asyncDispose]() {
        // Close the connection and return a promise
        return this.close();
    }

    async close() {
        console.log('Closing the connection...');
        await new Promise(resolve =&gt; setTimeout(resolve, 1000));
        console.log('Connection closed.');
    }
}

async function doWork() {
    // Create a new connection and dispose it asynchronously when it goes out of scope
    await using connection = new DatabaseConnection(); //  Resource is declared
    console.log('Doing some work...');
} // Resource is disposed (e.g., `await connection[Symbol.asyncDispose]()` is evaluated)

doWork();
</code></pre>
<p>The code logs:</p>
<pre><code class="language-md">Doing some work...
Closing the connection...
Connection closed.
</code></pre>
<p>The <code>using</code> and <code>await using</code> declarations are allowed in Statements: <code>for</code>, <code>for-in</code>, <code>for-of</code>, <code>for-await-of</code>, <code>switch</code>.</p>
<h3 id="string"><a class="header" href="#string">string</a></h3>
<p>The <code>string</code> primitive type stores textual data, and the value is always double or single-quoted.</p>
<pre><code class="language-typescript">const x: string = 'x';
const y: string = 'y';
</code></pre>
<p>Strings can span multiple lines if surrounded by the backtick (`) character:</p>
<pre><code class="language-typescript">let sentence: string = `xxx,yyy`;
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean">boolean</a></h3>
<p>The <code>boolean</code> data type in TypeScript stores a binary value, either <code>true</code> or <code>false</code>.</p>
<pre><code class="language-typescript">const isReady: boolean = true;
</code></pre>
<h3 id="number-1"><a class="header" href="#number-1">number</a></h3>
<p>A <code>number</code> data type in TypeScript is represented with a 64-bit floating point value. A <code>number</code> type can represent integers and fractions.
TypeScript also supports hexadecimal, binary, and octal, for instance:</p>
<pre><code class="language-typescript">const decimal: number = 10;
const hexadecimal: number = 0xa00d; // Hexadecimal starts with 0x
const binary: number = 0b1010; // Binary starts with 0b
const octal: number = 0o633; // Octal starts with 0o
</code></pre>
<h3 id="bigint"><a class="header" href="#bigint">bigInt</a></h3>
<p>A <code>bigInt</code> represents numeric values that are very large (253 – 1) and cannot be represented with a <code>number</code>.</p>
<p>A <code>bigInt</code> can be created by calling the built-in function <code>BigInt()</code> or by adding <code>n</code> to the end of any integer numeric literal:</p>
<pre><code class="language-typescript">const x: bigint = BigInt(9007199254740991);
const y: bigint = 9007199254740991n;
</code></pre>
<p>Notes:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>bigInt</code> values cannot be mixed with <code>number</code> and cannot be used with built-in <code>Math</code>, they must be coerced to the same type.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>bigInt</code> values are available only if target configuration is ES2020 or higher.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-billion-dollar-mistake"><a class="header" href="#the-billion-dollar-mistake">The billion-dollar mistake</a></h2>
<p>The expression comes from Thomas Hoare, a famous and influential computer scientist who introduced null references to ALGOL in 1965. Many years later he admitted that it was a mistake, as it resulted in “innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.”</p>
<p>What does it mean in the context of JavaScript and TypeScript?</p>
<p><code>Uncaught TypeError: Cannot read property 'foo' of undefined</code></p>
<p>Are you familiar with this error message? I bet you are. It occurs whenever you’re trying to access a property or method of an object that you think is present, but turns out to not be there.</p>
<p>There are two ways of representing empty values in JavaScript - null and undefined. This kind of error can occur in both cases. strictNullChecks enables you to detect such mistakes at compile-time. It is an invaluable help and, when done properly, can lead to the complete eradication of this class of runtime bugs.</p>
<h2 id="any"><a class="header" href="#any">any</a></h2>
<p>It allows us to assign anything to the variable of type any.
TypeScript introduces the any type for such occasions. Specifying that an object has a type of any will, in essence, remove the TypeScript strict type checking.</p>
<p>The following TypeScript code shows how to use the any type to mimic our original JavaScript code, as follows:</p>
<pre><code class="language-typescript">// Declare a variable called item1 with a type of any and assign to it an object literal that has properties id and name
var item1: any = { id: 1, name: &quot;item1&quot; }

// Assign a new object literal to item1 with only an id property
item1 = { id: 2 };
</code></pre>
<p>TypeScript introduces the <strong>:any</strong> type for such occasions. Specifying that an object has a type of any will, in essence, <strong>remove the TypeScript strict type checking</strong>. Used for <strong>backward compatibility with JavaScript</strong>. In short, avoid the any type at any cost.</p>
<p>The any data type represents literally “any” value, it is the default value when TypeScript cannot infer the type or is not specified.</p>
<p>When using any TypeScript <strong>compiler skips</strong> the type checking so there is no type safety when any is being used. Generally <strong>do not use <code>any</code> to silence the compiler when an error occurs</strong>, instead focus on fixing the error as with using any it is possible to break contracts and we lose the benefits of TypeScript autocomplete.</p>
<p>The any type could be useful during a gradual <strong>migration</strong> from JavaScript to TypeScript, as it can silence the compiler.</p>
<p>For new projects use TypeScript configuration <strong>noImplicitAny</strong> which enables TypeScript to issue errors where any is used or inferred.</p>
<blockquote>
<p><em>The anytype is usually a source of errors which can mask real problems with your types. Avoid using it as much as possible.</em></p>
</blockquote>
<p>The <code>any</code> type is a special type (<strong>universal supertype</strong>) that can be used to represent any type of value (<em>primitives, objects, arrays, functions, errors, symbols</em>). It is often used in situations where the <strong>type of a value is not known at compile time</strong>, or when working with values from external APIs or libraries that do not have TypeScript typings.</p>
<p>By utilizing <code>any</code> type, you are indicating to the TypeScript compiler that values should be represented without any limitations. In order to maximizing type safety in your code consider the following:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Limit the usage of <code>any</code></strong> to specific cases where the type is truly unknown.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Do not return <code>any</code> types from a function</strong> as you will lose type safety in the code using that function weakening your type safety.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Instead of <code>any</code> use <code>@ts-ignore</code> if you need to silence the compiler.</strong></li>
</ul>
<p>The <code>any</code> type holds a special place in the TypeScript type system. It gives you an escape hatch from the type system to <strong>tell the compiler to bugger off</strong>. <code>any</code> is compatible with <strong>any and all</strong> types in the type system. This means that <strong>anything can be assigned to it</strong> and <strong>it can be assigned to anything</strong>. This is demonstrated in the example below:</p>
<pre><code class="language-typescript">var power: any;

// Takes any and all types
power = '123';
power = 123;

// Is compatible with all types
var num: number;
power = num;
num = power;
</code></pre>
<p>If you are porting JavaScript code to TypeScript, you are going to be close friends with <code>any</code> in the beginning. However, don’t take this friendship too seriously as it means that it is up to you to <strong>ensure the type safety</strong>. <em>You are basically telling the compiler</em> to <strong>not do any meaningful static analysis</strong>.</p>
<pre><code class="language-typescript">let value: any;
value = true; // Valid
value = 7; // Valid
</code></pre>
<h2 id="unknown-type"><a class="header" href="#unknown-type">Unknown type</a></h2>
<p>In TypeScript, the <code>unknown</code> type represents a value that is of an unknown type. Unlike <code>any</code> type, which allows for any type of value, <code>unknown</code> requires a type check or assertion before it can be used in a specific way so <strong>no operations are permitted on an <code>unknown</code> without first asserting or narrowing to a more specific type.</strong></p>
<pre><code class="language-typescript">// Declare a variable of type any with a string value
let a: any = &quot;test&quot;;

// Declare a variable of type number with a number value
let aNumber: number = 2;

// Attempt to assign a value of type any to a variable of type number
aNumber = a; // Ok
</code></pre>
<p>Next:</p>
<pre><code class="language-typescript">// Declare a variable of type unknown with a string value
let u: unknown = &quot;an unknown&quot;;

// Assign a number value to the unknown type variable
u = 1;

// Declare a variable of type number
let aNumber2: number;

// Assign the value of the unknown type variable to a number type variable
aNumber2 = u; // Skip. Not Ok
aNumber2 = &lt;number&gt;u; // Ok
</code></pre>
<pre><code class="language-typescript">const isString = (value: unknown): value is string =&gt; typeof value === 'string';
</code></pre>
<p>Next </p>
<pre><code class="language-typescript">type Options = {
    [prop: string]: unknown;
    a?: string;
    b?: string;
};
const fn = (options: Options) =&gt; undefined;
fn({ c: 'c' }); // Valid
</code></pre>
<p>using unknown as a <strong>double assertion type</strong></p>
<pre><code class="language-typescript">function handler(event: Event) {
    let element = event as unknown as HTMLElement; // Okay, fix compiler complain!
}
</code></pre>
<p>The <code>unknown</code> type is only assignable to any type and the <code>unknown</code> type itself, it is a type-safe alternative to <code>any</code>.</p>
<!-- skip -->
<pre><code class="language-typescript">let value: unknown;

let value1: unknown = value; // Valid
let value2: any = value; // Valid
let value3: boolean = value; // Invalid
let value4: number = value; // Invalid
</code></pre>
<pre><code class="language-typescript">const add = (a: unknown, b: unknown): number | undefined =&gt;
    typeof a === 'number' &amp;&amp; typeof b === 'number' ? a + b : undefined;
console.log(add(1, 2)); // 3
console.log(add('x', 2)); // undefined
</code></pre>
<p>When trying to get rid of the any instances from your codebase, you might run into situations where you actually have no way of knowing the type of some value. This is especially true when the value is “external”, meaning it’s returned by a backend endpoint or is deserialized from local storage. In such cases, it’s a good idea to type such value as unknown instead of any.</p>
<pre><code class="language-ts">interface Article {
    title: string;
    body: string;
}

fetch(&quot;http://example.com&quot;)
  .then(response =&gt; response.json())
  .then((body: unknown) =&gt; {
    const article = body as Article;
    // we need to cast, otherwise we'd get an error
    console.log(article.title);
  });
</code></pre>
<h3 id="any-vs-unknown"><a class="header" href="#any-vs-unknown">any vs unknown</a></h3>
<p>Both are <strong>equally unsafe</strong> as far as TypeScript is concerned. Use what makes you happy. Considerations:
The difference between the two, however, is that a variable of type unknown can’t be assigned to a known type without <strong>explicit casting</strong>.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Linters prefer unknown</strong> (with no-explicit-any rule)</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>any is less characters</strong> to type than unknown</li>
<li><input disabled="" type="checkbox" checked=""/>
Unlike <code>any</code> type, which allows for any type of value, <strong><code>unknown</code> requires a type check or assertion</strong> before it can be used in a specific way</li>
</ul>
<h2 id="undefined"><a class="header" href="#undefined">undefined</a></h2>
<h3 id="null-and-undefined"><a class="header" href="#null-and-undefined"><code>null</code> and <code>undefined</code></a></h3>
<p>How they are treated by the type system depends on the <code>strictNullChecks</code> compiler flag (we cover this flag later). When in <code>strictNullCheck:false</code>, the <code>null</code> and <code>undefined</code> JavaScript literals are effectively treated by the type system the same as something of type <code>any</code>. These literals can be assigned to any other type. This is demonstrated in the below example:</p>
<pre><code class="language-typescript">var num: number;
var str: string;

// These literals can be assigned to anything
num = null;
str = undefined;
</code></pre>
<pre><code class="language-typescript">let array = [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;];  // Initialize an array with 3 elements, &quot;123&quot;, &quot;456&quot;, and &quot;789&quot;
delete array[0]; // delete the element at index 0 of the array, in this case &quot;123&quot;. Using delete leaves a hole in the index and can cause unexpected behavior in many situations. 

// Use a for loop to iterate over the array
for (let i = 0; i &lt; array.length; i++) {
  checkAndPrintElement(array[i]); // call the checkAndPrintElement function with the current element of the array as a parameter
}

// checkAndPrintElement function 
function checkAndPrintElement(arrElement: string | undefined) {
  // check if the passed element is undefined
  if (arrElement === undefined) {
    console.log(`invalid array element`); // If the element is undefined, log the message &quot;invalid array element&quot;
  } else {
    console.log(`valid array element : ${arrElement}`); // Else if the element is defined, log the message &quot;valid array element: &quot; and the element
  }
}
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">:invalid array element
valid array element : 456
valid array element : 789
</code></pre>
<h3 id="return-validity-checking-by-undefined"><a class="header" href="#return-validity-checking-by-undefined">return validity checking by undefined</a></h3>
<blockquote>
<p>Don’t use return <code>undefined</code> as a means of denoting <em>validity</em></p>
</blockquote>
<p>For example an awful function like this:</p>
<pre><code class="language-typescript">function toInt(str: string) {
  return str ? parseInt(str) : undefined;
}
</code></pre>
<p>can be much better written like this:</p>
<pre><code class="language-typescript">function toInt(str: string): { valid: boolean, int?: number } {
  const int = parseInt(str);
  if (isNaN(int)) {
    return { valid: false };
  }
  else {
    return { valid: true, int };
  }
}
</code></pre>
<h3 id="limit-explicit-use-of-undefined"><a class="header" href="#limit-explicit-use-of-undefined">Limit explicit use of ‘undefined’</a></h3>
<p>Because TypeScript gives you the opportunity to <em>document</em> your structures separately from values instead of stuff like:</p>
<pre><code class="language-typescript">function foo(){
  // if Something
  return {a:1,b:2};
  // else
  return {a:1,b:undefined};//Valid
}
</code></pre>
<p>you should use a type annotation:</p>
<pre><code class="language-typescript">function foo():{a:number,b?:number}{
  // if Something
  return {a:1,b:2};
  // else
  return {a:1};//Valid
}
</code></pre>
<h3 id="json-and-serialization"><a class="header" href="#json-and-serialization">JSON and serialization</a></h3>
<p>The JSON standard has support for encoding <code>null</code> but not <code>undefined</code>. When JSON-encoding an object with an attribute that is <code>null</code>, the attribute will be included with its null value, whereas an attribute with an <code>undefined</code> value will be excluded entirely.</p>
<pre><code class="language-typescript">JSON.stringify({willStay: null, willBeGone: undefined}); // {&quot;willStay&quot;:null}
</code></pre>
<p>As a result, JSON-based databases may support <code>null</code> values but not <code>undefined</code> values. Since attributes set to <code>null</code> are encoded, you can transmit the intent to clear an attribute by setting its value to <code>null</code> before encoding and transmitting the object to a remote store.</p>
<p>Setting attribute values to undefined can save on storage and transmission costs, as the attribute names will not be encoded. However, this can complicate the semantics of clearing values vs. absent values.</p>
<h2 id="null"><a class="header" href="#null">null</a></h2>
<p>Along with undefined, JavaScript also allows values to be set to null. Setting a value to null is intended to indicate that the variable is known but has no value, as opposed to undefined, where the variable has not been defined in the current scope.  undefined is often seen as something that happens automatically or by default.</p>
<pre><code class="language-typescript">// function that takes a parameter of type `number` or `null`
function printValues(a: number | null) {
  console.log(`a = ${a}`);  // log the value of a
}

printValues(1); // call the function with a number value of 1
printValues(null); // call the function with a null value

</code></pre>
<p><code>&gt; Output:</code>
:a = 1
a = null</p>
<h2 id="null-and-undefined-1"><a class="header" href="#null-and-undefined-1">Null and Undefined</a></h2>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=kaUfBNzuUAI">Free youtube video on the subject</a></p>
</blockquote>
<p>JavaScript (and by extension TypeScript) has two bottom types : <code>null</code> and <code>undefined</code>. They are <em>intended</em> to mean different things:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Something hasn’t been <strong>initialized</strong> : <code>undefined</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Something is <strong>currently unavailable</strong>: <code>null</code>.</li>
</ul>
<pre><code class="language-typescript">// Both null and undefined are only `==` to themselves and each other:
console.log(null == null); // true (of course)
console.log(undefined == undefined); // true (of course)
console.log(null == undefined); // true


// You don't have to worry about falsy values making through this check
console.log(0 == undefined); // false
console.log('' == undefined); // false
console.log(false == undefined); // false
</code></pre>
<p>Recommend <code>== null</code> to check for both <code>undefined</code> or <code>null</code>. You generally don’t want to make a distinction between the two.</p>
<pre><code class="language-typescript">function foo(arg: string | null | undefined) {
  if (arg != null) {
    // arg must be a string as `!=` rules out both null and undefined. 
  }
}
</code></pre>
<p>Remember how I said you should use <code>== null</code>? Of course you do (cause I just said it ^). Don’t use it for root level things. In strict mode if you use <code>foo</code> and <code>foo</code> is undefined you get a <code>ReferenceError</code> <strong>exception</strong> and the whole call stack unwinds.</p>
<blockquote>
<p>You should use strict mode … and in fact the TS compiler will insert it for you if you use modules … more on those later in the book so you don’t have to be explicit about it :)</p>
</blockquote>
<p>So to check if a variable is defined or not at a <strong>global</strong> level you normally <strong>use <code>typeof</code></strong>:</p>
<pre><code class="language-typescript">if (typeof someglobal !== 'undefined') {
  // someglobal is now safe to use
  console.log(someglobal);
}
</code></pre>
<h3 id="nullish-coalescing"><a class="header" href="#nullish-coalescing">Nullish coalescing</a></h3>
<p>In general, it is a good idea to check that a particular variable is not either null or undefined before using it, as this can lead to errors.</p>
<pre><code class="language-typescript">function nullishCheck(a: number | undefined | null) {
    // Check if the passed variable 'a' is either undefined or null
    // If it is, then print 'undefined or null'
    // Else print the value of 'a'
    console.log(`a : ${a ?? `undefined or null`}`);
}

// Call the function with a number
nullishCheck(1);

// Call the function with null
nullishCheck(null);

// Call the function with undefined
nullishCheck(undefined);
</code></pre>
<h3 id="null-and-undefined-with-strictnullchecks"><a class="header" href="#null-and-undefined-with-strictnullchecks">null and undefined with <code>strictNullChecks</code></a></h3>
<p>TypeScript is smart enough to rule out both <code>null</code> and <code>undefined</code> with a <code>== null</code> / <code>!= null</code> check. For example:</p>
<pre><code class="language-typescript">function foo(a?: number | null) {
  if (a == null) return;

  // a is number now.
}
</code></pre>
<h2 id="never-type"><a class="header" href="#never-type">Never type</a></h2>
<p>The <code>never</code> type represents values that never occur. It is used to <strong>denote functions or expressions that never return or throw an error.</strong> This type is used to indicate instances where <strong>something should never occur</strong>. Even though this may sound confusing, we can often write code where this occurs.</p>
<h3 id="never-vs-null"><a class="header" href="#never-vs-null">never vs null</a></h3>
<p>The <code>never</code> type is used to ensure that the default case is exhaustive and that TypeScript will raise an error if a new value is added to the Direction type without being handled in the switch statement.</p>
<h3 id="never-use-cases"><a class="header" href="#never-use-cases">Never use-cases</a></h3>
<p>For instance an infinite loop:</p>
<pre><code class="language-typescript">const infiniteLoop = (): never =&gt; {
    while (true) {
        // do something
    }
};
</code></pre>
<p>Throwing an error:</p>
<pre><code class="language-typescript">const throwError = (message: string): never =&gt; {
    throw new Error(message);
};
</code></pre>
<p>The never type is used in TypeScript to denote this bottom type. Cases when it occurs naturally:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A function <strong>never returns</strong> (e.g. if the function body has while(true){})</li>
<li><input disabled="" type="checkbox" checked=""/>
A function <strong>always throws</strong> (e.g. in function foo(){throw new Error(‘Not Implemented’)} the return type of foo is never)</li>
</ul>
<pre><code class="language-typescript">let foo: never = 123; // Error: Type number is not assignable to never

// Okay as the function's return type is `never`
let bar: never = (() =&gt; { throw new Error(`Throw my hands in the air like I just don't care`) })();
</code></pre>
<p>And because <code>never</code> is only assignable to another <code>never</code> you can use it for <em>compile time</em> exhaustive checks as well. </p>
<p>The <code>never</code> type is useful in ensuring type safety and catching potential errors in your code. It helps TypeScript analyze and infer more precise types when used in combination with other types and control flow statements, for instance:</p>
<pre><code class="language-typescript">type Direction = 'up' | 'down';
const move = (direction: Direction): void =&gt; {
    switch (direction) {
        case 'up':
            // move up
            break;
        case 'down':
            // move down
            break;
        default:
            const exhaustiveCheck: never = direction;
            throw new Error(`Unhandled direction: ${exhaustiveCheck}`);
    }
};
</code></pre>
<p>When a variable is narrowed to a type that cannot contain any values, the TypeScript compiler will infer that the variable must be of the <code>never</code> type. This is because The never Type represents a value that can never be produced.</p>
<pre><code class="language-typescript">const printValue = (val: string | number) =&gt; {
    if (typeof val === 'string') {
        console.log(val.toUpperCase());
    } else if (typeof val === 'number') {
        console.log(val.toFixed(2));
    } else {
        // val has type never here because it can never be anything other than a string or a number
        const neverVal: never = val;
        console.log(`Unexpected value: ${neverVal}`);
    }
};
</code></pre>
<h2 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness checking</a></h2>
<p>Exhaustiveness checking is a feature in TypeScript that ensures all possible cases of a discriminated union are handled in a <code>switch</code> statement or an <code>if</code> statement.</p>
<pre><code class="language-typescript">type Direction = 'up' | 'down';

const move = (direction: Direction) =&gt; {
    switch (direction) {
        case 'up':
            console.log('Moving up');
            break;
        case 'down':
            console.log('Moving down');
            break;
        default:
            const exhaustiveCheck: never = direction;
            console.log(exhaustiveCheck); // This line will never be executed
    }
};
</code></pre>
<h2 id="void"><a class="header" href="#void">void</a></h2>
<p>Use <code>:void</code> to signify that a function does not have a return type:</p>
<pre><code class="language-typescript">function log(message): void {
    console.log(message);
}
</code></pre>
<p>As soon as someone tells you that never is returned when a function never exits gracefully you intuitively want to think of it as the same as void. However, void is a Unit. never is a falsum.</p>
<p>A function that returns nothing returns a Unit void. However, a function that never returns (or always throws) returns never. void is something that can be assigned (without strictNullChecking) but never can never be assigned to anything other than never.</p>
<pre><code class="language-typescript">// Inferred return type: void
function failDeclaration(message: string) {
  throw new Error(message);
}

// Inferred return type: never
const failExpression = function(message: string) {
  throw new Error(message);
};
</code></pre>
<h3 id="final-thoughts"><a class="header" href="#final-thoughts">Final thoughts</a></h3>
<p>TypeScript team doesn’t use <code>null</code> : <a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#null-and-undefined">TypeScript coding guidelines</a> and it hasn’t caused any problems. Douglas Crockford thinks <a href="https://www.youtube.com/watch?v=PSGEjv3Tqo0&amp;feature=youtu.be&amp;t=9m21s"><code>null</code> is a bad idea</a> and we should all just use <code>undefined</code>.</p>
<p>However, NodeJS style code bases uses <code>null</code> for Error arguments as standard as it denotes <code>Something is currently unavailable</code>. I personally don’t care to distinguish between the two as most projects use libraries with differing opinions and just rule out both with <code>== null</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="wapper-objects"><a class="header" href="#wapper-objects">Wapper Objects</a></h2>
<h3 id="boxed-types"><a class="header" href="#boxed-types">Boxed types</a></h3>
<p>Boxed types refer to the <strong>wrapper objects</strong> that are used to represent <strong>primitive types as objects</strong>. These wrapper objects <em>provide additional functionality and methods that are not available directly on the primitive values.</em></p>
<p>When you access a method like <code>charAt</code> or <code>normalize</code> on a <code>string</code> primitive, JavaScript wraps it in a <code>String</code> object, calls the method, and then throws the object away.</p>
<p>Demonstration:</p>
<pre><code class="language-typescript">const originalNormalize = String.prototype.normalize;
String.prototype.normalize = function () {
    console.log(this, typeof this);
    return originalNormalize.call(this);
};
console.log('\u0041'.normalize());
</code></pre>
<p>TypeScript represents this differentiation by providing separate types for the primitives and their corresponding object wrappers:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
string =&gt; String</li>
<li><input disabled="" type="checkbox" checked=""/>
number =&gt; Number</li>
<li><input disabled="" type="checkbox" checked=""/>
boolean =&gt; Boolean</li>
<li><input disabled="" type="checkbox" checked=""/>
symbol =&gt; Symbol</li>
<li><input disabled="" type="checkbox" checked=""/>
bigint =&gt; BigInt</li>
</ul>
<blockquote>
<p>The boxed types are usually not needed. Avoid using boxed types and instead use type for the primitives,  for instance <code>string</code> instead of <code>String</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="union-types"><a class="header" href="#union-types">Union types</a></h2>
<p>Quite commonly in JavaScript you want to allow a property to be one of multiple types e.g. <em>a <code>string</code> or a <code>number</code></em>. This is where the <em>union type</em> (denoted by <code>|</code> in a type annotation e.g. <code>string|number</code>) comes in handy. A common use case is a function that can take a single object or an array of the object e.g.:</p>
<pre><code class="language-typescript">function formatCommandline(command: string[]|string) {
    var line = '';
    if (typeof command === 'string') {
        line = command.trim();
    } else {
        line = command.join(' ').trim();
    }

    // Do stuff with line: string
}
</code></pre>
<p>They use the <strong>pipe symbol (|)</strong> to list all of the types that will make up this new type.</p>
<pre><code class="language-typescript">// Declare a function called printObject that takes in a parameter called obj with a type of string or number
function printObject(obj: string | number) {
  // Log the value of obj
  console.log(`obj = ${obj}`);
}

// Call printObject with a number value
printObject(1);

// Call printObject with a string value
printObject(&quot;string value&quot;);

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">obj = 1
obj = string value
</code></pre>
<h2 id="union-vs-intersection-vs-extends"><a class="header" href="#union-vs-intersection-vs-extends">Union vs Intersection vs Extends</a></h2>
<p>An union, (T1 | T2) creates a wider set (both):</p>
<pre><code class="language-typescript">type X = {
    a: string;
};
type Y = {
    b: string;
};
type XY = X | Y;
const r: XY = { a: 'a', b: 'x' }; // Valid
</code></pre>
<p>An intersection, (T1 &amp; T2) create a narrower set (only shared):</p>
<!-- skip -->
<pre><code class="language-typescript">type X = {
    a: string;
};
type Y = {
    a: string;
    b: string;
};
type XY = X &amp; Y;
const r: XY = { a: 'a' }; // Invalid
const j: XY = { a: 'a', b: 'b' }; // Valid
</code></pre>
<p>The <code>extends</code> keyword could be considered as a “subset of” in this context. It sets a constraint for a type. The extends used with a generic, take the generic as an infinite set and it will constrain it to a more specific type.
Please note that <code>extends</code> has nothing to do with hierarchy in a OOP sense (there is no this concept in TypeScript).
TypeScript works with sets and does not have a strict hierarchy, infact, as in the example below, two types could overlap without either being a subtype of the other type (TypeScript considers the structure, shape of the objects).</p>
<pre><code class="language-typescript">interface X {
    a: string;
}
interface Y extends X {
    b: string;
}
interface Z extends Y {
    c: string;
}
const z: Z = { a: 'a', b: 'b', c: 'c' };
interface X1 {
    a: string;
}
interface Y1 {
    a: string;
    b: string;
}
interface Z1 {
    a: string;
    b: string;
    c: string;
}
const z1: Z1 = { a: 'a', b: 'b', c: 'c' };

const r: Z1 = z; // Valid
</code></pre>
<h4 id="discriminated-unions"><a class="header" href="#discriminated-unions">Discriminated Unions</a></h4>
<p>Discriminated Unions in TypeScript are a type of union type that uses a common property, known as the discriminant, to narrow down the set of possible types for the union.</p>
<pre><code class="language-typescript">type Square = {
    kind: 'square'; // Discriminant
    size: number;
};

type Circle = {
    kind: 'circle'; // Discriminant
    radius: number;
};

type Shape = Square | Circle;

const area = (shape: Shape) =&gt; {
    switch (shape.kind) {
        case 'square':
            return Math.pow(shape.size, 2);
        case 'circle':
            return Math.PI - [x] Math.pow(shape.radius, 2);
    }
};

const square: Square = { kind: 'square', size: 5 };
const circle: Circle = { kind: 'circle', radius: 2 };

console.log(area(square)); // 25
console.log(area(circle)); // 12.566370614359172
</code></pre>
<p>Using a “Discriminated Union” is a pattern in TypeScript where an explicit “tag” is added to objects to distinguish between different types within a union. This pattern is also referred to as a “tagged union.” In the following example, the “tag” is represented by the property “type”:</p>
<pre><code class="language-typescript">type A = { type: 'type_a'; value: number };
type B = { type: 'type_b'; value: string };

const x = (input: A | B): string | number =&gt; {
    switch (input.type) {
        case 'type_a':
            return input.value + 100; // type is A
        case 'type_b':
            return input.value + 'extra'; // type is B
    }
};
</code></pre>
<p><a href="https://github.com/Microsoft/TypeScript/pull/5185">TypeScript/pull/5185</a></p>
<h2 id="template-union-types"><a class="header" href="#template-union-types">Template Union Types</a></h2>
<p>Template union types can be used to merge and manipulate text inside the type system for instance:</p>
<pre><code class="language-typescript">type Status = 'active' | 'inactive';
type Products = 'p1' | 'p2';
type ProductId = `id-${Products}-${Status}`; // &quot;id-p1-active&quot; | &quot;id-p1-inactive&quot; | &quot;id-p2-active&quot; | &quot;id-p2-inactive&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="discriminated-union"><a class="header" href="#discriminated-union">Discriminated Union</a></h3>
<p>If you have a class with a <a href="types/compound/union/./literal-types.html"><em>literal member</em></a> then you can use that property to discriminate between union members.</p>
<p>As an example consider the union of a <code>Square</code> and <code>Rectangle</code>, here we have a member <code>kind</code> that exists on both union members and is of a particular <em>literal type</em>:</p>
<pre><code class="language-typescript">interface Square {
    kind: &quot;square&quot;;
    size: number;
}

interface Rectangle {
    kind: &quot;rectangle&quot;;
    width: number;
    height: number;
}
type Shape = Square | Rectangle;
</code></pre>
<p>If you use a type guard style check (<code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>) or <code>switch</code> on the <em>discriminant property</em> (here <code>kind</code>) TypeScript will realize that the object must be of the type that has that specific literal and do a type narrowing for you :)</p>
<pre><code class="language-typescript">function area(s: Shape) {
    if (s.kind === &quot;square&quot;) {
        // Now TypeScript *knows* that `s` must be a square ;)
        // So you can use its members safely :)
        return s.size * s.size;
    }
    else {
        // Wasn't a square? So TypeScript will figure out that it must be a Rectangle ;)
        // So you can use its members safely :)
        return s.width * s.height;
    }
}
</code></pre>
<h3 id="exhaustive-checks"><a class="header" href="#exhaustive-checks">Exhaustive Checks</a></h3>
<p>Quite commonly you want to make sure that all members of a union have some code(action) against them.</p>
<pre><code class="language-typescript">interface Square {
    kind: &quot;square&quot;;
    size: number;
}

interface Rectangle {
    kind: &quot;rectangle&quot;;
    width: number;
    height: number;
}

// Someone just added this new `Circle` Type
// We would like to let TypeScript give an error at any place that *needs* to cater for this
interface Circle {
    kind: &quot;circle&quot;;
    radius: number;
}

type Shape = Square | Rectangle | Circle;
</code></pre>
<p>As an example of where stuff goes bad:</p>
<pre><code class="language-typescript">function area(s: Shape) {
    if (s.kind === &quot;square&quot;) {
        return s.size * s.size;
    }
    else if (s.kind === &quot;rectangle&quot;) {
        return s.width * s.height;
    }
    // Would it be great if you could get TypeScript to give you an error?
}
</code></pre>
<p>You can do that by simply adding a fall through and making sure that the inferred type in that block is compatible with the <code>never</code> type. For example if you add the exhaustive check you get a nice error:</p>
<pre><code class="language-typescript">function area(s: Shape) {
    if (s.kind === &quot;square&quot;) {
        return s.size * s.size;
    }
    else if (s.kind === &quot;rectangle&quot;) {
        return s.width * s.height;
    }
    else {
        // ERROR : `Circle` is not assignable to `never`
        const _exhaustiveCheck: never = s;
    }
}
</code></pre>
<p>That forces you to handle this new case : </p>
<pre><code class="language-typescript">function area(s: Shape) {
    if (s.kind === &quot;square&quot;) {
        return s.size * s.size;
    }
    else if (s.kind === &quot;rectangle&quot;) {
        return s.width * s.height;
    }
    else if (s.kind === &quot;circle&quot;) {
        return Math.PI * (s.radius **2);
    }
    else {
        // Okay once more
        const _exhaustiveCheck: never = s;
    }
}
</code></pre>
<h3 id="switch-1"><a class="header" href="#switch-1">Switch</a></h3>
<p>TIP: of course you can also do it in a <code>switch</code> statement:</p>
<pre><code class="language-typescript">function area(s: Shape) {
    switch (s.kind) {
        case &quot;square&quot;: return s.size * s.size;
        case &quot;rectangle&quot;: return s.width * s.height;
        case &quot;circle&quot;: return Math.PI * s.radius * s.radius;
        default: const _exhaustiveCheck: never = s;
    }
}
</code></pre>
<h3 id="strictnullchecks-3"><a class="header" href="#strictnullchecks-3">strictNullChecks</a></h3>
<p><code>&gt;tags:</code> [[Error_NullChecks]] [[Error_Return]] If using *<strong>strictNullChecks</strong> and doing exhaustive checks, TypeScript might complain “not all code paths return a value”. You can silence that by simply returning the <code>_exhaustiveCheck</code> variable (of type <code>never</code>). So:</p>
<pre><code class="language-typescript">function area(s: Shape) {
    switch (s.kind) {
        case &quot;square&quot;: return s.size * s.size;
        case &quot;rectangle&quot;: return s.width * s.height;
        case &quot;circle&quot;: return Math.PI * s.radius * s.radius;
        default:
          const _exhaustiveCheck: never = s;
          return _exhaustiveCheck;
    }
}
</code></pre>
<h3 id="throw-in-exhaustive-checks"><a class="header" href="#throw-in-exhaustive-checks">Throw in exhaustive checks</a></h3>
<p>You can write a function that takes a <code>never</code> (and therefore can only be called with a variable that is inferred as <code>never</code>) and then throws an error if its body ever executes: </p>
<pre><code class="language-typescript">function assertNever(x:never): never {
    throw new Error('Unexpected value. Should have been never.');
}
</code></pre>
<p>Example use with the area function: </p>
<pre><code class="language-typescript">interface Square {
    kind: &quot;square&quot;;
    size: number;
}
interface Rectangle {
    kind: &quot;rectangle&quot;;
    width: number;
    height: number;
}
type Shape = Square | Rectangle;

function area(s: Shape) {
    switch (s.kind) {
        case &quot;square&quot;: return s.size * s.size;
        case &quot;rectangle&quot;: return s.width * s.height;
		// If a new case is added at compile time you will get a compile error
		// If a new value appears at runtime you will get a runtime error
        default: return assertNever(s);
    }
}
</code></pre>
<h3 id="retrospective-versioning"><a class="header" href="#retrospective-versioning">Retrospective Versioning</a></h3>
<p>Say you have a data structure of the form: </p>
<p><code>&gt;tags:</code> [[DTO]] [[Versioning]]</p>
<pre><code class="language-typescript">type DTO = {
  name: string
}
</code></pre>
<p>And after you have a bunch of <code>DTO</code>s you realize that <code>name</code> was a poor choice. You can add versioning retrospectively by creating a new <em>union</em> with <em>literal number</em> (or string if you want) of DTO. Mark the version 0 as <code>undefined</code> and if you have <em>strictNullChecks</em> enabled it will just work out: </p>
<pre><code class="language-typescript">type DTO = 
| { 
   version: undefined, // version 0
   name: string,
 }
| {
   version: 1,
   firstName: string,
   lastName: string, 
}
// Even later 
| {
    version: 2,
    firstName: string,
    middleName: string,
    lastName: string, 
} 
// So on
</code></pre>
<p>Example usage of such a DTO:</p>
<pre><code class="language-typescript">function printDTO(dto:DTO) {
  if (dto.version == null) {
      console.log(dto.name);
  } else if (dto.version == 1) {
      console.log(dto.firstName,dto.lastName);
  } else if (dto.version == 2) {
      console.log(dto.firstName, dto.middleName, dto.lastName);
  } else {
      const _exhaustiveCheck: never = dto;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="types/compound/enum/enum.html#enums">Enums</a></li>
<li><a href="types/compound/enum/enum.html#number-enums-and-numbers">Number Enums and numbers</a></li>
<li><a href="types/compound/enum/enum.html#number-enums-and-strings">Number Enums and strings</a></li>
<li><a href="types/compound/enum/enum.html#changing-the-number-associated-with-a-number-enum">Changing the number associated with a number enum</a></li>
<li><a href="types/compound/enum/enum.html#enums-are-open-ended">Enums are open ended</a></li>
<li><a href="types/compound/enum/enum.html#number-enums-as-flags">Number Enums as flags</a></li>
<li><a href="types/compound/enum/enum.html#string-enums">String Enums</a></li>
<li><a href="types/compound/enum/enum.html#const-enums">Const enums</a></li>
<li><a href="types/compound/enum/enum.html#enum-with-static-functions">Enum with static functions</a></li>
</ul>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>An enum is a way to organize a collection of related values. Many other programming languages (C/C#/Java) have an <code>enum</code> data type but JavaScript does not. However, TypeScript does. Here is an example definition of a TypeScript enum:</p>
<pre><code class="language-typescript">enum CardSuit {
	Clubs,
	Diamonds,
	Hearts,
	Spades
}

// Sample usage
var card = CardSuit.Clubs;

// Safety
card = &quot;not a member of card suit&quot;; // Error : string is not assignable to type `CardSuit`
</code></pre>
<p>These enums values are <code>number</code>s so I’ll call them Number Enums from hence forth.</p>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<p>In TypeScript, an <code>enum</code> is a set of named constant values.</p>
<pre><code class="language-typescript">enum Color {
    Red = '#ff0000',
    Green = '#00ff00',
    Blue = '#0000ff',
}
</code></pre>
<p>Note: TypeScript allows the usage of heterogeneous Enums where string and numeric members can coexist.</p>
<h3 id="constant-enums"><a class="header" href="#constant-enums">Constant enums</a></h3>
<p>A constant enum in TypeScript is a special type of Enum where all the values are known at compile time and are inlined wherever the enum is used, resulting in more efficient code.</p>
<pre><code class="language-typescript">const enum Language {
    English = 'EN',
    Spanish = 'ES',
}
console.log(Language.English);
</code></pre>
<p>Will be compiled into:</p>
<pre><code class="language-js">console.log('EN' /- [x] Language.English */);
</code></pre>
<p><code>&gt;tags:</code> [[Important]] [[Hardcode]] [[Enum]]
Const Enums have hardcoded values, erasing the Enum, which can be more efficient in self-contained libraries but is generally not desirable. Also, Const enums cannot have computed members.</p>
<h4 id="number-enums-and-numbers"><a class="header" href="#number-enums-and-numbers">Number Enums and Numbers</a></h4>
<p>TypeScript enums are number based. This means that numbers can be assigned to an instance of the enum, and so can anything else that is compatible with <code>number</code>.</p>
<pre><code class="language-typescript">enum Color {
    Red,
    Green,
    Blue
}
var col = Color.Red;
col = 0; // Effectively same as Color.Red
</code></pre>
<h4 id="number-enums-and-strings"><a class="header" href="#number-enums-and-strings">Number Enums and Strings</a></h4>
<p>Before we look further into enums let’s look at the JavaScript that it generates, here is a sample TypeScript:</p>
<pre><code class="language-typescript">enum Tristate {
    False,
    True,
    Unknown
}
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-js">var Tristate;
(function (Tristate) {
    Tristate[Tristate[&quot;False&quot;] = 0] = &quot;False&quot;;
    Tristate[Tristate[&quot;True&quot;] = 1] = &quot;True&quot;;
    Tristate[Tristate[&quot;Unknown&quot;] = 2] = &quot;Unknown&quot;;
})(Tristate || (Tristate = {}));
</code></pre>
<p>let’s focus on the line <code>Tristate[Tristate[&quot;False&quot;] = 0] = &quot;False&quot;;</code>. Within it <code>Tristate[&quot;False&quot;] = 0</code> should be self explanatory, i.e. sets <code>&quot;False&quot;</code> member of <code>Tristate</code> variable to be <code>0</code>. Note that in JavaScript the assignment operator returns the assigned value (in this case <code>0</code>). Therefore the next thing executed by the JavaScript runtime is <code>Tristate[0] = &quot;False&quot;</code>. This means that you can use the <code>Tristate</code> variable to convert a string version of the enum to a number or a number version of the enum to a string. This is demonstrated below:</p>
<pre><code class="language-typescript">enum Tristate {
    False,
    True,
    Unknown
}
console.log(Tristate[0]); // &quot;False&quot;
console.log(Tristate[&quot;False&quot;]); // 0
console.log(Tristate[Tristate.False]); // &quot;False&quot; because `Tristate.False == 0`
</code></pre>
<h4 id="changing-the-number-associated-with-a-number-enum"><a class="header" href="#changing-the-number-associated-with-a-number-enum">Changing the number associated with a Number Enum</a></h4>
<p>By default enums are <code>0</code> based and then each subsequent value increments by 1 automatically. As an example consider the following:</p>
<pre><code class="language-typescript">enum Color {
    Red,     // 0
    Green,   // 1
    Blue     // 2
}
</code></pre>
<p>However, you can change the number associated with any enum member by assigning to it specifically. This is demonstrated below where we start at 3 and start incrementing from there:</p>
<pre><code class="language-typescript">enum Color {
    DarkRed = 3,  // 3
    DarkGreen,    // 4
    DarkBlue      // 5
}
console.log(`${Color.DarkGreen}`); // 4
</code></pre>
<blockquote>
<p>TIP: I quite commonly initialize the first enum with <code> = 1</code> as it allows me to do a safe truthy check on an enum value.</p>
</blockquote>
<h4 id="number-enums-as-flags"><a class="header" href="#number-enums-as-flags">Number Enums as flags</a></h4>
<p>One excellent use of enums is the ability to use enums as <code>Flags</code>. Flags allow you to check if a certain condition from a set of conditions is true. Consider the following example where we have a set of properties about animals:</p>
<pre><code class="language-typescript">enum AnimalFlags {
    None           = 0,
    HasClaws       = 1 &lt;&lt; 0, // Result 1
    CanFly         = 1 &lt;&lt; 1, // Result 2
    EatsFish       = 1 &lt;&lt; 2, // Result 4
    Endangered     = 1 &lt;&lt; 3 // Result 8
}
</code></pre>
<p>Here we are using the left shift operator to move <code>1</code> around a certain level of bits to come up with bitwise disjoint numbers <code>0001</code>, <code>0010</code>, <code>0100</code> and <code>1000</code> (these are decimals <code>1</code>,<code>2</code>,<code>4</code>,<code>8</code> if you are curious). The bitwise operators <code>|</code> (or) / <code>&amp;</code> (and) / <code>~</code> (not) are your best friends when working with flags and are demonstrated below:</p>
<pre><code class="language-typescript">enum AnimalFlags {
    None           = 0,
    HasClaws       = 1 &lt;&lt; 0,
    CanFly         = 1 &lt;&lt; 1,
}
type Animal = {
    flags: AnimalFlags
}

function printAnimalAbilities(animal: Animal) {
    var animalFlags = animal.flags;
    if (animalFlags &amp; AnimalFlags.HasClaws) {
        console.log('animal has claws');
    }
    if (animalFlags &amp; AnimalFlags.CanFly) {
        console.log('animal can fly');
    }
    if (animalFlags == AnimalFlags.None) {
        console.log('nothing');
    }
}

let animal: Animal = { flags: AnimalFlags.None };
printAnimalAbilities(animal); // nothing
animal.flags |= AnimalFlags.HasClaws;
printAnimalAbilities(animal); // animal has claws
animal.flags &amp;= ~AnimalFlags.HasClaws;
printAnimalAbilities(animal); // nothing
animal.flags |= AnimalFlags.HasClaws | AnimalFlags.CanFly;
printAnimalAbilities(animal); // animal has claws, animal can fly
</code></pre>
<p>Here:</p>
<ul>
<li>we used <code>|=</code> to add flags</li>
<li>a combination of <code>&amp;=</code> and <code>~</code> to clear a flag</li>
<li><code>|</code> to combine flags</li>
</ul>
<blockquote>
<p>Note: you can combine flags to create convenient shortcuts within the enum definition e.g. <code>EndangeredFlyingClawedFishEating</code> below:</p>
</blockquote>
<pre><code class="language-typescript">enum AnimalFlags {
	None           = 0,
    HasClaws       = 1 &lt;&lt; 0,
    CanFly         = 1 &lt;&lt; 1,
    EatsFish       = 1 &lt;&lt; 2,
    Endangered     = 1 &lt;&lt; 3,

	EndangeredFlyingClawedFishEating = HasClaws | CanFly | EatsFish | Endangered,
}
</code></pre>
<h4 id="string-enums"><a class="header" href="#string-enums">String Enums</a></h4>
<p>We’ve only looked at enums where the member values are <code>number</code>s. You are actually allowed to have enum members with string values as well. e.g. </p>
<pre><code class="language-typescript">export enum EvidenceTypeEnum {
  UNKNOWN = '',
  PASSPORT_VISA = 'passport_visa',
  PASSPORT = 'passport',
  SIGHTED_STUDENT_CARD = 'sighted_tertiary_edu_id',
  SIGHTED_KEYPASS_CARD = 'sighted_keypass_card',
  SIGHTED_PROOF_OF_AGE_CARD = 'sighted_proof_of_age_card',
}
</code></pre>
<p>These can be easier to deal with and debug as they provide meaningful / debuggable string values. </p>
<p>You can use these values to do simple string comparisons. e.g. </p>
<pre><code class="language-typescript">// Where `someStringFromBackend` will be '' | 'passport_visa' | 'passport' ... etc.
const value = someStringFromBackend as EvidenceTypeEnum; 

// Sample use in code
if (value === EvidenceTypeEnum.PASSPORT){
    console.log('You provided a passport');
    console.log(value); // `passport`
}
</code></pre>
<h4 id="const-enums"><a class="header" href="#const-enums">Const Enums</a></h4>
<p>If you have an enum definition like the following:</p>
<pre><code class="language-typescript">enum Tristate {
    False,
    True,
    Unknown
}

var lie = Tristate.False;
</code></pre>
<p>The line <code>var lie = Tristate.False</code> is compiled to the JavaScript <code>var lie = Tristate.False</code> (yes, output is same as input). This means that at execution the runtime will need to lookup <code>Tristate</code> and then <code>Tristate.False</code>. To get a performance boost here you can mark the <code>enum</code> as a <code>const enum</code>. This is demonstrated below:</p>
<pre><code class="language-typescript">const enum Tristate {
    False,
    True,
    Unknown
}

var lie = Tristate.False;
</code></pre>
<p>generates the JavaScript:</p>
<pre><code class="language-js">var lie = 0;
</code></pre>
<p>i.e. the compiler:</p>
<ol>
<li><em>Inlines</em> any usages of the enum (<code>0</code> instead of <code>Tristate.False</code>).</li>
<li>Does not generate any JavaScript for the enum definition (there is no <code>Tristate</code> variable at runtime) as its usages are inlined.</li>
</ol>
<h5 id="const-enum-preserveconstenums"><a class="header" href="#const-enum-preserveconstenums">Const enum preserveConstEnums</a></h5>
<p>Inlining has obvious performance benefits. The fact that there is no <code>Tristate</code> variable at runtime is simply the compiler helping you out by not generating JavaScript that is not actually used at runtime. However, you might want the compiler to still generate the JavaScript version of the enum definition for stuff like <em>number to string</em> or <em>string to number</em> lookups as we saw. In this case you can use the compiler flag <code>--preserveConstEnums</code> and it will still generate the <code>var Tristate</code> definition so that you can use <code>Tristate[&quot;False&quot;]</code> or <code>Tristate[0]</code> manually at runtime if you want. This does not impact <em>inlining</em> in any way.</p>
<h3 id="enum-with-static-functions"><a class="header" href="#enum-with-static-functions">Enum with static functions</a></h3>
<p>You can use the declaration <code>enum</code> + <code>namespace</code> merging to add static methods to an enum. The following demonstrates an example where we add a static member <code>isBusinessDay</code> to an enum <code>Weekday</code>:</p>
<pre><code class="language-typescript">enum Weekday {
	Monday,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
}
namespace Weekday {
	export function isBusinessDay(day: Weekday) {
		switch (day) {
			case Weekday.Saturday:
			case Weekday.Sunday:
				return false;
			default:
				return true;
		}
	}
}

const mon = Weekday.Monday;
const sun = Weekday.Sunday;
console.log(Weekday.isBusinessDay(mon)); // true
console.log(Weekday.isBusinessDay(sun)); // false
</code></pre>
<h4 id="enums-are-open-ended"><a class="header" href="#enums-are-open-ended">Enums are open ended</a></h4>
<blockquote>
<p>NOTE: open ended enums are only relevant if you are not using modules. You should be using modules. Hence this section is last.</p>
</blockquote>
<p>Here is the generated JavaScript for an enum shown again:</p>
<pre><code class="language-js">var Tristate;
(function (Tristate) {
    Tristate[Tristate[&quot;False&quot;] = 0] = &quot;False&quot;;
    Tristate[Tristate[&quot;True&quot;] = 1] = &quot;True&quot;;
    Tristate[Tristate[&quot;Unknown&quot;] = 2] = &quot;Unknown&quot;;
})(Tristate || (Tristate = {}));
</code></pre>
<p>We already explained the <code>Tristate[Tristate[&quot;False&quot;] = 0] = &quot;False&quot;;</code> portion. Now notice the surrounding code <code>(function (Tristate) { /*code here */ })(Tristate || (Tristate = {}));</code> specifically the <code>(Tristate || (Tristate = {}));</code> portion. This basically captures a local variable <code>TriState</code> that will either point to an already defined <code>Tristate</code> value or initialize it with a new empty <code>{}</code> object.</p>
<p>This means that you can split (and extend) an enum definition across multiple files. For example below we have split the definition for <code>Color</code> into two blocks</p>
<pre><code class="language-typescript">enum Color {
    Red,
    Green,
    Blue
}

enum Color {
    DarkRed = 3,
    DarkGreen,
    DarkBlue
}
</code></pre>
<p>Note that you <em>should</em> reinitialize the first member (here <code>DarkRed = 3</code>) in a continuation of an enum to get the generated code not clobber values from a previous definition (i.e. the <code>0</code>, <code>1</code>, … so on values). TypeScript will warn you if you don’t anyways (error message <code>In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.</code>).</p>
<h3 id="computed-members"><a class="header" href="#computed-members">Computed members</a></h3>
<pre><code class="language-typescript">// Computed members
enum Color {
    Red = 1,
    Green = Math.pow(2, 2),
    Blue = Math.floor(Math.random() - [x] 3) + 1,
}
console.log(Color.Blue); // random number generated at run time
</code></pre>
<p>Enums are denoted by unions comprising their member types. The values of each member can be determined through constant or non-constant expressions, with members possessing constant values being assigned literal types. To illustrate, consider the declaration of type E and its subtypes E.A, E.B, and E.C. In this case, E represents the union E.A | E.B | E.C.</p>
<pre><code class="language-typescript">const identity = (value: number) =&gt; value;

enum E {
    A = 2 - [x] 5, // Numeric literal
    B = 'bar', // String literal
    C = identity(42), // Opaque computed
}

console.log(E.C); //42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tuple-type"><a class="header" href="#tuple-type">Tuple Type</a></h2>
<p>JavaScript doesn’t have first class tuple support. People generally just use an array as a tuple. This is exactly what the TypeScript type system supports. Tuples can be annotated using <code>: [typeofmember1, typeofmember2]</code> etc. A tuple can have any number of members. Tuples are demonstrated in the below example:</p>
<pre><code class="language-typescript">var nameNumber: [string, number];

// Okay
nameNumber = ['Jenny', 8675309];

// Error!
nameNumber = ['Jenny', '867-5309'];
</code></pre>
<p>Combine this with the destructuring support in TypeScript, tuples feel fairly first class despite being arrays underneath:</p>
<pre><code class="language-typescript">var nameNumber: [string, number];
nameNumber = ['Jenny', 8675309];

var [name, num] = nameNumber;
</code></pre>
<h3 id="variadic-tuple-types"><a class="header" href="#variadic-tuple-types">Variadic Tuple Types</a></h3>
<p>Variadic Tuple Types are a features introduces in TypeScript version 4.0, let’s start to learn them by revise what is a tuple:</p>
<p>A tuple type is an array which has a defined length, and were the type of each element is known:</p>
<pre><code class="language-typescript">type Student = [string, number];
const [name, age]: Student = ['Simone', 20];
</code></pre>
<p>The term <strong>“variadic” means indefinite arity</strong> (accept a variable number of arguments).</p>
<p>A variadic tuple is a tuple type which has all the property as before but the exact shape is not defined yet:</p>
<pre><code class="language-typescript">type Bar&lt;T extends unknown[]&gt; = [boolean, ...T, number];

type A = Bar&lt;[boolean]&gt;; // [boolean, boolean, number]
type B = Bar&lt;['a', 'b']&gt;; // [boolean, 'a', 'b', number]
type C = Bar&lt;[]&gt;; // [boolean, number]
</code></pre>
<p>In the previous code we can see that the tuple shape is defined by the <code>T</code> generic passed in.</p>
<p>Variadic tuples can accept multiple generics make them very flexible:</p>
<pre><code class="language-typescript">type Bar&lt;T extends unknown[], G extends unknown[]&gt; = [...T, boolean, ...G];

type A = Bar&lt;[number], [string]&gt;; // [number, boolean, string]
type B = Bar&lt;['a', 'b'], [boolean]&gt;; // [&quot;a&quot;, &quot;b&quot;, boolean, boolean]
</code></pre>
<p>With the new variadic tuples we can use:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The spreads in tuple type syntax can now be generic, so we can represent higher-order operation on tuples and arrays even when we do not know the actual types we are operating over.</li>
<li><input disabled="" type="checkbox" checked=""/>
The rest elements can occur anywhere in a tuple.</li>
</ul>
<p>Example:</p>
<pre><code class="language-typescript">type Items = readonly unknown[];

function concat&lt;T extends Items, U extends Items&gt;(
    arr1: T,
    arr2: U
): [...T, ...U] {
    return [...arr1, ...arr2];
}

concat([1, 2, 3], ['4', '5', '6']); // [1, 2, 3, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics allow you to create reusable components and functions that <strong>can work with multiple types</strong>. With generics, you can parameterize types, functions, and interfaces, allowing them to <strong>operate on different types without explicitly specifying them beforehand.</strong></p>
<p>The key motivation for generics is to document meaningful type dependencies between members. The members can be:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Class instance members</li>
<li><input disabled="" type="checkbox" checked=""/>
Class methods</li>
<li><input disabled="" type="checkbox" checked=""/>
function arguments</li>
<li><input disabled="" type="checkbox" checked=""/>
function return value</li>
</ul>
<p>Many algorithms and data structures in computer science do not depend on the <em>actual type</em> of the object. However, you still want to enforce a constraint between various variables. A simple toy example is a function that takes a list of items and returns a reversed list of items. The constraint here is between what is passed in to the function and what is returned by the function:</p>
<pre><code class="language-typescript">function reverse&lt;T&gt;(items: T[]): T[] {
    var toreturn = [];
    for (let i = items.length - 1; i &gt;= 0; i--) {
        toreturn.push(items[i]);
    }
    return toreturn;
}

var sample = [1, 2, 3];
var reversed = reverse(sample);
console.log(reversed); // 3,2,1

// Safety!
reversed[0] = '1';     // Error!
reversed = ['1', '2']; // Error!

reversed[0] = 1;       // Okay
reversed = [1, 2];     // Okay
</code></pre>
<p>Here you are basically saying that the function <code>reverse</code> takes an array (<code>items: T[]</code>) of <em>some</em> type <code>T</code> (notice the type parameter in <code>reverse&lt;T&gt;</code>) and returns an array of type <code>T</code> (notice <code>: T[]</code>). Because the <code>reverse</code> function returns items of the same type as it takes, TypeScript knows the <code>reversed</code> variable is also of type <code>number[]</code> and will give you Type safety. Similarly if you pass in an array of <code>string[]</code> to the reverse function the returned result is also an array of <code>string[]</code> and you get similar type safety as shown below:</p>
<pre><code class="language-typescript">var strArr = ['1', '2'];
var reversedStrs = reverse(strArr);

reversedStrs = [1, 2]; // Error!
</code></pre>
<p>In fact JavaScript arrays already have a <code>.reverse</code> function and TypeScript does indeed use generics to define its structure:</p>
<pre><code class="language-typescript">interface Array&lt;T&gt; {
 reverse(): T[];
 // ...
}
</code></pre>
<p>This means that you get type safety when calling <code>.reverse</code> on any array as shown below:</p>
<pre><code class="language-typescript">var numArr = [1, 2];
var reversedNums = numArr.reverse();

reversedNums = ['1', '2']; // Error!
</code></pre>
<p>We will discuss more about the <code>Array&lt;T&gt;</code> interface later when we present <code>lib.d.ts</code> in the section <strong>Ambient Declarations</strong>.</p>
<h3 id="generic-type"><a class="header" href="#generic-type">Generic Type</a></h3>
<p>To define a generic type, you use angle brackets (<code>&lt;&gt;</code>) to specify the type parameters, for instance:</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
const a = identity('x');
const b = identity(123);

const getLen = &lt;T,&gt;(data: ReadonlyArray&lt;T&gt;) =&gt; data.length;
const len = getLen([1, 2, 3]);
</code></pre>
<h3 id="generic-classes"><a class="header" href="#generic-classes">Generic Classes</a></h3>
<p>Generics can be applied also to classes, in this way they can work with multiple types by using type parameters. This is useful to create reusable class definitions that can operate on different data types while maintaining type safety.</p>
<pre><code class="language-typescript">class Container&lt;T&gt; {
    private item: T;

    constructor(item: T) {
        this.item = item;
    }

    getItem(): T {
        return this.item;
    }
}

const numberContainer = new Container&lt;number&gt;(123);
console.log(numberContainer.getItem()); // 123

const stringContainer = new Container&lt;string&gt;('hello');
console.log(stringContainer.getItem()); // hello
</code></pre>
<h3 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h3>
<p>Generic parameters can be constrained using the <code>extends</code> keyword followed by a type or interface that the type parameter must satisfy.</p>
<p>In the following example T it is must containing a properly <code>length</code> in order to be valid:</p>
<!-- skip -->
<pre><code class="language-typescript">const printLen = &lt;T extends { length: number }&gt;(value: T): void =&gt; {
    console.log(value.length);
};

printLen('Hello'); // 5
printLen([1, 2, 3]); // 3
printLen({ length: 10 }); // 10
printLen(123); // Invalid
</code></pre>
<p><code>&gt;tags:</code> [[Important]] #Propagated_Type [[Generic]] [[PointFree]] [[Propagate]]</p>
<p>An interesting feature of generic introduced in version 3.4 RC is Higher order function type inference which introduced  propagated generic type arguments:</p>
<pre><code class="language-typescript">declare function pipe&lt;A extends any[], B, C&gt;(
    ab: (...args: A) =&gt; B,
    bc: (b: B) =&gt; C
): (...args: A) =&gt; C;

declare function list&lt;T&gt;(a: T): T[];
declare function box&lt;V&gt;(x: V): { value: V };

const listBox = pipe(list, box); // &lt;T&gt;(a: T) =&gt; { value: T[] }
const boxList = pipe(box, list); // &lt;V&gt;(x: V) =&gt; { value: V }[]
</code></pre>
<p>This functionality allows more easily typed safe pointfree style programming which is common in functional programming.</p>
<h3 id="generic-contextual-narrowing"><a class="header" href="#generic-contextual-narrowing">Generic contextual narrowing</a></h3>
<p>Contextual narrowing for generics is the mechanism in TypeScript that allows the compiler to narrow down the type of a generic parameter based on the context in which it is used, it is useful when working with generic types in conditional statements:</p>
<pre><code class="language-typescript">function process&lt;T&gt;(value: T): void {
    if (typeof value === 'string') {
        // Value is narrowed down to type 'string'
        console.log(value.length);
    } else if (typeof value === 'number') {
        // Value is narrowed down to type 'number'
        console.log(value.toFixed(2));
    }
}

process('hello'); // 5
process(3.14159); // 3.14
</code></pre>
<h2 id="motivation-and-samples"><a class="header" href="#motivation-and-samples">Motivation and samples</a></h2>
<p>Consider the simple <code>Queue</code> (first in, first out) data structure implementation. A simple one in TypeScript / JavaScript looks like:</p>
<pre><code class="language-typescript">class Queue {
  private data = [];
  push(item) { this.data.push(item); }
  pop() { return this.data.shift(); }
}
</code></pre>
<p>One issue with this implementation is that it allows people to add <em>anything</em> to the queue and when they pop it - it can be <em>anything</em>. This is shown below, where someone can push a <code>string</code> onto the queue while the usage actually assumes that only <code>numbers</code> were pushed in:</p>
<pre><code class="language-typescript">class Queue {
  private data = [];
  push(item) { this.data.push(item); }
  pop() { return this.data.shift(); }
}

const queue = new Queue();
queue.push(0);
queue.push(&quot;1&quot;); // Oops a mistake

// a developer walks into a bar
console.log(queue.pop().toPrecision(1));
console.log(queue.pop().toPrecision(1)); // RUNTIME ERROR
</code></pre>
<p>One solution (and in fact the only one in languages that don’t support generics) is to go ahead and create <em>special</em> classes just for these constraints. E.g. a quick and dirty number queue:</p>
<pre><code class="language-typescript">class QueueNumber extends Queue {
  push(item: number) { super.push(item); }
  pop(): number { return this.data.shift(); }
}

const queue = new QueueNumber();
queue.push(0);
queue.push(&quot;1&quot;); // ERROR : cannot push a string. Only numbers allowed

// ^ if that error is fixed the rest would be fine too
</code></pre>
<p>Of course this can quickly become painful e.g. if you want a string queue you have to go through all that effort again. What you really want is a way to say that whatever the type is of the stuff getting <em>pushed</em> it should be the same for whatever gets <em>popped</em>. This is done easily with a <em>generic</em> parameter (in this case, at the class level):</p>
<pre><code class="language-typescript">/** A class definition with a generic parameter */
class Queue&lt;T&gt; {
  private data = [];
  push(item: T) { this.data.push(item); }
  pop(): T | undefined { return this.data.shift(); }
}

/** Again sample usage */
const queue = new Queue&lt;number&gt;();
queue.push(0);
queue.push(&quot;1&quot;); // ERROR : cannot push a string. Only numbers allowed

// ^ if that error is fixed the rest would be fine too
</code></pre>
<p>Another example that we have already seen is that of a <em>reverse</em> function, here the constraint is between what gets passed into the function and what the function returns:</p>
<pre><code class="language-typescript">function reverse&lt;T&gt;(items: T[]): T[] {
    var toreturn = [];
    for (let i = items.length - 1; i &gt;= 0; i--) {
        toreturn.push(items[i]);
    }
    return toreturn;
}

var sample = [1, 2, 3];
var reversed = reverse(sample);
console.log(reversed); // 3,2,1

// Safety!
reversed[0] = '1';     // Error!
reversed = ['1', '2']; // Error!

reversed[0] = 1;       // Okay
reversed = [1, 2];     // Okay
</code></pre>
<p>In this section you have seen examples of generics being defined <em>at class level</em> and at <em>function level</em>. One minor addition worth mentioning is that you can have generics created just for a member function. As a toy example consider the following where we move the <code>reverse</code> function into a <code>Utility</code> class:</p>
<pre><code class="language-typescript">class Utility {
  reverse&lt;T&gt;(items: T[]): T[] {
      var toreturn = [];
      for (let i = items.length - 1; i &gt;= 0; i--) {
          toreturn.push(items[i]);
      }
      return toreturn;
  }
}
</code></pre>
<blockquote>
<p>TIP: You can call the generic parameter whatever you want. It is conventional to use <code>T</code>, <code>U</code>, or <code>V</code> when you have simple generics. If you have more than one generic argument try to use meaningful names like <code>TKey</code> and <code>TValue</code>. The convention is to prefix with <code>T</code> because generics are also called <em>templates</em> in other languages like C++.</p>
</blockquote>
<h3 id="design-pattern-convenience-generic"><a class="header" href="#design-pattern-convenience-generic">Design Pattern: Convenience generic</a></h3>
<p>Consider the function: </p>
<pre><code class="language-typescript">declare function parse&lt;T&gt;(name: string): T;
</code></pre>
<p>In this case you can see that the type <code>T</code> is only used in one place. So there is no constraint <em>between</em> members. This is equivalent to a type assertion in terms of type safety:</p>
<pre><code class="language-typescript">declare function parse(name: string): any;

const something = parse('something') as TypeOfSomething;
</code></pre>
<p>Generics used <em>only once</em> are no better than an assertion in terms of type safety. That said they do provide <em>convenience</em> to your API.</p>
<p>A more obvious example is a function that loads a json response. It returns a promise of <em>whatever type you pass in</em>:</p>
<pre><code class="language-typescript">const getJSON = &lt;T&gt;(config: {
    url: string,
    headers?: { [key: string]: string },
  }): Promise&lt;T&gt; =&gt; {
    const fetchConfig = ({
      method: 'GET',
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      ...(config.headers || {})
    });
    return fetch(config.url, fetchConfig)
      .then&lt;T&gt;(response =&gt; response.json());
  }
</code></pre>
<p>Note that you still have to explicitly annotate what you want, but the <code>getJSON&lt;T&gt;</code> signature <code>(config) =&gt; Promise&lt;T&gt;</code> saves you a few key strokes (you don’t need to annotate the return type of <code>loadUsers</code> as it can be inferred):</p>
<pre><code class="language-typescript">type LoadUsersResponse = {
  users: {
    name: string;
    email: string;
  }[];  // array of user objects
}
function loadUsers() {
  return getJSON&lt;LoadUsersResponse&gt;({ url: 'https://example.com/users' });
}
</code></pre>
<p>Also <code>Promise&lt;T&gt;</code> as a return value is definitely better than alternatives like <code>Promise&lt;any&gt;</code>.</p>
<p>Another example is where a generic is only used as an argument: </p>
<pre><code class="language-typescript">declare function send&lt;T&gt;(arg: T): void;
</code></pre>
<p>Here the generic <code>T</code> can be used to annote the type that you want the argument to match e.g. </p>
<pre><code class="language-typescript">send&lt;Something&gt;({
  x:123,
  // Also you get autocomplete  
}); // Will TSError if `x:123` does not match the structure expected for Something

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-assertion"><a class="header" href="#type-assertion">Type Assertion</a></h2>
<p>TypeScript allows you to override its inferred and analyzed view of types in any way you want to. This is done by a mechanism called “type assertion”. TypeScript’s type assertion is purely <strong>you telling the compiler that you know about the types(unsafe)</strong> better than it does, and that it should not second guess you.</p>
<p>Type assertion using <code>as</code></p>
<pre><code class="language-typescript">const user2 = {
    name: 'Simon',
    nickName: undefined,
    attributes: ['dev', 'admin'],
} as User;
</code></pre>
<p>A common use case for type assertion is when you are porting over code from JavaScript to TypeScript. For example consider the following pattern:</p>
<pre><code class="language-typescript">var foo = {};
foo.bar = 123; // Error: property 'bar' does not exist on `{}`
foo.bas = 'hello'; // Error: property 'bas' does not exist on `{}`
</code></pre>
<p>Here the code errors because the <strong>inferred</strong> type of <code>foo</code> is <code>{}</code> i.e. an object with zero properties. Therefore you are not allowed to add <code>bar</code> or <code>bas</code> to it. You can <strong>fix this simply by a type assertion <code>as Foo</code></strong>:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number;
    bas: string;
}
var foo = {} as Foo;
foo.bar = 123;
foo.bas = 'hello';
</code></pre>
<h3 id="as-foo-vs-foo"><a class="header" href="#as-foo-vs-foo"><code>as foo</code> vs. <code>&lt;foo&gt;</code></a></h3>
<p>Originally the syntax that was added was <code>&lt;foo&gt;</code>. This is demonstrated below:</p>
<pre><code class="language-typescript">var foo: any;
var bar = &lt;string&gt; foo; // bar is now of type &quot;string&quot;
</code></pre>
<p>However, there is an ambiguity in the language grammar when using <code>&lt;foo&gt;</code> style assertions in JSX:</p>
<pre><code class="language-typescript">var foo = &lt;string&gt;bar;
&lt;/string&gt;
</code></pre>
<p>Therefore it is now recommended that you just use <code>as foo</code> for consistency.</p>
<h3 id="type-assertion-vs-casting"><a class="header" href="#type-assertion-vs-casting">Type Assertion vs. Casting</a></h3>
<p>The reason why it’s not called “type casting” is that <em>casting</em> generally implies some sort of runtime support. However, <em>type assertions</em> are purely a compile time construct and a way for you to provide hints to the compiler on how you want your code to be analyzed.</p>
<h3 id="assertion-considered-harmful"><a class="header" href="#assertion-considered-harmful">Assertion considered harmful</a></h3>
<p>In many cases assertion will allow you to easily migrate legacy code (and even copy paste other code samples into your codebase). However, you should be careful with your use of assertions. Take our original code as a sample, the compiler will not protect you from forgetting to <em>actually add the properties you promised</em>:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number;
    bas: string;
}
var foo = {} as Foo;
// ahhhh .... forget something?
</code></pre>
<p>Also another common thought is using an assertion as a means of providing <em>autocomplete</em> e.g.:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number;
    bas: string;
}
var foo = &lt;Foo&gt;{
    // the compiler will provide autocomplete for properties of Foo
    // But it is easy for the developer to forget adding all the properties
    // Also this code is likely to break if Foo gets refactored (e.g. a new property added)
};
</code></pre>
<p>but the hazard here is the same, if you forget a property the compiler will not complain. It is better if you do the following:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number;
    bas: string;
}
var foo: Foo = {
    // the compiler will provide autocomplete for properties of Foo
};
</code></pre>
<p>In some cases you might need to create a temporary variable, but at least you will not be making (possibly false) promises and instead relying on the type inference to do the checking for you.</p>
<h3 id="double-assertion"><a class="header" href="#double-assertion">Double assertion</a></h3>
<p>The type assertion, despite being a bit <strong>unsafe</strong> as we’ve shown, is not <em>completely open season</em>. E.g. the following is a very valid use case (e.g. the user thinks the event passed in will be a more specific case of an event) and the type assertion works as expected:</p>
<pre><code class="language-typescript">function handler (event: Event) {
    let mouseEvent = event as MouseEvent;
}
</code></pre>
<p>However, the following is most likely an error and TypeScript will complain as shown despite the user’s type assertion:</p>
<pre><code class="language-typescript">function handler(event: Event) {
    let element = event as HTMLElement; // Error: Neither 'Event' nor type 'HTMLElement' is assignable to the other
}
</code></pre>
<p>If you <em>still want that Type, you can use a double assertion</em>, but first asserting to <code>unknown</code> (or <code>any</code>) which is compatible with all types and therefore the compiler no longer complains:</p>
<pre><code class="language-typescript">function handler(event: Event) {
    let element = event as unknown as HTMLElement; // Okay!
}
</code></pre>
<h4 id="how-typescript-determines-if-a-single-assertion-is-not-enough"><a class="header" href="#how-typescript-determines-if-a-single-assertion-is-not-enough">How TypeScript determines if a single assertion is not enough</a></h4>
<p>Basically, the assertion from type <code>S</code> to <code>T</code> succeeds if either <code>S</code> is a subtype of <code>T</code> or <code>T</code> is a subtype of <code>S</code>. This is to provide extra safety when doing type assertions … completely wild assertions can be very unsafe and you need to use <code>unknown</code> (or <code>any</code>) to be that unsafe.</p>
<h4 id="as-any-as-vs-as-unknown-as"><a class="header" href="#as-any-as-vs-as-unknown-as"><code>as any as</code> vs <code>as unknown as</code></a></h4>
<p>Both are <em>equally unsafe</em> as far as TypeScript is concerned. Use what makes you happy. Considerations: </p>
<ul>
<li>Linters prefer <code>unknown</code> (with <code>no-explicit-any</code> rule)</li>
<li><code>any</code> is less characters to type than <code>unknown</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertion-type-mapping"><a class="header" href="#assertion-type-mapping">Assertion: Type mapping</a></h1>
<p><code>&gt;tags:</code> [[Map]] [[Macro]]</p>
<pre><code class="language-typescript">type PREFIX&lt;Type&gt; = {
    [Property in keyof Type as `prefix_${string &amp;
        Property}`]: () =&gt; Type[Property];
};
type X = {
    a: string;
    b: number;
};
type Y = PREFIX&lt;X&gt;;
</code></pre>
<p>In this example, the type J<Type> uses a mapped type with a template literal to remap the keys of Type. It creates new properties with a “prefix_” added to each key, and their corresponding values are functions returning the original property values.
Type mapping is akin macro in Rust Programming.
It is worth noting that when using a type assertion, TypeScript will not execute excess property checking. Therefore, it is generally preferable to use a Type Declaration when the structure of the object is known in advance.</p>
<p>Add in the keyof keyword, and we can create new types based on the properties of another type.
<code>transform properties</code></p>
<p><code>&gt;tags:</code> [[Important]] [[map]]</p>
<pre><code class="language-typescript">interface IAbRequired {
  a: number;
  b: string;
}

// Create a variable ab that conforms to the IAbRequired interface
let ab: IAbRequired = {
  a: 1,
  b: &quot;test&quot;,
};

// Define a generic type WeakInterface that makes all properties of a given type optional
type WeakInterface&lt;T&gt; = {
  [K in keyof T]?: T[K];
};

// Create a variable allOptional of type WeakInterface&lt;IAbRequired&gt; and initialize it as an empty object
let allOptional: WeakInterface&lt;IAbRequired&gt; = {};

</code></pre>
<h2 id="partial-required-and-readonly-mapped-types"><a class="header" href="#partial-required-and-readonly-mapped-types">Partial, Required, and Readonly mapped types</a></h2>
<p>Using mapped types that transform properties is seen as so fundamental that their definitions have been included in the standard TypeScript type definitions.</p>
<p>The WeakType type alias that we created earlier is actually called Partial, which can be seen from the type definition in lib.es5.d.ts as follows:</p>
<pre><code class="language-typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = {
 [P in keyof T]?: T[P];
};
</code></pre>
<pre><code class="language-typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = {
    [P in keyof T]-?: T[P];
};
</code></pre>
<pre><code class="language-typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = {
 readonly [P in keyof T]: T[P];
};
</code></pre>
<h2 id="the-pick-mapped-type"><a class="header" href="#the-pick-mapped-type">The Pick mapped type</a></h2>
<p>The Pick mapped type is used to construct a type based on a subset of properties of another type.</p>
<pre><code class="language-typescript">interface IAbc {
  a: number;
  b: string;
  c: boolean;
}

// Define a new type PickAb using the Pick utility type to select only the &quot;a&quot; and &quot;b&quot; properties from the IAbc interface.
type PickAb = Pick&lt;IAbc, &quot;a&quot; | &quot;b&quot;&gt;;
let pickAbObject: PickAb = {
  a: 1,
  b: &quot;test&quot;,
};

console.log(pickAbObject);
</code></pre>
<h2 id="the-record-mapped-type"><a class="header" href="#the-record-mapped-type">The Record mapped type</a></h2>
<p>The final mapped type that we will explore is the Record mapped type, which is used to construct a type on the fly.</p>
<p>It is almost the opposite of the Pick mapped type and uses a <strong>provided list of properties</strong> as a string literal to define what properties the type must have.</p>
<p>Consider the following example:</p>
<pre><code class="language-typescript">type RecordedCd = Record&lt;&quot;c&quot; | &quot;d&quot;, number&gt;;

// Declare a variable of type RecordedCd and assign it an object with properties &quot;c&quot; and &quot;d&quot;
let recordedCdVar: RecordedCd = {
  c: 1,
  d: 1,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="types/freshness.html#freshness">Freshness</a></li>
<li><a href="types/freshness.html#allowing-extra-properties">Allowing extra properties</a></li>
<li><a href="types/freshness.html#use-case-react-state">Use Case: React</a></li>
</ul>
<h3 id="strict-object-literal-checking-freshness"><a class="header" href="#strict-object-literal-checking-freshness">Strict Object Literal Checking (Freshness)</a></h3>
<p>Strict object literal checking, sometimes referred to as “freshness”, is a feature in TypeScript that helps catch excess or misspelled properties that would otherwise go unnoticed in normal structural type checks.</p>
<p>When creating an object literal, the TypeScript compiler considers it “fresh.” If the object literal is assigned to a variable or passed as a parameter, TypeScript will throw an error if the object literal specifies properties that do not exist in the target type.</p>
<p>However, “freshness” disappears when an object literal is widened or a type assertion is used.</p>
<p>TypeScript provides a concept of <strong>Freshness</strong> (also called <em>strict object literal checking</em>) to make it easier to type check object literals that would otherwise be structurally type compatible.</p>
<p>Here are some examples to illustrate:</p>
<pre><code class="language-typescript">type X = { a: string };
type Y = { a: string; b: string };

let x: X;
x = { a: 'a', b: 'b' }; // Freshness check: Invalid assignment
var y: Y;
y = { a: 'a', bx: 'bx' }; // Freshness check: Invalid assignment

const fn = (x: X) =&gt; console.log(x.a);

fn(x);
fn(y); // Widening: No errors, structurally type compatible

fn({ a: 'a', bx: 'b' }); // Freshness check: Invalid argument

let x: { a: string } = { a: 'a' };
let y: { a: string; b: string } = { a: 'a', b: '' };
x = y; // Widening: No Freshness check
</code></pre>
<p>Structural typing is <em>extremely convenient</em>. Consider the following piece of code. This allows you to <em>very conveniently</em> <strong>upgrade your JavaScript to TypeScript</strong> while still preserving a level of type <strong>safety</strong>:</p>
<pre><code class="language-typescript">function logName(something: { name: string }) {
    console.log(something.name);
}

var person = { name: 'matt', job: 'being awesome' };
var animal = { name: 'cow', diet: 'vegan, but has milk of own species' };
var random = { note: `I don't have a name property` };

logName(person); // okay
logName(animal); // okay
logName(random); // Error: property `name` is missing
</code></pre>
<p>However, <em>structural</em> typing has a weakness in that it allows you to misleadingly think that something accepts more data than it actually does. This is demonstrated in the following code which TypeScript will error on as shown:</p>
<pre><code class="language-typescript">function logName(something: { name: string }) {
    console.log(something.name);
}

logName({ name: 'matt' }); // okay
logName({ name: 'matt', job: 'being awesome' }); // Error: object literals must only specify known properties. `job` is excessive here.
</code></pre>
<p>Note that this error <em>only happens on object literals</em>. Without this error one might look at the call <code>logName({ name: 'matt', job: 'being awesome' })</code> and think that <em>logName</em> would do something useful with <code>job</code> where as in reality it will completely ignore it.</p>
<p>Another big use case is with interfaces that have optional members, without such object literal checking, a typo would type check just fine. This is demonstrated below:</p>
<pre><code class="language-typescript">function logIfHasName(something: { name?: string }) {
    if (something.name) {
        console.log(something.name);
    }
}
var person = { name: 'matt', job: 'being awesome' };
var animal = { name: 'cow', diet: 'vegan, but has milk of own species' };

logIfHasName(person); // okay
logIfHasName(animal); // okay
logIfHasName({neme: 'I just misspelled name to neme'}); // Error: object literals must only specify known properties. `neme` is excessive here.
</code></pre>
<p>The reason why only object literals are type checked this way is because in this case additional properties <em>that aren’t actually used</em> is almost always a typo or a misunderstanding of the API.</p>
<h3 id="allowing-extra-properties"><a class="header" href="#allowing-extra-properties">Allowing extra properties</a></h3>
<p>A type can include an index signature to explicitly indicate that excess properties are permitted:</p>
<pre><code class="language-typescript">var x: { foo: number, [x: string]: unknown };
x = { foo: 1, baz: 2 };  // Ok, `baz` matched by index signature
</code></pre>
<h3 id="use-case-react-state"><a class="header" href="#use-case-react-state">Use Case: React State</a></h3>
<p><a href="https://facebook.github.io/react/">Facebook ReactJS</a> offers a nice use case for object freshness. Quite commonly in a component you call <code>setState</code> with only a few properties instead of passing in all the properties, i.e.: </p>
<pre><code class="language-typescript">// Assuming
interface State {
    foo: string;
    bar: string;
}

// You want to do: 
this.setState({foo: &quot;Hello&quot;}); // Error: missing property bar

// But because state contains both `foo` and `bar` TypeScript would force you to do: 
this.setState({foo: &quot;Hello&quot;, bar: this.state.bar});
</code></pre>
<p>Using the idea of freshness you would mark all the members as optional and <em>you still get to catch typos</em>!: </p>
<pre><code class="language-typescript">// Assuming
interface State {
    foo?: string;
    bar?: string;
}

// You want to do: 
this.setState({foo: &quot;Hello&quot;}); // Yay works fine!

// Because of freshness it's protected against typos as well!
this.setState({foos: &quot;Hello&quot;}); // Error: Objects may only specify known properties

// And still type checked
this.setState({foo: 123}); // Error: Cannot assign number to a string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference-in-typescript"><a class="header" href="#type-inference-in-typescript">Type Inference in TypeScript</a></h1>
<p>TypeScript can infer (and then check) the type of a variable based on a few simple rules. Because these rules
are simple you can train your brain to recognize safe / unsafe code (it happened for me and my teammates quite quickly).</p>
<blockquote>
<p>The types flowing is just how I imagine in my brain the flow of type information.</p>
</blockquote>
<h2 id="variable-definition"><a class="header" href="#variable-definition">Variable Definition</a></h2>
<p>Types of a variable are inferred by definition.</p>
<pre><code class="language-typescript">let foo = 123; // foo is a `number`
let bar = &quot;Hello&quot;; // bar is a `string`
foo = bar; // Error: cannot assign `string` to a `number`
</code></pre>
<p>This is an example of types flowing from right to left.</p>
<h2 id="function-return-types"><a class="header" href="#function-return-types">Function Return Types</a></h2>
<p>The return type is inferred by the return statements e.g. the following function is inferred to return a <code>number</code>.</p>
<pre><code class="language-typescript">function add(a: number, b: number) {
    return a + b;
}
</code></pre>
<p>This is an example of types flowing bottom out.</p>
<h2 id="assignment"><a class="header" href="#assignment">Assignment</a></h2>
<p>The type of function parameters / return values can also be inferred by assignment e.g. here we say that <code>foo</code> is an <code>Adder</code>, that makes <code>number</code> the type of <code>a</code> and <code>b</code>.</p>
<pre><code class="language-typescript">type Adder = (a: number, b: number) =&gt; number;
let foo: Adder = (a, b) =&gt; a + b;
</code></pre>
<p>This fact can be demonstrated by the below code which raises an error as you would hope:</p>
<pre><code class="language-typescript">type Adder = (a: number, b: number) =&gt; number;
let foo: Adder = (a, b) =&gt; {
    a = &quot;hello&quot;; // Error: cannot assign `string` to a `number`
    return a + b;
}
</code></pre>
<p>This is an example of types flowing from left to right.</p>
<p>The same <em>assignment</em> style type inference works if you create a function for a callback argument. After all an <code>argument -&gt; parameter</code>is just another form of variable assignment.</p>
<pre><code class="language-typescript">type Adder = (a: number, b: number) =&gt; number;
function iTakeAnAdder(adder: Adder) {
    return adder(1, 2);
}
iTakeAnAdder((a, b) =&gt; {
    // a = &quot;hello&quot;; // Would Error: cannot assign `string` to a `number`
    return a + b;
})
</code></pre>
<h3 id="more-advanced-inferences"><a class="header" href="#more-advanced-inferences">More Advanced Inferences</a></h3>
<p>When multiple expressions are used in type inference, TypeScript looks for the “best common types.” For instance:</p>
<pre><code class="language-typescript">let x = [1, 'x', 1, null]; // The type inferred is: (string | number | null)[]
</code></pre>
<p>If the compiler cannot find the best common types, it returns a union type. For example:</p>
<pre><code class="language-typescript">let x = [new RegExp('x'), new Date()]; // Type inferred is: (RegExp | Date)[]
</code></pre>
<p>TypeScript utilizes “contextual typing” based on the variable’s location to infer types. In the following example, the compiler knows that <code>e</code> is of type <code>MouseEvent</code> because of the <code>click</code> event type defined in the lib.d.ts file, which contains ambient declarations for various common JavaScript constructs and the DOM:</p>
<pre><code class="language-typescript">window.addEventListener('click', function (e) {}); // The inferred type of e is MouseEvent
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="structural-typing"><a class="header" href="#structural-typing">Structural Typing</a></h3>
<p>TypeScript is based on a structural type system. This means that the compatibility and equivalence of types are determined by the type’s actual structure or definition, rather than its name or place of declaration, as in nominative type systems like C# or C.</p>
<p>TypeScript’s structural type system was designed based on how JavaScript’s dynamic duck typing system works during runtime.</p>
<p>The following example is valid TypeScript code. As you can observe, “X” and “Y” have the same member “a,” even though they have different declaration names. The types are determined by their structures, and in this case, since the structures are the same, they are compatible and valid.</p>
<pre><code class="language-typescript">type X = {
    a: string;
};
type Y = {
    a: string;
};
const x: X = { a: 'a' };
const y: Y = x; // Valid
</code></pre>
<h2 id="structuring"><a class="header" href="#structuring">Structuring</a></h2>
<p>These simple rules also work in the presence of <strong>structuring</strong> (object literal creation). For example in the following case the type of <code>foo</code> is inferred to be <code>{a:number, b:number}</code></p>
<pre><code class="language-typescript">let foo = {
    a: 123,
    b: 456
};
// foo.a = &quot;hello&quot;; // Would Error: cannot assign `string` to a `number`
</code></pre>
<p>Similarly for arrays:</p>
<pre><code class="language-typescript">const bar = [1,2,3];
// bar[0] = &quot;hello&quot;; // Would error: cannot assign `string` to a `number`
</code></pre>
<p>And of course any nesting:</p>
<pre><code class="language-typescript">let foo = {
    bar: [1, 3, 4]
};
// foo.bar[0] = 'hello'; // Would error: cannot assign `string` to a `number`
</code></pre>
<h2 id="erased-structural-types"><a class="header" href="#erased-structural-types">Erased Structural Types</a></h2>
<p>In TypeScript, objects do not have to match a specific, exact type. For instance, if we create an object that fulfills an interface’s requirements, we can utilize that object in places where that interface is required, even if there was no explicit connection between them.
Example:</p>
<pre><code class="language-typescript">type NameProp1 = {
    prop1: string;
};

function log(x: NameProp1) {
    console.log(x.prop1);
}

const obj = {
    prop2: 123,
    prop1: 'Origin',
};

log(obj); // Valid
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Work with destructuring, akin objects:</p>
<pre><code class="language-typescript">let foo = {
    a: 123,
    b: 456
};
let {a} = foo;
// a = &quot;hello&quot;; // Would Error: cannot assign `string` to a `number`
</code></pre>
<p>and arrays:</p>
<pre><code class="language-typescript">const bar = [1, 2];
let [a, b] = bar;
// a = &quot;hello&quot;; // Would Error: cannot assign `string` to a `number`
</code></pre>
<p>And if the function parameter can be inferred, so can its destructured properties. For example here we destructure the argument into its <code>a</code>/<code>b</code> members.</p>
<pre><code class="language-typescript">type Adder = (numbers: { a: number, b: number }) =&gt; number;
function iTakeAnAdder(adder: Adder) {
    return adder({ a: 1, b: 2 });
}
iTakeAnAdder(({a, b}) =&gt; { // Types of `a` and `b` are inferred
    // a = &quot;hello&quot;; // Would Error: cannot assign `string` to a `number`
    return a + b;
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="narrowing"><a class="header" href="#narrowing">Narrowing</a></h2>
<p>TypeScript narrowing is the process of refining the type of a variable within a conditional block. This is useful when working with union types, where a variable can have more than one type.</p>
<p>Narrowing types can occur in different ways, including:</p>
<h4 id="conditions"><a class="header" href="#conditions">Conditions</a></h4>
<p>By using conditional statements, such as <code>if</code> or <code>switch</code>, TypeScript can <strong>narrow down the type based on the outcome of the condition.</strong> For example:</p>
<pre><code class="language-typescript">let x: number | undefined = 10;

if (x !== undefined) {
    x += 100; // The type is number, which had been narrowed by the condition
}
</code></pre>
<h4 id="throwing-or-returning"><a class="header" href="#throwing-or-returning">Throwing or returning</a></h4>
<p>Throwing an error or returning early from a branch can be used to help TypeScript narrow down a type. For example:</p>
<pre><code class="language-typescript">let x: number | undefined = 10;

if (x === undefined) {
    throw 'error';
}
x += 100;
</code></pre>
<p>Other ways to <strong>narrow down types</strong> in TypeScript include:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<strong><code>instanceof</code> operator</strong>: Used to check if an object is an instance of a specific class.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong><code>in</code> operator</strong>: Used to check if a property exists in an object.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong><code>typeof</code> operator</strong>: Used to check the type of a value at runtime.</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Built-in functions like <code>Array.isArray()</code></strong>: Used to check if a value is an array.</li>
</ul>
<p>TypeScript recognizes several ways to narrow the type:</p>
<h3 id="typeof-type-guards"><a class="header" href="#typeof-type-guards">typeof type guards</a></h3>
<p>The typeof type guard is one specific type guard in TypeScript that checks the type of a variable based on its built-in JavaScript type.</p>
<pre><code class="language-typescript">const fn = (x: number | string) =&gt; {
    if (typeof x === 'number') {
        return x + 1; // x is number
    }
    return -1;
};
</code></pre>
<h3 id="truthiness-narrowing"><a class="header" href="#truthiness-narrowing">Truthiness narrowing</a></h3>
<p>Truthiness narrowing in TypeScript works by checking whether a variable is truthy or falsy to narrow its type accordingly.</p>
<pre><code class="language-typescript">const toUpperCase = (name: string | null) =&gt; {
    if (name) {
        return name.toUpperCase();
    } else {
        return null;
    }
};
</code></pre>
<h3 id="equality-narrowing"><a class="header" href="#equality-narrowing">Equality narrowing</a></h3>
<p>Equality narrowing in TypeScript works by checking whether a variable is equal to a specific value or not, to narrow its type accordingly.</p>
<p>It is used in conjunction with <code>switch</code> statements and equality operators such as <code>===</code>, <code>!==</code>, <code>==</code>, and <code>!=</code> to narrow down types.</p>
<pre><code class="language-typescript">const checkStatus = (status: 'success' | 'error') =&gt; {
    switch (status) {
        case 'success':
            return true;
        case 'error':
            return null;
    }
};
</code></pre>
<h3 id="in-operator-narrowing"><a class="header" href="#in-operator-narrowing">In Operator narrowing</a></h3>
<p>The <code>in</code> Operator narrowing in TypeScript is a way to narrow the type of a variable based on whether a property exists within the variable’s type.</p>
<pre><code class="language-typescript">type Dog = {
    name: string;
    breed: string;
};

type Cat = {
    name: string;
    likesCream: boolean;
};

const getAnimalType = (pet: Dog | Cat) =&gt; {
    if ('breed' in pet) {
        return 'dog';
    } else {
        return 'cat';
    }
};
</code></pre>
<h3 id="instanceof-narrowing"><a class="header" href="#instanceof-narrowing">instanceof narrowing</a></h3>
<p>The <code>instanceof</code> operator narrowing in TypeScript is a way to narrow the type of a variable based on its constructor function, by checking if an object is an instance of a certain class or interface.</p>
<pre><code class="language-typescript">class Square {
    constructor(public width: number) {}
}
class Rectangle {
    constructor(
        public width: number,
        public height: number
    ) {}
}
function area(shape: Square | Rectangle) {
    if (shape instanceof Square) {
        return shape.width - shape.width;
    } else {
        return shape.width - shape.height;
    }
}
const square = new Square(5);
const rectangle = new Rectangle(5, 10);
console.log(area(square)); // 25
console.log(area(rectangle)); // 50
</code></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>TypeScript narrowing using assignments is a way to narrow the type of a variable based on the value assigned to it. When a variable is assigned a value, TypeScript infers its type based on the assigned value, and it narrows the type of the variable to match the inferred type.</p>
<p><code>&gt;tags:</code> #toFixed [[Math]] #toUpperCase</p>
<pre><code class="language-typescript">let value: string | number;
value = 'hello';
if (typeof value === 'string') {
    console.log(value.toUpperCase());
}
value = 42;
if (typeof value === 'number') {
    console.log(value.toFixed(2));
}
</code></pre>
<h2 id="another-form-of-widening"><a class="header" href="#another-form-of-widening">Another form of widening</a></h2>
<p><a href="types/narrowing/./widening.html">Ref.to widening</a> to findings <code>const x= 'x' </code> is a narrow type in spite of <code>let</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-guard"><a class="header" href="#type-guard">Type Guard</a></h1>
<p>We have already seen how <a href="types/narrowing/./literal-types.md.html">literal types</a> help change and narrow down types (particularly in the case of unions). Type guards are just another form of type inference for a variable in a block.</p>
<p>A type guard is an expression that performs a check on our type and then <strong>guarantees that type within its scope</strong>. Let’s rewrite our previous function with a type guard as follows:</p>
<pre><code class="language-typescript">// Declare a function called addWithTypeGuard that takes in two parameters, arg1 and arg2, with types of string or number
function addWithTypeGuard(
  arg1: string | number,
  arg2: string | number
) {
  // Check if arg1 is a string
  if (typeof arg1 === &quot;string&quot;) {function addWithTypeGuard(
  arg1: string | number,
  arg2: string | number
) {
  // Check if arg1 is a string
  if (typeof arg1 === &quot;string&quot;) {
    // If it is, log that it is a string and return the sum of arg1 and arg2 as a string
    console.log(`arg1 is of type string`);
    return arg1 + arg2;
  }
  // Check if both arg1 and arg2 are numbers
  if (typeof arg1 === &quot;number&quot; &amp;&amp; typeof arg2 === &quot;number&quot;) {
    // If they are, log that they are numbers and return the sum of arg1 and arg2 as a number
    console.log(`arg1 and arg2 are numbers`);
    return arg1 + arg2;
  }
  // If arg1 and arg2 are not both numbers, log that they are being treated as strings and return their concatenation as a string
  console.log(`default return treat both as strings`)
  return arg1.toString() + arg2.toString();
}

</code></pre>
<p><code>&gt; Output:</code> Succeeded</p>
<ul>
<li><a href="types/narrowing/guard.html#type-guard">Type Guard</a></li>
<li><a href="types/narrowing/guard.html#user-defined-type-guards">User Defined Type Guards</a></li>
</ul>
<p>Type Guards allow you to narrow down the type of an object within a conditional block. </p>
<h3 id="typeof"><a class="header" href="#typeof">typeof</a></h3>
<p>[[typeof]]
TypeScript is aware of the usage of the JavaScript <code>instanceof</code> and <code>typeof</code> operators. If you use these in a conditional block, TypeScript will understand the type of the variable to be different within that conditional block. Here is a quick example where TypeScript realizes that a particular function does not exist on <code>string</code> and points out what was probably a user typo:</p>
<pre><code class="language-typescript">function doSomething(x: number | string) {
    if (typeof x === 'string') { // Within the block TypeScript knows that `x` must be a string
        console.log(x.subtr(1)); // Error, 'subtr' does not exist on `string`
        console.log(x.substr(1)); // OK
    }
    x.substr(1); // Error: There is no guarantee that `x` is a `string`
}
</code></pre>
<h3 id="instanceof"><a class="header" href="#instanceof">instanceof</a></h3>
<p>[[instanceof]]
Here is an example with a class and <code>instanceof</code>:</p>
<pre><code class="language-typescript">class Foo {
    foo = 123;
    common = '123';
}

class Bar {
    bar = 123;
    common = '123';
}

function doStuff(arg: Foo | Bar) {
    if (arg instanceof Foo) {
        console.log(arg.foo); // OK
        console.log(arg.bar); // Error!
    }
    if (arg instanceof Bar) {
        console.log(arg.foo); // Error!
        console.log(arg.bar); // OK
    }

    console.log(arg.common); // OK
    console.log(arg.foo); // Error!
    console.log(arg.bar); // Error!
}

doStuff(new Foo());
doStuff(new Bar());
</code></pre>
<p>TypeScript even understands <code>else</code> so when an <code>if</code> narrows out one type it knows that within the else <em>it’s definitely not that type</em>. Here is an example:</p>
<pre><code class="language-typescript">class Foo {
    foo = 123;
}

class Bar {
    bar = 123;
}

function doStuff(arg: Foo | Bar) {
    if (arg instanceof Foo) {
        console.log(arg.foo); // OK
        console.log(arg.bar); // Error!
    }
    else {  // MUST BE Bar!
        console.log(arg.foo); // Error!
        console.log(arg.bar); // OK
    }
}

doStuff(new Foo());
doStuff(new Bar());
</code></pre>
<h3 id="in"><a class="header" href="#in">in</a></h3>
<p>[[in]]
The <code>in</code> operator does a safe check for the existence of a property on an object and can be used as a type guard. E.g. </p>
<pre><code class="language-typescript">interface A {
  x: number;
}
interface B {
  y: string;
}

function doStuff(q: A | B) {
  if ('x' in q) {
    // q: A
  }
  else {
    // q: B
  }
}
</code></pre>
<h2 id="warnings"><a class="header" href="#warnings">Warnings</a></h2>
<h3 id="be-careful-around-parameters"><a class="header" href="#be-careful-around-parameters">Be careful around parameters</a></h3>
<p>Types do not flow into the function parameters if it cannot be inferred from an assignment. For example in the following case the compiler does not know the type of <code>foo</code> so it cannot infer the type of <code>a</code> or <code>b</code>.</p>
<pre><code class="language-typescript">const foo = (a,b) =&gt; { /* do something */ };
</code></pre>
<p>However, if <code>foo</code> was typed the function parameters type can be inferred (<code>a</code>,<code>b</code> are both inferred to be of type <code>number</code> in the example below).</p>
<pre><code class="language-typescript">type TwoNumberFunction = (a: number, b: number) =&gt; void;
const foo: TwoNumberFunction = (a, b) =&gt; { /* do something */ };
</code></pre>
<h3 id="be-careful-around-return"><a class="header" href="#be-careful-around-return">Be careful around return</a></h3>
<p>Although TypeScript can generally infer the return type of a function, it might not be what you expect. For example here function <code>foo</code> has a return type of <code>any</code>.</p>
<pre><code class="language-typescript">function foo(a: number, b: number) {
    return a + addOne(b);
}
// Some external function in a library someone wrote in JavaScript
function addOne(c) {
    return c + 1;
}
</code></pre>
<p>This is because the return type is impacted by the poor type definition for <code>addOne</code> (<code>c</code> is <code>any</code> so the return of <code>addOne</code> is <code>any</code> so the return of <code>foo</code> is <code>any</code>).</p>
<blockquote>
<p>I find it simplest to always be explicit about function returns. After all, these annotations are a theorem and the function body is the proof.</p>
</blockquote>
<p>There are other cases that one can imagine, but the good news is that there is a compiler flag that can help catch such bugs.</p>
<h2 id="noimplicitany-2"><a class="header" href="#noimplicitany-2"><code>noImplicitAny</code></a></h2>
<p>The flag <code>noImplicitAny</code> instructs the compiler to raise an error if it cannot infer the type of a variable (and therefore can only have it as an <em>implicit</em> <code>any</code> type). You can then</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Either say that <em>yes I want it to be of type <code>any</code></em> by <em>explicitly</em> adding an <code>: any</code> type annotation</li>
<li><input disabled="" type="checkbox" checked=""/>
Help the compiler out by adding a few more <em>correct</em> annotations.</li>
</ul>
<h3 id="user-defined-type-js-guards"><a class="header" href="#user-defined-type-js-guards">User Defined Type JS Guards</a></h3>
<p>In cases where TypeScript is unable to determine a type, it is possible to write a helper function known as a “user-defined type guard.” In the following example, we will utilize a Type Predicate to narrow down the type after applying certain filtering:</p>
<pre><code class="language-typescript">const data = ['a', null, 'c', 'd', null, 'f'];

const r1 = data.filter(x =&gt; x != null); // The type is (string | null)[], TypeScript was not able to infer the type properly

const isValid = (item: string | null): item is string =&gt; item !== null; // Custom type guard

const r2 = data.filter(isValid); // The type is fine now string[], by using the predicate type guard we were able to narrow the type
</code></pre>
<p>JavaScript doesn’t have very rich runtime introspection support built in. When you are using just plain JavaScript Objects (using structural typing to your advantage), you do not even have access to <code>instanceof</code> or <code>typeof</code>. For these cases you can create <em>User Defined Type Guard functions</em>. These are just functions that return <code>someArgumentName is SomeType</code>. Here is an example:</p>
<pre><code class="language-typescript">/**
 * Just some interfaces
 */
interface Foo {
    foo: number;
    common: string;
}

interface Bar {
    bar: number;
    common: string;
}

/**
 * User Defined Type Guard!
 */
function isFoo(arg: any): arg is Foo {
    return arg.foo !== undefined;
}

/**
 * Sample usage of the User Defined Type Guard
 */
function doStuff(arg: Foo | Bar) {
    if (isFoo(arg)) {
        console.log(arg.foo); // OK
        console.log(arg.bar); // Error!
    }
    else {
        console.log(arg.foo); // Error!
        console.log(arg.bar); // OK
    }
}

doStuff({ foo: 123, common: '123' });
doStuff({ bar: 123, common: '123' });
</code></pre>
<h3 id="type-guards-and-callbacks"><a class="header" href="#type-guards-and-callbacks">Type Guards and callbacks</a></h3>
<p>TypeScript doesn’t assume type guards remain active in callbacks as making this assumption is dangerous. e.g. </p>
<pre><code class="language-js">// Example Setup
declare var foo:{bar?: {baz: string}};
function immediate(callback: ()=&gt;void) {
  callback();
}


// Type Guard
if (foo.bar) {
  console.log(foo.bar.baz); // Okay
  functionDoingSomeStuff(() =&gt; {
    console.log(foo.bar.baz); // TS error: Object is possibly 'undefined'&quot;
  });
}
</code></pre>
<p>The fix is as easy as storing the inferred safe value in a local variable, automatically ensuring it doesn’t get changed externally, and TypeScript can easily understand that: </p>
<pre><code class="language-js">// Type Guard
if (foo.bar) {
  console.log(foo.bar.baz); // Okay
  const bar = foo.bar;
  functionDoingSomeStuff(() =&gt; {
    console.log(bar.baz); // Okay
  });
}
</code></pre>
<h2 id="control-flow-analysis"><a class="header" href="#control-flow-analysis">Control Flow Analysis</a></h2>
<p>Control Flow Analysis in TypeScript is a way to statically analyze the code flow to infer the types of variables, allowing the compiler to narrow the types of those variables as needed, based on the results of the analysis.</p>
<p>Prior to TypeScript 4.4, code flow analysis would only be applied to code within an if statement, but from TypeScript 4.4, it can also be applied to conditional expressions and discriminant property accesses indirectly referenced through const variables.</p>
<p>For example:</p>
<pre><code class="language-typescript">const f1 = (x: unknown) =&gt; {
    const isString = typeof x === 'string';
    if (isString) {
        x.length;
    }
};

const f2 = (
    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }
) =&gt; {
    const isFoo = obj.kind === 'foo';
    if (isFoo) {
        obj.foo;
    } else {
        obj.bar;
    }
};
</code></pre>
<p>Some examples where narrowing does not occur:</p>
<!-- skip -->
<pre><code class="language-typescript">const f1 = (x: unknown) =&gt; {
    let isString = typeof x === 'string';
    if (isString) {
        x.length; // Error, no narrowing because isString it is not const
    }
};

const f6 = (
    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }
) =&gt; {
    const isFoo = obj.kind === 'foo';
    obj = obj;
    if (isFoo) {
        obj.foo; // Error, no narrowing because obj is assigned in function body
    }
};
</code></pre>
<p>Notes: Up to five levels of indirection are analyzed in conditional expressions.</p>
<h2 id="type-predicates"><a class="header" href="#type-predicates">Type Predicates</a></h2>
<p>Type Predicates in TypeScript are functions that return a boolean value and are used to narrow the type of a variable to a more specific type.</p>
<pre><code class="language-typescript">const isString = (value: unknown): value is string =&gt; typeof value === 'string';

const foo = (bar: unknown) =&gt; {
    if (isString(bar)) {
        console.log(bar.toUpperCase());
    } else {
        console.log('not a string');
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertion-functions"><a class="header" href="#assertion-functions">Assertion Functions</a></h2>
<p>In TypeScript, assertion functions are functions that indicate the verification of a specific condition based on their return value. In their simplest form, an assert function examines a provided predicate and raises an error when the predicate evaluates to false.</p>
<pre><code class="language-typescript">function isNumber(value: unknown): asserts value is number {
    if (typeof value !== 'number') {
        throw new Error('Not a number');
    }
}
</code></pre>
<p>Or can be declared as function expression:</p>
<pre><code class="language-typescript">type AssertIsNumber = (value: unknown) =&gt; asserts value is number;
const isNumber: AssertIsNumber = value =&gt; {
    if (typeof value !== 'number') {
        throw new Error('Not a number');
    }
};
</code></pre>
<p>Assertion functions share similarities with type guards. <strong>Type guards were initially introduced to perform runtime checks</strong> and ensure the type of a value within a specific scope.
Specifically, a type guard is a function that <strong>evaluates a type predicate and returns a boolean value indicating whether the predicate is true or false</strong>. </p>
<p>This differs slightly from <strong>assertion functions,where the intention is to throw an error</strong> rather than returning false when the predicate is not satisfied.</p>
<p>Example of type guard:</p>
<pre><code class="language-typescript">const isNumber = (value: unknown): value is number =&gt; typeof value === 'number';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="type-widening"><a class="header" href="#type-widening">Type Widening</a></h3>
<p>Type widening is the process in which TypeScript assigns a type to a variable initialized when no type annotation was provided. It allows narrow to wider types but not vice versa.
In the following example:</p>
<p><code>&gt;tags:</code> [[Error_TS2322]] [[Error_Assignable]]</p>
<!-- skip -->
<pre><code class="language-typescript">let x = 'x'; // TypeScript infers as string, a wide type
let y: 'y' | 'x' = 'y'; // y types is a union of literal types
y = x; // Invalid Type 'string' is not assignable to type '&quot;x&quot; | &quot;y&quot;'.
</code></pre>
<p>TypeScript assigns <code>string</code> to <code>x</code> based on the single value provided during initialization (<code>x</code>), this is an example of widening.</p>
<p>TypeScript provides ways to have control of the widening process, for instance using “const”.</p>
<p><code>&gt;tags:</code> [[Const]]</p>
<h3 id="const-1"><a class="header" href="#const-1">Const</a></h3>
<p>Using the <code>const</code> keyword when declaring a variable results in a narrower type inference in TypeScript.</p>
<p>For example:</p>
<pre><code class="language-typescript">const x = 'x'; // TypeScript infers the type of x as 'x', a narrower type
let y: 'y' | 'x' = 'y';
y = x; // Valid: The type of x is inferred as 'x'
</code></pre>
<p>By using <code>const</code> to declare the variable x, its type is narrowed to the specific literal value ‘x’. Since the type of x is narrowed, it can be assigned to the variable y without any error.
The reason the type can be inferred is because <code>const</code> variables cannot be reassigned, so their type can be narrowed down to a specific literal type, in this case, the literal type ‘x’.</p>
<h4 id="const-modifier-on-type-parameters"><a class="header" href="#const-modifier-on-type-parameters">Const Modifier on Type Parameters</a></h4>
<p>From version 5.0 of TypeScript, it is possible to specify the <code>const</code> attribute on a generic type parameter. This allows for inferring the most precise type possible. Let’s see an example without using <code>const</code>:</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(value: T) {
    // No const here
    return value;
}
const values = identity({ a: 'a', b: 'b' }); // Type infered is: { a: string; b: string; }
</code></pre>
<p>As you can see, the properties <code>a</code> and <code>b</code> are inferred with a type of <code>string</code>   .</p>
<p>Now, let’s see the difference with the <code>const</code> version:</p>
<pre><code class="language-typescript">function identity&lt;const T&gt;(value: T) {
    // Using const modifier on type parameters
    return value;
}
const values = identity({ a: 'a', b: 'b' }); // Type infered is: { a: &quot;a&quot;; b: &quot;b&quot;; }
</code></pre>
<p>Now we can see that the properties <code>a</code> and <code>b</code> are inferred as <code>const</code>, so <code>a</code> and <code>b</code> are treated as string literals rather than just <code>string</code> types.</p>
<h4 id="const-assertion"><a class="header" href="#const-assertion">Const assertion</a></h4>
<p>This feature allows you to declare a variable with a more precise literal type based on its initialization value, signifying to the compiler that the value should be treated as an immutable literal. Here are a few examples:</p>
<p>On a single property:</p>
<pre><code class="language-typescript">const v = {
    x: 3 as const,
};
v.x = 3;
</code></pre>
<p>On an entire object:</p>
<pre><code class="language-typescript">const v = {
    x: 1,
    y: 2,
} as const;
</code></pre>
<p>This can be particularly useful when defining the type for a tuple:</p>
<pre><code class="language-typescript">const x = [1, 2, 3]; // number[]
const y = [1, 2, 3] as const; // Tuple of readonly [1, 2, 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literals are <em>exact</em> values that are JavaScript primitives. </p>
<p>A Literal Type is a single element set from a collective type, it defines a very exact value that is a JavaScript primitive.</p>
<p>Literal Types in TypeScript are numbers, strings, and booleans.</p>
<p>Example of literals:</p>
<pre><code class="language-typescript">const a = 'a'; // String literal type
const b = 1; // Numeric literal type
const c = true; // Boolean literal type
</code></pre>
<p>String, Numeric, and Boolean Literal Types are used in the union, type guard, and type aliases.
In the following example you can see a type alias union, <code>O</code> can be the only value specified and not any other string:</p>
<pre><code class="language-typescript">type O = 'a' | 'b' | 'c';
</code></pre>
<h3 id="template-literal-types"><a class="header" href="#template-literal-types">Template Literal Types</a></h3>
<p>Template Literal Types allow to manipulate string value at type level and generate new string types based on existing ones. They are useful to create more expressive and precise types from string-based operations.</p>
<pre><code class="language-typescript">type Department = 'engineering' | 'hr';
type Language = 'english' | 'spanish';
type Id = `${Department}-${Language}-id`; // &quot;engineering-english-id&quot; | &quot;engineering-spanish-id&quot; | &quot;hr-english-id&quot; | &quot;hr-spanish-id&quot;
</code></pre>
<h3 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h3>
<p>You can use a string literal as a type. For example:</p>
<pre><code class="language-typescript">let foo: 'Hello';
</code></pre>
<p>Here we have created a variable called <code>foo</code> that <em>will only allow the literal value <code>'Hello'</code> to be assigned to it</em>. This is demonstrated below:</p>
<pre><code class="language-typescript">let foo: 'Hello';
foo = 'Bar'; // Error: &quot;Bar&quot; is not assignable to type &quot;Hello&quot;
</code></pre>
<p>They are not very useful on their own but can be combined in a type union to create a powerful (and useful) abstraction e.g.:</p>
<pre><code class="language-typescript">type CardinalDirection =
    | &quot;North&quot;
    | &quot;East&quot;
    | &quot;South&quot;
    | &quot;West&quot;;

function move(distance: number, direction: CardinalDirection) {
    // ...
}

move(1,&quot;North&quot;); // Okay
move(1,&quot;Nurth&quot;); // Error!
</code></pre>
<h3 id="other-literal-types"><a class="header" href="#other-literal-types">Other literal types</a></h3>
<p>TypeScript also supports <code>boolean</code> and <code>number</code> literal types, e.g.: </p>
<pre><code class="language-typescript">type OneToFive = 1 | 2 | 3 | 4 | 5;
type Bools = true | false;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="type-inference-1"><a class="header" href="#type-inference-1">Type Inference</a></h3>
<p>TypeScript can infer types when no annotation is provided during:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Variable initialization.</li>
<li><input disabled="" type="checkbox" checked=""/>
Member initialization.</li>
<li><input disabled="" type="checkbox" checked=""/>
Setting defaults for parameters.</li>
<li><input disabled="" type="checkbox" checked=""/>
Function return type.</li>
</ul>
<p>For example:</p>
<pre><code class="language-typescript">let x = 'x'; // The type inferred is string
</code></pre>
<p>The TypeScript compiler analyzes the value or expression and determines its type based on the available information.</p>
<p>Quite commonly you get an error like <code>Type string is not assignable to type &quot;foo&quot;</code>. The following example demonstrates this.</p>
<pre><code class="language-typescript">function iTakeFoo(foo: 'foo') { }
const test = {
  someProp: 'foo'
};
iTakeFoo(test.someProp); // Error: Argument of type string is not assignable to parameter of type 'foo'
</code></pre>
<p>This is because <code>test</code> is inferred to be of type <code>{someProp: string}</code>. The fix here is to use a simple type assertion to tell TypeScript the literal you want it to infer as shown below: </p>
<pre><code class="language-typescript">function iTakeFoo(foo: 'foo') { }
const test = {
  someProp: 'foo' as 'foo'
};
iTakeFoo(test.someProp); // Okay!
</code></pre>
<p>or use a type annotation that helps TypeScript infer the correct thing at the point of declaration: </p>
<pre><code class="language-typescript">function iTakeFoo(foo: 'foo') { }
type Test = {
  someProp: 'foo',
}
const test: Test = { // Annotate - inferred someProp is always === 'foo'
  someProp: 'foo' 
}; 
iTakeFoo(test.someProp); // Okay!
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h3>
<p>Valid use cases for string literal types are string based enum.</p>
<h2 id="literal-inference"><a class="header" href="#literal-inference">Literal Inference</a></h2>
<p>Literal Inference is a feature in TypeScript that allows the type of a variable or parameter to be inferred based on its value.</p>
<p>In the following example we can see that TypeScript considers <code>x</code> a literal type as the value cannot be changed any time later, when instead <code>y</code> is inferred as string as it can be modified any time later.</p>
<pre><code class="language-typescript">const x = 'x'; // Literal type of 'x', because this value cannot be changed
let y = 'y'; // Type string, as we can change this value
</code></pre>
<p>In the following example we can see that <code>o.x</code> was inferred as a <code>string</code> (and not a literal of <code>a</code>) as TypeScript considers that the value can be changed any time later.</p>
<p><code>&gt;tags:</code> [[Error_TS2345]] [[Error_assignable]] : Argument of type ‘string’ is not assignable to parameter of type ‘X’</p>
<p>As you can see the code throws an error when passing o.x to fn as X is a narrower type.</p>
<p>We can solve this issue by using type assertion using const or the X type:</p>
<pre><code class="language-typescript">let oo = {
    x: 'a' as X,// as const,
};
console.log(fn(oo.x));
</code></pre>
<!-- skip -->
<pre><code class="language-typescript">type X = 'a' | 'b';

let o = {
    x: 'a', // This is a wider string
};

const fn = (x: X) =&gt; `${x}-foo`;

console.log(fn(o.x)); // Argument of type 'string' is not assignable to parameter of type 'X'
</code></pre>
<p>As you can see the code throws an error when passing <code>o.x</code> to <code>fn</code> as X is a narrower type.</p>
<p>We can solve this issue by using type assertion using <code>const</code> or the <code>X</code> type:</p>
<!-- skip -->
<pre><code class="language-typescript">let o = {
    x: 'a' as const,
};
</code></pre>
<p>or:</p>
<!-- skip -->
<pre><code class="language-typescript">let o = {
    x: 'a' as X,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-based-enums"><a class="header" href="#string-based-enums">String based enums</a></h1>
<p><a href="types/../enums.html">TypeScript enums are number based</a>. You can use string literals with union types to mock a string based enum as we did in the <code>CardinalDirection</code> example above. You can even generate a <code>Key:Value</code> structure using the following function: </p>
<p>Generate the literal type union using <code>keyof typeof</code>. Here is a complete example:</p>
<p><code>&gt;tags:</code> #Important [[Inference]] [[Literal]] [[Type]] [[Enum]]</p>
<pre><code class="language-typescript">/** Utility function to create a K:V from a list of strings */
function strEnum&lt;T extends string&gt;(o: Array&lt;T&gt;): {[K in T]: K} {
  return o.reduce((res, key) =&gt; {
    res[key] = key;
    return res;
  }, Object.create(null));
}

/**
  * Sample create a string enum
  */

/** Create a K:V */
const Direction = strEnum([
  'North',
  'South',
  'East',
  'West'
])
/** Create a Type */
type Direction = keyof typeof Direction;

/** 
  * Sample using a string enum
  */
let sample: Direction;

sample = Direction.North; // Okay
sample = 'North'; // Okay
sample = 'AnythingElse'; // ERROR!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="literal-type-guard"><a class="header" href="#literal-type-guard">Literal Type Guard</a></h3>
<p>You can use <code>===</code> / <code>==</code> / <code>!==</code> / <code>!=</code> to distinguish between literal values</p>
<pre><code class="language-typescript">type TriState = 'yes' | 'no' | 'unknown';

function logOutState(state:TriState) {
  if (state == 'yes') {
    console.log('User selected yes');
  } else if (state == 'no') {
    console.log('User selected no');
  } else {
    console.log('User has not made a selection yet');
  }
}
</code></pre>
<p>This even works when you have literal types in a union. You can check the value of a shared property name to discriminate the union e.g. </p>
<pre><code class="language-typescript">type Foo = {
  kind: 'foo', // Literal type 
  foo: number
}
type Bar = {
  kind: 'bar', // Literal type 
  bar: number
}

function doStuff(arg: Foo | Bar) {
    if (arg.kind === 'foo') {
        console.log(arg.foo); // OK
        console.log(arg.bar); // Error!
    }
    else {  // MUST BE Bar!
        console.log(arg.foo); // Error!
        console.log(arg.bar); // OK
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utility-types"><a class="header" href="#utility-types">Utility Types</a></h1>
<p>Several built-in utility types can be used to manipulate types, below a list of the most common used:</p>
<h1 id="unwrap"><a class="header" href="#unwrap">Unwrap</a></h1>
<h2 id="awaitedt"><a class="header" href="#awaitedt">Awaited&lt;T&gt;</a></h2>
<p>Constructs a type recursively unwrap Promises.</p>
<pre><code class="language-typescript">type A = Awaited&lt;Promise&lt;string&gt;&gt;; // string
</code></pre>
<h1 id="type-1"><a class="header" href="#type-1">Type</a></h1>
<h2 id="partialt"><a class="header" href="#partialt">Partial&lt;T&gt;</a></h2>
<p>Constructs a type with all properties of T set to optional.</p>
<pre><code class="language-typescript">type Person = {
    name: string;
    age: number;
};

type A = Partial&lt;Person&gt;; // { name?: string | undefined; age?: number | undefined; }
</code></pre>
<h2 id="requiredt"><a class="header" href="#requiredt">Required&lt;T&gt;</a></h2>
<p>Constructs a type with all properties of T set to required.</p>
<pre><code class="language-typescript">type Person = {
    name?: string;
    age?: number;
};

type A = Required&lt;Person&gt;; // { name: string; age: number; }
</code></pre>
<h2 id="readonlyt"><a class="header" href="#readonlyt">Readonly&lt;T&gt;</a></h2>
<p>Constructs a type with all properties of T set to readonly.</p>
<!-- skip -->
<pre><code class="language-typescript">type Person = {
    name: string;
    age: number;
};

type A = Readonly&lt;Person&gt;;

const a: A = { name: 'Simon', age: 17 };
a.name = 'John'; // Invalid
</code></pre>
<h2 id="recordk-t"><a class="header" href="#recordk-t">Record&lt;K, T&gt;</a></h2>
<p>Constructs a type with a set of properties K of type T.</p>
<pre><code class="language-typescript">type Product = {
    name: string;
    price: number;
};

const products: Record&lt;string, Product&gt; = {
    apple: { name: 'Apple', price: 0.5 },
    banana: { name: 'Banana', price: 0.25 },
};

console.log(products.apple); // { name: 'Apple', price: 0.5 }
</code></pre>
<h2 id="pickt-k"><a class="header" href="#pickt-k">Pick&lt;T, K&gt;</a></h2>
<p>Constructs a type by picking the specified properties K from T.</p>
<pre><code class="language-typescript">type Product = {
    name: string;
    price: number;
};

type Price = Pick&lt;Product, 'price'&gt;; // { price: number; }
</code></pre>
<h2 id="omitt-k"><a class="header" href="#omitt-k">Omit&lt;T, K&gt;</a></h2>
<p>Constructs a type by omitting the specified properties K from T.</p>
<pre><code class="language-typescript">type Product = {
    name: string;
    price: number;
};

type Name = Omit&lt;Product, 'price'&gt;; // { name: string; }
</code></pre>
<h2 id="excludet-u"><a class="header" href="#excludet-u">Exclude&lt;T, U&gt;</a></h2>
<p>Constructs a type by excluding all values of type U from T.</p>
<pre><code class="language-typescript">type Union = 'a' | 'b' | 'c';
type MyType = Exclude&lt;Union, 'a' | 'c'&gt;; // b
</code></pre>
<h2 id="extractt-u"><a class="header" href="#extractt-u">Extract&lt;T, U&gt;</a></h2>
<p>Constructs a type by extracting all values of type U from T.</p>
<pre><code class="language-typescript">type Union = 'a' | 'b' | 'c';
type MyType = Extract&lt;Union, 'a' | 'c'&gt;; // a | c
</code></pre>
<h1 id="empty"><a class="header" href="#empty">Empty</a></h1>
<h2 id="nonnullablet"><a class="header" href="#nonnullablet">NonNullable&lt;T&gt;</a></h2>
<p>Constructs a type by excluding null and undefined from T.</p>
<pre><code class="language-typescript">type Union = 'a' | null | undefined | 'b';
type MyType = NonNullable&lt;Union&gt;; // 'a' | 'b'
</code></pre>
<h1 id="class-1"><a class="header" href="#class-1">Class</a></h1>
<h2 id="instancetypet"><a class="header" href="#instancetypet">InstanceType&lt;T&gt;</a></h2>
<p>Extracts the instance type of a class type T.</p>
<pre><code class="language-typescript">class Person {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    sayHello() {
        console.log(`Hello, my name is ${this.name}!`);
    }
}

type PersonInstance = InstanceType&lt;typeof Person&gt;;

const person: PersonInstance = new Person('John');

person.sayHello(); // Hello, my name is John!
</code></pre>
<h1 id="function"><a class="header" href="#function">Function</a></h1>
<h2 id="parameterst"><a class="header" href="#parameterst">Parameters&lt;T&gt;</a></h2>
<p>Extracts the parameter types of a function type T.</p>
<pre><code class="language-typescript">type Func = (a: string, b: number) =&gt; void;
type MyType = Parameters&lt;Func&gt;; // [a: string, b: number]
</code></pre>
<h2 id="constructorparameterst"><a class="header" href="#constructorparameterst">ConstructorParameters&lt;T&gt;</a></h2>
<p>Extracts the parameter types of a constructor function type T.</p>
<pre><code class="language-typescript">class Person {
    constructor(
        public name: string,
        public age: number
    ) {}
}
type PersonConstructorParams = ConstructorParameters&lt;typeof Person&gt;; // [name: string, age: number]
const params: PersonConstructorParams = ['John', 30];
const person = new Person(...params);
console.log(person); // Person { name: 'John', age: 30 }
</code></pre>
<h2 id="returntypet"><a class="header" href="#returntypet">ReturnType&lt;T&gt;</a></h2>
<p>Extracts the return type of a function type T.</p>
<pre><code class="language-typescript">type Func = (name: string) =&gt; number;
type MyType = ReturnType&lt;Func&gt;; // number
</code></pre>
<h2 id="thistypet"><a class="header" href="#thistypet">ThisType&lt;T&gt;</a></h2>
<p>Servers as a market for a contextual <code>this</code> type.</p>
<!-- skip -->
<pre><code class="language-typescript">type Logger = {
    log: (error: string) =&gt; void;
};

let helperFunctions: { [name: string]: Function } &amp; ThisType&lt;Logger&gt; = {
    hello: function () {
        this.log('some error'); // Valid as &quot;log&quot; is a part of &quot;this&quot;.
        this.update(); // Invalid
    },
};
</code></pre>
<h2 id="thisparametertypet"><a class="header" href="#thisparametertypet">ThisParameterType&lt;T&gt;</a></h2>
<p>Extracts the type of ‘this’ parameter from a function type T.</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    greet(this: Person): void;
}
type PersonThisType = ThisParameterType&lt;Person['greet']&gt;; // Person
</code></pre>
<h2 id="omitthisparametert"><a class="header" href="#omitthisparametert">OmitThisParameter&lt;T&gt;</a></h2>
<p>Removes the ‘this’ parameter from a function type T.</p>
<pre><code class="language-typescript">function capitalize(this: String) {
    return this[0].toUpperCase + this.substring(1).toLowerCase();
}

type CapitalizeType = OmitThisParameter&lt;typeof capitalize&gt;; // () =&gt; string
</code></pre>
<h1 id="string-1"><a class="header" href="#string-1">String</a></h1>
<h2 id="uppercaset"><a class="header" href="#uppercaset">Uppercase&lt;T&gt;</a></h2>
<p>Make uppercase the name of the input type T.</p>
<pre><code class="language-typescript">type MyType = Uppercase&lt;'abc'&gt;; // &quot;ABC&quot;
</code></pre>
<h2 id="lowercaset"><a class="header" href="#lowercaset">Lowercase&lt;T&gt;</a></h2>
<p>Make lowercase the name of the input type T.</p>
<pre><code class="language-typescript">type MyType = Lowercase&lt;'ABC'&gt;; // &quot;abc&quot;
</code></pre>
<h2 id="capitalizet"><a class="header" href="#capitalizet">Capitalize&lt;T&gt;</a></h2>
<p>Capitalize the name of the input type T.</p>
<pre><code class="language-typescript">type MyType = Capitalize&lt;'abc'&gt;; // &quot;Abc&quot;
</code></pre>
<h2 id="uncapitalizet"><a class="header" href="#uncapitalizet">Uncapitalize&lt;T&gt;</a></h2>
<p>Uncapitalize the name of the input type T.</p>
<pre><code class="language-typescript">type MyType = Uncapitalize&lt;'Abc'&gt;; // &quot;abc&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="covariance-and-contravariance-in-typescript"><a class="header" href="#covariance-and-contravariance-in-typescript">Covariance and Contravariance in TypeScript</a></h3>
<p>Covariance and Contravariance are used to <strong>describe how relationships</strong> work when dealing with <strong>inheritance or assignment of types</strong>.</p>
<p>Covariance means that a type relationship preserves the direction of inheritance or assignment, so if a type A is a subtype of type B, then an array of type A is also considered a subtype of an array of type B. The important thing to note here is that the subtype relationship is maintained this means that Covariance accept subtype but doesn’t accept supertype.</p>
<p>Contravariance means that a type relationship reverses the direction of inheritance or assignment, so if a type A is a subtype of type B, then an array of type B is considered a subtype of an array of type A. The subtype relationship is reversed this means that Contravariance accept supertype but doesn’t accept subtype.</p>
<p><code>Covariance(accept subtype)</code></p>
<pre><code class="language-md">A(is sub type of)-&gt;B
Result:
Array of A(is sub type of)-&gt; Array of B
</code></pre>
<p><code>Contravariance(accept supertype)</code></p>
<pre><code class="language-md">A(is sub type of)-&gt;B
Result:
Array of B(is sub type of)-&gt; Array of A
</code></pre>
<pre><code class="language-md">Notes: Bivariance means accept both supertype &amp; subtype.
</code></pre>
<blockquote>
<p><code>Example:</code> Let’s say we have a space for all animals and a separate space just for dogs.</p>
</blockquote>
<p>In Covariance, you can put all the dogs in the animals space because dogs are a type of animal. But you cannot put all the animals in the dog space because there might be other animals mixed in.</p>
<p>In Contravariance, you cannot put all the animals in the dogs space because the animals space might contain other animals as well. However, you can put all the dogs in the animal space because all dogs are also animals.</p>
<!-- skip -->
<pre><code class="language-typescript">// Covariance example
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

class Dog extends Animal {
    breed: string;
    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
}

let animals: Animal[] = [];
let dogs: Dog[] = [];

// Covariance allows assigning subtype (Dog) array to supertype (Animal) array
animals = dogs;
dogs = animals; // Invalid: Type 'Animal[]' is not assignable to type 'Dog[]'

// Contravariance example
type Feed&lt;in T&gt; = (animal: T) =&gt; void;

let feedAnimal: Feed&lt;Animal&gt; = (animal: Animal) =&gt; {
    console.log(`Animal name: ${animal.name}`);
};

let feedDog: Feed&lt;Dog&gt; = (dog: Dog) =&gt; {
    console.log(`Dog name: ${dog.name}, Breed: ${dog.breed}`);
};

// Contravariance allows assigning supertype (Animal) callback to subtype (Dog) callback
feedDog = feedAnimal;
feedAnimal = feedDog; // Invalid: Type 'Feed&lt;Dog&gt;' is not assignable to type 'Feed&lt;Animal&gt;'.
</code></pre>
<p><code>Notice</code></p>
<p>In TypeScript, type relationships for arrays are covariant, while type relationships for function parameters are contravariant. This means that TypeScript exhibits both covariance and contravariance, depending on the context.</p>
<h4 id="optional-variance-annotations-for-type-parameters"><a class="header" href="#optional-variance-annotations-for-type-parameters">Optional Variance Annotations for Type Parameters</a></h4>
<p>As of TypeScript 4.7.0, we can use the <code>out</code> and <code>in</code> keywords to be specific about Variance annotation.</p>
<p>For Covariant, use the <code>out</code> keyword:</p>
<pre><code class="language-typescript">type AnimalCallback&lt;out T&gt; = () =&gt; T; // T is Covariant here
</code></pre>
<p>And for Contravariant, use the <code>in</code> keyword:</p>
<pre><code class="language-typescript">type AnimalCallback&lt;in T&gt; = (value: T) =&gt; void; // T is Contravariance here
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h3>
<p>A Recursive Type is a type that can refer to itself. This is useful for defining data structures that have a hierarchical or recursive structure (potentially infinite nesting), such as linked lists, trees, and graphs.</p>
<pre><code class="language-typescript">type ListNode&lt;T&gt; = {
    data: T;
    next: ListNode&lt;T&gt; | undefined;
};
</code></pre>
<h3 id="recursive-conditional-types"><a class="header" href="#recursive-conditional-types">Recursive Conditional Types</a></h3>
<p>It is possible to define complex type relationships using logic and recursion in TypeScript.
Let’s break it down in simple terms:</p>
<p>Conditional Types: allows you to define types based on boolean conditions:</p>
<pre><code class="language-typescript">type CheckNumber&lt;T&gt; = T extends number ? 'Number' : 'Not a number';
type A = CheckNumber&lt;123&gt;; // 'Number'
type B = CheckNumber&lt;'abc'&gt;; // 'Not a number'
</code></pre>
<p>Recursion: means a type definition that refers to itself within its own definition:</p>
<pre><code class="language-typescript">type Json = string | number | boolean | null | Json[] | { [key: string]: Json };

const data: Json = {
    prop1: true,
    prop2: 'prop2',
    prop3: {
        prop4: [],
    },
};
</code></pre>
<p>Recursive Conditional Types combine both conditional logic and recursion. It means that a type definition can depend on itself through conditional logic, creating complex and flexible type relationships.</p>
<pre><code class="language-typescript">type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? Flatten&lt;U&gt; : T;

type NestedArray = [1, [2, [3, 4], 5], 6];
type FlattenedArray = Flatten&lt;NestedArray&gt;; // 2 | 3 | 4 | 5 | 1 | 6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="errors-and-exception-handling"><a class="header" href="#errors-and-exception-handling">Errors and Exception Handling</a></h2>
<p>TypeScript allows you to catch and handle errors using standard JavaScript error handling mechanisms:</p>
<p>Try-Catch-Finally Blocks:</p>
<pre><code class="language-typescript">try {
    // Code that might throw an error
} catch (error) {
    // Handle the error
} finally {
    // Code that always executes, finally is optional
}
</code></pre>
<p>You can also handle different types of error:</p>
<pre><code class="language-typescript">try {
    // Code that might throw different types of errors
} catch (error) {
    if (error instanceof TypeError) {
        // Handle TypeError
    } else if (error instanceof RangeError) {
        // Handle RangeError
    } else {
        // Handle other errors
    }
}
</code></pre>
<p>Custom Error Types:</p>
<p>It is possible to specify more specific error by extending on the Error <code>class</code>:</p>
<pre><code class="language-typescript">class CustomError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'CustomError';
    }
}

throw new CustomError('This is a custom error.');
</code></pre>
<h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<p>JavaScript has an <code>Error</code> class that you can use for exceptions. You throw an error with the <code>throw</code> keyword. You can catch it with a <code>try</code> / <code>catch</code> block pair e.g.</p>
<pre><code class="language-js">try {
  throw new Error('Something bad happened');
}
catch(e) {
  console.log(e);
}
</code></pre>
<h2 id="error-sub-types"><a class="header" href="#error-sub-types">Error Sub Types</a></h2>
<p>Beyond the built in <code>Error</code> class there are a few additional built-in error classes that inherit from <code>Error</code> that the JavaScript runtime can throw:</p>
<h3 id="rangeerror"><a class="header" href="#rangeerror">RangeError</a></h3>
<p>Creates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.</p>
<pre><code class="language-js">// Call console with too many arguments
console.log.apply(console, new Array(1000000000)); // RangeError: Invalid array length
</code></pre>
<h3 id="referenceerror"><a class="header" href="#referenceerror">ReferenceError</a></h3>
<p>Creates an instance representing an error that occurs when de-referencing an invalid reference. e.g.</p>
<pre><code class="language-js">'use strict';
console.log(notValidVar); // ReferenceError: notValidVar is not defined
</code></pre>
<h3 id="syntaxerror"><a class="header" href="#syntaxerror">SyntaxError</a></h3>
<p>Creates an instance representing a syntax error that occurs while parsing code that isn’t valid JavaScript.</p>
<pre><code class="language-js">1***3; // SyntaxError: Unexpected token *
</code></pre>
<h3 id="typeerror"><a class="header" href="#typeerror">TypeError</a></h3>
<p>Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.</p>
<pre><code class="language-js">('1.2').toPrecision(1); // TypeError: '1.2'.toPrecision is not a function
</code></pre>
<h3 id="urierror"><a class="header" href="#urierror">URIError</a></h3>
<p>Creates an instance representing an error that occurs when <code>encodeURI()</code> or <code>decodeURI()</code> are passed invalid parameters.</p>
<pre><code class="language-js">decodeURI('%'); // URIError: URI malformed
</code></pre>
<h2 id="always-use-error"><a class="header" href="#always-use-error">Always use <code>Error</code></a></h2>
<p>Beginner JavaScript developers sometimes just throw raw strings e.g.</p>
<pre><code class="language-js">try {
  throw 'Something bad happened';
}
catch(e) {
  console.log(e);
}
</code></pre>
<p><em>Don’t do that</em>. The fundamental benefit of <code>Error</code> objects is that they automatically keep track of where they were built and originated with the <code>stack</code> property.</p>
<p>Raw strings result in a very painful debugging experience and complicate error analysis from logs.</p>
<h2 id="you-dont-have-to-throw-an-error"><a class="header" href="#you-dont-have-to-throw-an-error">You don’t have to <code>throw</code> an error</a></h2>
<p>It is okay to pass an <code>Error</code> object around. This is conventional in Node.js callback style code which takes callbacks with the first argument as an error object.</p>
<pre><code class="language-js">function myFunction (callback: (e?: Error)) {
  doSomethingAsync(function () {
    if (somethingWrong) {
      callback(new Error('This is my error'))
    } else {
      callback();
    }
  });
}
</code></pre>
<h2 id="exceptional-cases"><a class="header" href="#exceptional-cases">Exceptional cases</a></h2>
<p><code>Exceptions should be exceptional</code> is a common saying in computer science. There are a few reasons why this is true for JavaScript (and TypeScript) as well.</p>
<h3 id="unclear-where-it-is-thrown"><a class="header" href="#unclear-where-it-is-thrown">Unclear where it is thrown</a></h3>
<p>Consider the following piece of code:</p>
<pre><code class="language-js">try {
  const foo = runTask1();
  const bar = runTask2();
}
catch(e) {
  console.log('Error:', e);
}
</code></pre>
<p>The next developer cannot know which function might throw the error. The person reviewing the code cannot know without reading the code for task1 / task2 and other functions they might call etc.</p>
<h3 id="makes-graceful-handling-hard"><a class="header" href="#makes-graceful-handling-hard">Makes graceful handling hard</a></h3>
<p>You can try to make it graceful with explicit catch around each thing that might throw:</p>
<pre><code class="language-js">try {
  const foo = runTask1();
}
catch(e) {
  console.log('Error:', e);
}
try {
  const bar = runTask2();
}
catch(e) {
  console.log('Error:', e);
}
</code></pre>
<p>But now if you need to pass stuff from the first task to the second one the code becomes messy: (notice <code>foo</code> mutation requiring <code>let</code> + explicit need for annotating it because it cannot be inferred from the return of <code>runTask1</code>):</p>
<pre><code class="language-typescript">let foo: number; // Notice use of `let` and explicit type annotation
try {
  foo = runTask1();
}
catch(e) {
  console.log('Error:', e);
}
try {
  const bar = runTask2(foo);
}
catch(e) {
  console.log('Error:', e);
}
</code></pre>
<h3 id="not-well-represented-in-the-type-system"><a class="header" href="#not-well-represented-in-the-type-system">Not well represented in the type system</a></h3>
<p>Consider the function:</p>
<pre><code class="language-typescript">function validate(value: number) {
  if (value &lt; 0 || value &gt; 100) throw new Error('Invalid value');
}
</code></pre>
<p>Using <code>Error</code> for such cases is a bad idea as it is not represented in the type definition for the validate function (which is <code>(value:number) =&gt; void</code>). Instead a better way to create a validate method would be:</p>
<pre><code class="language-typescript">function validate(value: number): {error?: string} {
  if (value &lt; 0 || value &gt; 100) return {error:'Invalid value'};
}
</code></pre>
<p>And now its represented in the type system.</p>
<blockquote>
<p>Unless you want to handle the error in a very generic (simple / catch-all etc) way, don’t <em>throw</em> an error.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><code>&gt;tags:</code> [[readonly]] [[extend]]</p>
<h3 id="defaulted-declarations"><a class="header" href="#defaulted-declarations">Defaulted declarations</a></h3>
<p>Defaulted declarations are used when a variable or parameter is assigned a default value. This means that if no value is provided for that variable or parameter, the default value will be used instead.</p>
<pre><code class="language-typescript">function greet(name: string = 'Anonymous'): void {
    console.log(`Hello, ${name}!`);
}
greet(); // Hello, Anonymous!
greet('John'); // Hello, John!
</code></pre>
<h3 id="-character"><a class="header" href="#-character">! character</a></h3>
<p>Non-null assertion operators are simply a way of telling the compiler, trust me, I’m absolutely sure that this optional value is in fact never empty. Syntactically, you can express this by postfixing the optional value with a ! character. So developer will gauranty the code. ! means unsafe code.</p>
<pre><code class="language-ts">interface Person {
    hello(): void;
}

function sayHello(person: Person | undefined) {
    person!.hello(); // no errors!
}
</code></pre>
<p>One possible valid use-case for non-null assertion operators is when you are working with classes and you have the strictPropertyInitialization flag enabled.</p>
<pre><code class="language-ts">class CounterService {
    counter: number | undefined;

    increase() {
        if (this.counter !== undefined) {
            this.counter += 1;
            this.printCounter();
        }
    }

    private printCounter() {
        console.log(this.counter!.toLocaleString());
    }
}
</code></pre>
<h3 id="optional-chaining"><a class="header" href="#optional-chaining">Optional Chaining</a></h3>
<p>purpose of optional chaining in TypeScript is to access properties on an object that may or may not exist.
The optional chaining operator <code>?.</code> works like the regular dot operator (<code>.</code>) for accessing properties or methods. However, it gracefully handles null or undefined values by terminating the expression and returning <code>undefined</code>, instead of throwing an error.</p>
<pre><code class="language-typescript">type Person = {
    name: string;
    age?: number;
    address?: {
        street?: string;
        city?: string;
    };
};

const person: Person = {
    name: 'John',
};

console.log(person.address?.city); // undefined
</code></pre>
<h3 id="nullish-coalescing-operator-"><a class="header" href="#nullish-coalescing-operator-">Nullish coalescing operator (??)</a></h3>
<p>The nullish coalescing operator <code>??</code> returns the right-hand side value if the left-hand side is <code>null</code> or <code>undefined</code>; otherwise, it returns the left-hand side value.</p>
<pre><code class="language-typescript">const foo = null ?? 'foo';
console.log(foo); // foo

const baz = 1 ?? 'baz';
const baz2 = 0 ?? 'baz';
console.log(baz); // 1
console.log(baz2); // 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intersection-type"><a class="header" href="#intersection-type">Intersection Type</a></h2>
<p><code>extend</code> is a very common pattern in JavaScript where you take two objects and create a new one that has the features of both these objects. An <strong>Intersection Type</strong> allows you to use this pattern in a safe way as demonstrated below:</p>
<pre><code class="language-typescript">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
  return { ...first, ...second };
}

const x = extend({ a: &quot;hello&quot; }, { b: 42 });

// x now has both `a` and `b`
const a = x.a;
const b = x.b;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="es7-exponentiation-operator"><a class="header" href="#es7-exponentiation-operator">ES7 Exponentiation Operator</a></h3>
<p>The exponentiation (<code>**</code>) operator computes the value obtained by raising the first operand to the power of the second operand. It functions similarly to <code>Math.pow()</code>, but with the added <strong>capability of accepting BigInts as operands</strong>.
TypeScript fully supports this operator using as <code>target</code> in your tsconfig.json file <code>es2016</code> or larger version.</p>
<pre><code class="language-typescript">console.log(2 ** (2 ** 2)); // 16
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-satisfies-operator"><a class="header" href="#the-satisfies-operator">The satisfies Operator</a></h2>
<p>The <code>satisfies</code>  allows you to check if a given type satisfies a specific interface or condition. In other words, it <strong>ensures(infer)</strong> <em>that a type has all the required properties and methods of a specific interface.</em> It is a way to ensure a variable fits into a definition of a type.</p>
<p>Here is an example:</p>
<p><code>&gt;tags:</code> [[Important]] [[Satisfies]] [[Operator]] [[Map]] [[Array]] [[Attribute]] #Satisfy</p>
<!-- skip -->
<pre><code class="language-typescript">type Columns = 'name' | 'nickName' | 'attributes';

type User = Record&lt;Columns, string | string[] | undefined&gt;;

// Type Annotation using `User`
const user: User = {
    name: 'Simone',
    nickName: undefined,
    attributes: ['dev', 'admin'],
};

// In the following lines, TypeScript won't be able to infer properly
user.attributes?.map(console.log); // Property 'map' does not exist on type 'string | string[]'. Property 'map' does not exist on type 'string'.
user.nickName; // string | string[] | undefined

// Type assertion using `as`
const user2 = {
    name: 'Simon',
    nickName: undefined,
    attributes: ['dev', 'admin'],
} as User;

// Here too, TypeScript won't be able to infer properly
user2.attributes?.map(console.log); // Property 'map' does not exist on type 'string | string[]'. Property 'map' does not exist on type 'string'.
user2.nickName; // string | string[] | undefined

// Using `satisfies` operators we can properly infer the types now
const user3 = {
    name: 'Simon',
    nickName: undefined,
    attributes: ['dev', 'admin'],
} satisfies User;

user3.attributes?.map(console.log); // TypeScript infers correctly: string[]
user3.nickName; // TypeScript infers correctly: undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="conditional-types"><a class="header" href="#conditional-types">Conditional Types</a></h2>
<p>Allow you to create types based on some conditions:</p>
<pre><code class="language-typescript">type ExtractParam&lt;T&gt; = T extends (param: infer P) =&gt; any ? P : never;
type MyFunction = (name: string) =&gt; number;
type ParamType = ExtractParam&lt;MyFunction&gt;; // string
</code></pre>
<p>Conditional Types are a way to create a type that depends on a condition, where the type to be created is determined based on the result of the condition. They are defined using the <code>extends</code> keyword and a ternary operator to conditionally choose between two types.</p>
<pre><code class="language-typescript">type IsArray&lt;T&gt; = T extends any[] ? true : false;
const myArray = [1, 2, 3];
const myNumber = 42;
type IsMyArrayAnArray = IsArray&lt;typeof myArray&gt;; // Type true
type IsMyNumberAnArray = IsArray&lt;typeof myNumber&gt;; // Type false
</code></pre>
<h2 id="distributive-conditional-types"><a class="header" href="#distributive-conditional-types">Distributive Conditional Types</a></h2>
<p>Distributive Conditional Types are a feature that allow a type to be distributed over a union of types, by applying a transformation to each member of the union individually.
This can be especially useful when working with mapped types or higher-order types.</p>
<pre><code class="language-typescript">type Nullable&lt;T&gt; = T extends any ? T | null : never;
type NumberOrBool = number | boolean;
type NullableNumberOrBool = Nullable&lt;NumberOrBool&gt;; // number | boolean | null
</code></pre>
<h2 id="infer-type-inference-in-conditional-types"><a class="header" href="#infer-type-inference-in-conditional-types">infer Type Inference in Conditional Types</a></h2>
<p>The <code>infer</code>keyword is used in conditional types to infer (extract) the type of a generic parameter from a type that depends on it. This allows you to write more flexible and reusable type definitions.</p>
<pre><code class="language-typescript">type ElementType&lt;T&gt; = T extends (infer U)[] ? U : never;
type Numbers = ElementType&lt;number[]&gt;; // number
type Strings = ElementType&lt;string[]&gt;; // string
</code></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
InferredFromListType</li>
<li><input disabled="" type="checkbox" checked=""/>
InferredFromFnParam</li>
<li><input disabled="" type="checkbox" checked=""/>
InferredFromFnReturnType</li>
<li><input disabled="" type="checkbox" checked=""/>
InferredFromFnReturnType</li>
<li><input disabled="" type="checkbox" checked=""/>
InferredTypeFromArray</li>
</ul>
<h2 id="predefined-conditional-types"><a class="header" href="#predefined-conditional-types">Predefined Conditional Types</a></h2>
<p>In TypeScript, Predefined Conditional Types are built-in conditional types provided by the language. They are designed to perform common type transformations based on the characteristics of a given type.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>Exclude&lt;UnionType, ExcludedType&gt;</code>: This type removes all the types from Type that are assignable to ExcludedType.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Extract&lt;Type, Union&gt;</code>: This type extracts all the types from Union that are assignable to Type.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>NonNullable&lt;Type&gt;</code>: This type removes null and undefined from Type.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>ReturnType&lt;Type&gt;</code>: This type extracts the return type of a function Type.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Parameters&lt;Type&gt;</code>: This type extracts the parameter types of a function Type.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Required&lt;Type&gt;</code>: This type makes all properties in Type required.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Partial&lt;Type&gt;</code>: This type makes all properties in Type optional.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Readonly&lt;Type&gt;</code>: This type makes all properties in Type readonly.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapped-types"><a class="header" href="#mapped-types">Mapped Types</a></h2>
<p>Allow you to transform the properties of an existing type to create new type:</p>
<pre><code class="language-typescript">type Mutable&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
};
type Person = {
    name: string;
    age: number;
};
type ImmutablePerson = Mutable&lt;Person&gt;; // Properties become read-only
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ambient-declarations-1"><a class="header" href="#ambient-declarations-1">Ambient Declarations</a></h1>
<p><code>@types</code></p>
<p>A major design goal of TypeScript was to make it possible for you to safely and easily use existing JavaScript libraries in TypeScript. TypeScript does this by means of <strong>declaration</strong>.
Packages under the @types organization are special package naming conventions used to <strong>provide type definitions for existing JavaScript libraries or modules</strong>. For instance using:</p>
<pre><code class="language-shell">npm install --save-dev @types/lodash
</code></pre>
<p>Ambient declarations allow you to <strong>safely use existing popular JavaScript libraries</strong> and <em>incrementally migrate your JavaScript/CoffeeScript/Other-Compile-To-Js-Language project to TypeScript</em>.</p>
<p>Studying patterns in ambient declarations for <em>third party JavaScript code</em> is good practice for annotating <em>your</em> TypeScript code base as well. This is why we present it so early on.
Ambient declarations are files that describe types for JavaScript code, they have a file name format as <code>.d.ts.</code>. They are usually imported and used to annotate existing JavaScript libraries or to add types to existing JS files in your project.</p>
<p>Many common libraries types can be found at <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> and can be installed using:</p>
<pre><code class="language-shell">npm install --save-dev @types/library-name
</code></pre>
<p>For your defined Ambient Declarations, you can import using the “triple-slash” reference:</p>
<!-- skip -->
<pre><code class="language-typescript">/// &lt;reference path=&quot;./library-types.d.ts&quot; /&gt;
</code></pre>
<p>You can use Ambient Declarations even within JavaScript files using <code>// @ts-check</code>.</p>
<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">Definitely Typed</a> is definitely one of TypeScript’s greatest strengths. The community has effectively gone ahead and <strong>documented</strong> the nature of nearly 90% of the top JavaScript projects out there.</p>
<p>This means that you can use these projects in a very interactive and exploratory manner, no need to have the docs open in a separate window and making sure you don’t make a typo.</p>
<p>If you want you can build on this basic definition and provide more information to help protect you from errors:</p>
<pre><code class="language-typescript">declare var $: {
    (selector:string): any;
};
$('.awesome').show(); // Okay!
$(123).show(); // Error: selector needs to be a string
</code></pre>
<p>We will discuss the details of creating TypeScript definitions for existing JavaScript in detail later once you know more about TypeScript (e.g. stuff like <code>interface</code> and the <code>any</code>).</p>
<h2 id="using-types"><a class="header" href="#using-types">Using <code>@types</code></a></h2>
<p>Installation is fairly simple as it just works on top of <code>npm</code>. So as an example you can install type definitions for <code>jquery</code> simply as:</p>
<pre><code class="language-bash">npm install @types/jquery --save-dev
</code></pre>
<p><code>@types</code> supports both <em>global</em> and <em>module</em> type definitions.</p>
<h3 id="global-types"><a class="header" href="#global-types">Global <code>@types</code></a></h3>
<p>By default any definitions that support global consumption are included automatically. E.g. for <code>jquery</code> you should be able to just start using <code>$</code> <em>globally</em> in your project.</p>
<p>However, for <em>libraries</em>  (like <code>jquery</code>) I generally <strong>recommend using modules</strong>:</p>
<h3 id="module-types"><a class="header" href="#module-types">Module <code>@types</code></a></h3>
<p>After installation, no special configuration is required really. You just use it like a module e.g.:</p>
<pre><code class="language-typescript">import * as $ from &quot;jquery&quot;;

// Use $ at will in this module :)
</code></pre>
<p>A major design goal of TypeScript was to make it possible for you to safely and easily use existing JavaScript libraries in TypeScript. TypeScript does this by means of <em>declaration</em>. TypeScript provides you with a sliding scale of how much or how little effort you want to put in your declarations, the more effort you put the more type safety + code intelligence you get. Note that definitions for most of the popular JavaScript libraries have already been written for you by the <a href="https://github.com/borisyankov/DefinitelyTyped">DefinitelyTyped community</a> so for most purposes either:</p>
<ol>
<li>The definition file already exists.</li>
<li>Or at the very least, you have a vast list of well reviewed TypeScript declaration templates already available</li>
</ol>
<p>As a quick example of how you would author your own declaration file, consider a trivial example of <a href="https://jquery.com/">jquery</a>. By default (as is to be expected of good JS code) TypeScript expects you to declare (i.e. use <code>var</code> somewhere) before you use a variable</p>
<pre><code class="language-typescript">$('.awesome').show(); // Error: cannot find name `$`
</code></pre>
<blockquote>
<p>As a quick fix <em>you can tell TypeScript</em> that there is indeed something called <code>$</code>:</p>
</blockquote>
<pre><code class="language-typescript">declare var $: any;
$('.awesome').show(); // Okay!
</code></pre>
<h2 id="controlling-globals"><a class="header" href="#controlling-globals">Controlling Globals</a></h2>
<p>As can be seen, having a definition that allows global leak-in automatically can be a problem for some teams. So you can choose to <em>explicitly</em> only bring in the types that make sense using the <code>tsconfig.json</code> <code>compilerOptions.types</code> e.g.:</p>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;types&quot; : [
            &quot;jquery&quot;
        ]
    }
}
</code></pre>
<p>The above shows a sample where only <code>jquery</code> will be allowed to be used. Even if the person installs another definition like <code>npm install @types/node</code> its globals (e.g. <a href="https://nodejs.org/api/process.html"><code>process</code></a>) will not leak into your code until you add them to the <code>tsconfig.json</code> types option.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ambient-declarations-2"><a class="header" href="#ambient-declarations-2">Ambient Declarations</a></h2>
<blockquote>
<p>A major design goal of TypeScript was to make it possible for you to safely and easily use existing JavaScript libraries in TypeScript. TypeScript does this by means of <em>declaration</em>.</p>
</blockquote>
<p>Ambient declarations allow you to <strong>safely use existing popular JavaScript libraries</strong> and <em>incrementally migrate your JavaScript/CoffeeScript/Other-Compile-To-Js-Language project to TypeScript</em>.</p>
<p>Studying patterns in ambient declarations for <em>third party JavaScript code</em> is good practice for annotating <em>your</em> TypeScript code base as well. This is why we present it so early on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaration-file"><a class="header" href="#declaration-file">Declaration file</a></h1>
<p>A declaration file is a special type of file used by the TypeScript compiler. It is only used during the compilation step and is used as a sort of reference file to describe JavaScript. Declaration files are similar to the header files used in C or C++ or the interfaces used in Java. They simply describe the structure of available functions and properties but do not provide an implementation.</p>
<p>The purpose of a declaration file is to tell the TypeScript <strong>compiler ahead of time</strong> what the structure of a JavaScript library looks like. We have seen that we can use all of the TypeScript keywords and language features within a declaration file.</p>
<p>You can tell TypeScript that you are trying to describe code that exists elsewhere (e.g. written in JavaScript/CoffeeScript/The runtime environment like the browser or Node.js) using the <code>declare</code> keyword. As a quick example:</p>
<pre><code class="language-typescript">foo = 123; // Error: `foo` is not defined
</code></pre>
<p>vs.</p>
<pre><code class="language-typescript">declare var foo: any;
foo = 123; // allowed
</code></pre>
<p>The first thing to note about this code is that we have used the <strong>TypeScript keyword declare</strong>. The declare keyword tells the compiler that we want to define something but that the implementation of this object (or variable or function) <strong>will be resolved at runtime.</strong></p>
<p>You have the option of putting these declarations in a <code>.ts</code> file or in a <code>.d.ts</code> file. We highly recommend that in your real world projects you use a separate <code>.d.ts</code> (start with one called something like <code>global.d.ts</code> or <code>vendor.d.ts</code>).</p>
<p>If a file has the extension <code>.d.ts</code> then each root level definition must have the <code>declare</code> keyword prefixed to it. This helps make it clear to the author that there will be <em>no code emitted by TypeScript</em>. The author needs to ensure that the declared item will exist at runtime.</p>
<p><strong>Ambient declarations is a promise that you are making with the compiler</strong>. If these do not exist at runtime and you try to use them, things will break without warning.
<strong>Ambient declarations are like docs. If the source changes the docs need to be kept updated</strong>. So you might have new behaviours that work at runtime but no one’s updated the ambient declaration and hence you get compiler errors.</p>
<h3 id="auto-generating-declaration-type-files"><a class="header" href="#auto-generating-declaration-type-files">Auto-generating declaration type files</a></h3>
<p>Ref.to The declaration option of file <a href="types/module/ambient/../../../project/tsconfig.html">tsconfig</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>For example to tell TypeScript about the <a href="https://nodejs.org/api/process.html"><code>process</code> variable</a> you <em>can</em> do:</p>
<pre><code class="language-typescript">declare var process: any;
</code></pre>
<blockquote>
<p>You don’t <em>need</em> to do this for <code>process</code> as there is already a <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/index.d.ts">community maintained <code>node.d.ts</code></a>.</p>
</blockquote>
<p>This allows you to use the <code>process</code> variable without TypeScript complaining:</p>
<pre><code class="language-typescript">process.exit();
</code></pre>
<p>We recommend using an interface wherever possible e.g.:</p>
<pre><code class="language-typescript">interface Process {
    exit(code?: number): void;
}
declare var process: Process;
</code></pre>
<p>This allows other people to <em>extend</em> the nature of these global variables while still telling TypeScript about such modifications. E.g. consider the following case where we add an <code>exitWithLogging</code> function to process for our amusement:</p>
<pre><code class="language-typescript">interface Process {
    exitWithLogging(code?: number): void;
}
process.exitWithLogging = function() {
    console.log(&quot;exiting&quot;);
    process.exit.apply(process, arguments);
};
</code></pre>
<p>Let’s look at interfaces in a bit more detail next.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-only-imports-and-export"><a class="header" href="#type-only-imports-and-export">Type-Only Imports and Export</a></h2>
<p>Type-Only Imports and Export allows you to import or <strong>export types without importing or exporting the values or functions associated</strong> with those types. This can be useful for reducing the size of your bundle.</p>
<p>To use type-only imports, you can use the <code>import type</code> keyword.</p>
<p>TypeScript permits using both declaration and implementation file extensions (.ts, .mts, .cts, and .tsx) in type-only imports, regardless of <code>allowImportingTsExtensions</code> settings.</p>
<p>For example:</p>
<!-- skip -->
<pre><code class="language-typescript">import type { House } from './house.ts';
</code></pre>
<p>The following are supported forms:</p>
<!-- skip -->
<pre><code class="language-typescript">import type T from './mod';
import type { A, B } from './mod';
import type * as Types from './mod';
export type { T };
export type { T } from './mod';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="types/lib.d.ts.html#libdts">lib.d.ts</a></li>
<li><a href="types/lib.d.ts.html#example-usage">Example Usage</a></li>
<li><a href="types/lib.d.ts.html#libdts-inside-look">Inside look</a></li>
<li><a href="types/lib.d.ts.html#modifying-native-types">Modifying Native types</a></li>
<li><a href="types/lib.d.ts.html#using-your-own-custom-libdts">Using custom lib.d.ts</a></li>
<li><a href="types/lib.d.ts.html#compiler-target-effect-on-libdts">Compiler <code>target</code> effect on lib.d.ts</a></li>
<li><a href="types/lib.d.ts.html#lib-option"><code>lib</code> option</a></li>
<li><a href="types/lib.d.ts.html#polyfill-for-old-javascript-engines">Polyfill for old JavaScript engines</a></li>
</ul>
<h2 id="libdts"><a class="header" href="#libdts"><code>lib.d.ts</code></a></h2>
<p><code>Benefits of detailed declaration files</code></p>
<p>With these changes in place, any TypeScript code that uses these functions will <strong>ensure that the desired message structure</strong> is adhered to. Having a detailed declaration file for external JavaScript functions and libraries enhances the available <strong>documentation</strong> because it can be integrated directly into the <strong>code completion or code-hinting</strong> engine of the IDE we are using. Declaration files describe code as if it were written directly in TypeScript and will enforce the same strict typing rules for any code that we write using the external JavaScript libraries.</p>
<h2 id="nested-namespaces-and-a-function"><a class="header" href="#nested-namespaces-and-a-function">Nested namespaces and a function</a></h2>
<pre><code class="language-typescript">// This code declares a TypeScript module with nested namespaces and a function
declare module FirstNamespace {
    module SecondNamespace {
        module ThirdNamespace {
            function log(msg: string); // function to log a message
        }
    }
}

FirstNamespace.SecondNamespace.ThirdNamespace.log(&quot;test&quot;);
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<p>As always let’s look at examples of this file being used in action:</p>
<pre><code class="language-typescript">var foo = 123;
var bar = foo.toString();
</code></pre>
<p>This code type checks fine <em>because</em> the <code>toString</code> function is defined in <code>lib.d.ts</code> for all JavaScript objects.</p>
<p>If you use the same sample code with the <code>noLib</code> option you get a type check error:</p>
<pre><code class="language-typescript">var foo = 123;
var bar = foo.toString(); // ERROR: Property 'toString' does not exist on type 'number'.
</code></pre>
<p>So now that you understand the importance of <code>lib.d.ts</code>, what do its contents look like? We examine that next.</p>
<h3 id="libdts-inside-look"><a class="header" href="#libdts-inside-look"><code>lib.d.ts</code> Inside Look</a></h3>
<p>The contents of <code>lib.d.ts</code> are primarily a bunch of <em>variable</em> declarations e.g. <code>window</code>, <code>document</code>, <code>math</code> and a bunch of similar <em>interface</em> declarations e.g. <code>Window</code> , <code>Document</code>, <code>Math</code>.</p>
<p>The simplest way to read the documentation and type annotations of global stuff is to type in code <em>that you know works</em> e.g. <code>Math.floor</code> and then F12 (go to definition) using your IDE (VSCode has great support for this).</p>
<p>Let’s look at a sample <em>variable</em> declaration, e.g. <code>window</code> is defined as:</p>
<pre><code class="language-typescript">declare var window: Window;
</code></pre>
<p>That is just a simple <code>declare var</code> followed by the variable name (here <code>window</code>) and an interface for a type annotation (here the <code>Window</code> interface). These variables generally point to some global <em>interface</em> e.g. here is a small sample of the (actually quite massive) <code>Window</code> interface:</p>
<pre><code class="language-typescript">interface Window extends EventTarget, WindowTimers, WindowSessionStorage, WindowLocalStorage, WindowConsole, GlobalEventHandlers, IDBEnvironment, WindowBase64 {
    animationStartTime: number;
    applicationCache: ApplicationCache;
    clientInformation: Navigator;
    closed: boolean;
    crypto: Crypto;
    // so on and so forth...
}
</code></pre>
<p>You can see that there is a <em>lot</em> of type information in these interfaces. In the absence of TypeScript <em>you</em> would need to keep this in <em>your</em> head. Now you can offload that knowledge on the compiler with easy access to it using things like <code>intellisense</code>.</p>
<p>There is a good reason for using <em>interfaces</em> for these globals. It allows you to <em>add additional properties</em> to these globals <em>without</em> a need to change <code>lib.d.ts</code>. We will cover this concept next.</p>
<h3 id="modifying-native-types"><a class="header" href="#modifying-native-types">Modifying Native Types</a></h3>
<p>Since an <code>interface</code> in TypeScript is open ended this means that you can just add members to the interfaces declared in <code>lib.d.ts</code> and TypeScript will pick up on the additions. Note that you need to make these changes in a <a href="types/../project/modules.html"><em>global module</em></a> for these interfaces to be associated with <code>lib.d.ts</code>. We even recommend creating a special file called <a href="types/../project/globals.html"><code>global.d.ts</code></a> for this purpose.</p>
<p>Here are a few example cases where we add stuff to <code>window</code>, <code>Math</code>, <code>Date</code>:</p>
<h4 id="example-window"><a class="header" href="#example-window">Example <code>window</code></a></h4>
<p>Just add stuff to the <code>Window</code> interface e.g.:</p>
<pre><code class="language-typescript">interface Window {
    helloWorld(): void;
}
</code></pre>
<p>This will allow you to use it in a <em>type safe</em> manner:</p>
<pre><code class="language-typescript">// Add it at runtime
window.helloWorld = () =&gt; console.log('hello world');
// Call it
window.helloWorld();
// Misuse it and you get an error:
window.helloWorld('gracius'); // Error: Supplied parameters do not match the signature of the call target
</code></pre>
<h4 id="example-math"><a class="header" href="#example-math">Example <code>Math</code></a></h4>
<p>The global variable <code>Math</code> is defined in <code>lib.d.ts</code> as (again, use your dev tools to navigate to definition):</p>
<pre><code class="language-typescript">/** An intrinsic object that provides basic mathematics functionality and constants. */
declare var Math: Math;
</code></pre>
<p>i.e. the variable <code>Math</code> is an instance of the <code>Math</code> interface. The <code>Math</code> interface is defined as:</p>
<pre><code class="language-typescript">interface Math {
    E: number;
    LN10: number;
    // others ...
}
</code></pre>
<p>This means that if you want to add stuff to the <code>Math</code> global variable you just need to add it to the <code>Math</code> global interface, e.g. consider the <a href="https://www.npmjs.com/package/seedrandom"><code>seedrandom</code> project</a> which adds a <code>seedrandom</code> function to the global <code>Math</code> object. This can be declared quite easily:</p>
<pre><code class="language-typescript">interface Math {
    seedrandom(seed?: string);
}
</code></pre>
<p>And then you can just use it:</p>
<pre><code class="language-typescript">Math.seedrandom();
// or
Math.seedrandom(&quot;Any string you want!&quot;);
</code></pre>
<h4 id="example-date"><a class="header" href="#example-date">Example <code>Date</code></a></h4>
<p>If you look at the definition of the <code>Date</code> <em>variable</em> in <code>lib.d.ts</code> you will find:</p>
<pre><code class="language-typescript">declare var Date: DateConstructor;
</code></pre>
<p>The interface <code>DateConstructor</code> is similar to what you have seen before with <code>Math</code> and <code>Window</code> in that it contains members you can use off of the <code>Date</code> global variable e.g. <code>Date.now()</code>. In addition to these members it contains <em>construct</em> signatures which allow you to create <code>Date</code> instances (e.g. <code>new Date()</code>). A snippet of the <code>DateConstructor</code> interface is shown below:</p>
<pre><code class="language-typescript">interface DateConstructor {
    new (): Date;
    // ... other construct signatures

    now(): number;
    // ... other member functions
}
</code></pre>
<p>Consider the project <a href="https://github.com/abritinthebay/datejs"><code>datejs</code></a>. DateJS adds members to both the <code>Date</code> global variable and <code>Date</code> instances. Therefore a TypeScript definition for this library would look like (<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/datejs/index.d.ts">BTW the community has already written this for you in this case</a>):</p>
<pre><code class="language-typescript">/** DateJS Public Static Methods */
interface DateConstructor {
    /** Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM) */
    today(): Date;
    // ... so on and so forth
}

/** DateJS Public Instance Methods */
interface Date {
    /** Adds the specified number of milliseconds to this instance. */
    addMilliseconds(milliseconds: number): Date;
    // ... so on and so forth
}
</code></pre>
<p>This allows you to do stuff like the following in a TypeSafe manner:</p>
<pre><code class="language-typescript">var today = Date.today();
var todayAfter1second = today.addMilliseconds(1000);
</code></pre>
<h4 id="example-string"><a class="header" href="#example-string">Example <code>string</code></a></h4>
<p>If you look inside <code>lib.d.ts</code> for string you will find stuff similar to what we saw for <code>Date</code> (<code>String</code> global variable, <code>StringConstructor</code> interface, <code>String</code> interface). One thing of note though is that the <code>String</code> interface also impacts string <em>literals</em> as demonstrated in the below code sample:</p>
<pre><code class="language-typescript">
interface String {
    endsWith(suffix: string): boolean;
}

String.prototype.endsWith = function(suffix: string): boolean {
    var str: string = this;
    return str &amp;&amp; str.indexOf(suffix, str.length - suffix.length) !== -1;
}

console.log('foo bar'.endsWith('bas')); // false
console.log('foo bas'.endsWith('bas')); // true
</code></pre>
<p>Similar variables and interfaces exist for other things that have both static and instance members like <code>Number</code>, <code>Boolean</code>, <code>RegExp</code>, etc. and these interfaces affect literal instances of these types as well.</p>
<h3 id="example-string-redux"><a class="header" href="#example-string-redux">Example <code>string</code> redux</a></h3>
<p>We recommended creating a <code>global.d.ts</code> for maintainability reasons. However, you can break into the <em>global namespace</em> from within <em>a file module</em> if you desire so. This is done using <code>declare global { /*global namespace here*/ }</code>. E.g. the previous example can also be done as:</p>
<pre><code class="language-typescript">// Ensure this is treated as a module.
export {};

declare global {
    interface String {
        endsWith(suffix: string): boolean;
    }
}

String.prototype.endsWith = function(suffix: string): boolean {
    var str: string = this;
    return str &amp;&amp; str.indexOf(suffix, str.length - suffix.length) !== -1;
}

console.log('foo bar'.endsWith('bas')); // false
console.log('foo bas'.endsWith('bas')); // true
</code></pre>
<h3 id="using-your-own-custom-libdts"><a class="header" href="#using-your-own-custom-libdts">Using your own custom lib.d.ts</a></h3>
<p>As we mentioned earlier, using the <code>--noLib</code> boolean compiler flag causes TypeScript to exclude the automatic inclusion of <code>lib.d.ts</code>. There are various reasons why this is a useful feature. Here are a few of the common ones:</p>
<ul>
<li>You are running in a custom JavaScript environment that differs <em>significantly</em> from the standard browser based runtime environment.</li>
<li>You like to have <em>strict</em> control over the <em>globals</em> available in your code. E.g. lib.d.ts defines <code>item</code> as a global variable and you don’t want this to leak into your code.</li>
</ul>
<p>Once you have excluded the default <code>lib.d.ts</code> you can include a similarly named file into your compilation context and TypeScript will pick it up for type checking.</p>
<blockquote>
<p>Note: be careful with <code>--noLib</code>. Once you are in noLib land, if you choose to share your project with others, they will be <em>forced</em> into noLib land (or rather <em>your lib</em> land). Even worse, if you bring <em>their</em> code into your project you might need to port it to <em>your lib</em> based code.</p>
</blockquote>
<h3 id="compiler-target-effect-on-libdts"><a class="header" href="#compiler-target-effect-on-libdts">Compiler target effect on <code>lib.d.ts</code></a></h3>
<p>Setting the compiler target to <code>es6</code> causes the <code>lib.d.ts</code> to include <em>additional</em> ambient declarations for more modern (es6) stuff like <code>Promise</code>. This magical effect of the compiler target changing the <em>ambience</em> of the code is desirable for some people and for others it’s problematic as it conflates <em>code generation</em> with <em>code ambience</em>.</p>
<p>However, if you want finer grained control of your environment, you should use the <code>--lib</code> option which we discuss next.</p>
<h3 id="lib-option"><a class="header" href="#lib-option">lib option</a></h3>
<p>Sometimes (many times) you want to decouple the relationship between the compile target (the generated JavaScript version) and the ambient library support. A common example is <code>Promise</code>, e.g. today (in June 2016) you most likely want to <code>--target es5</code> but still use the latest features like <code>Promise</code>. To support this you can take explicit control of <code>lib</code> using the <code>lib</code> compiler option.</p>
<blockquote>
<p>Note: using <code>--lib</code> decouples any lib magic from <code>--target</code> giving you better control.</p>
</blockquote>
<p>You can provide this option on the command line or in <code>tsconfig.json</code> (recommended):</p>
<p><strong>Command line</strong>:</p>
<pre><code>tsc --target es5 --lib dom,es6
</code></pre>
<p><strong>tsconfig.json</strong>:</p>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;lib&quot;: [&quot;dom&quot;, &quot;es6&quot;]
}
</code></pre>
<p>The libs can be categorized as follows:</p>
<ul>
<li>JavaScript Bulk Feature:
<ul>
<li>es5</li>
<li>es6</li>
<li>es2015</li>
<li>es7</li>
<li>es2016</li>
<li>es2017</li>
<li>esnext</li>
</ul>
</li>
<li>Runtime Environment
<ul>
<li>dom</li>
<li>dom.iterable</li>
<li>webworker</li>
<li>scripthost</li>
</ul>
</li>
<li>ESNext By-Feature Options (even smaller than bulk feature)
<ul>
<li>es2015.core</li>
<li>es2015.collection</li>
<li>es2015.generator</li>
<li>es2015.iterable</li>
<li>es2015.promise</li>
<li>es2015.proxy</li>
<li>es2015.reflect</li>
<li>es2015.symbol</li>
<li>es2015.symbol.wellknown</li>
<li>es2016.array.include</li>
<li>es2017.object</li>
<li>es2017.sharedmemory</li>
<li>esnext.asynciterable</li>
</ul>
</li>
</ul>
<blockquote>
<p>NOTE: the <code>--lib</code> option provides extremely fine tuned control. So you most likely want to pick an item from the bulk + environment categories.
If –lib is not specified a default library is injected:</p>
</blockquote>
<ul>
<li>For –target es5 =&gt; es5, dom, scripthost</li>
<li>For –target es6 =&gt; es6, dom, dom.iterable, scripthost</li>
</ul>
<p>My Personal Recommendation:</p>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;lib&quot;: [&quot;es6&quot;, &quot;dom&quot;]
}
</code></pre>
<p>Example Including Symbol with ES5:</p>
<p>Symbol API is not included when target is es5. In fact, we receive an error like: [ts] Cannot find name ‘Symbol’.
We can use “target”: “es5” in combination with “lib” to provide Symbol API in TypeScript:</p>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;lib&quot;: [&quot;es5&quot;, &quot;dom&quot;, &quot;scripthost&quot;, &quot;es2015.symbol&quot;]
}
</code></pre>
<h2 id="polyfill-for-old-javascript-engines"><a class="header" href="#polyfill-for-old-javascript-engines">Polyfill for old JavaScript engines</a></h2>
<blockquote>
<p><a href="https://egghead.io/lessons/typescript-using-es6-and-esnext-with-typescript">Egghead PRO Video on this subject</a></p>
</blockquote>
<p>There are quite a few runtime features that are like <code>Map</code> / <code>Set</code> and even <code>Promise</code> (this list will of course change over time) that you can use with modern <code>lib</code> options. To use these all you need to do is use <code>core-js</code>. Simply install:</p>
<pre><code>npm install core-js --save-dev
</code></pre>
<p>And add an import to your application entry point: </p>
<pre><code class="language-js">import &quot;core-js&quot;;
</code></pre>
<p>And it should polyfill these runtime features for you 🌹.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="types/functions.html#parameter-annotations">Parameter Annotations</a></li>
<li><a href="types/functions.html#return-type-annotation">Return Type Annotation</a></li>
<li><a href="types/functions.html#optional-parameters">Optional Parameters</a></li>
<li><a href="types/functions.html#overloading">Overloading</a></li>
</ul>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>The TypeScript type system pays a lot of love to functions, after all they are the core building blocks of a composable system.</p>
<h3 id="parameter-annotations"><a class="header" href="#parameter-annotations">Parameter annotations</a></h3>
<p>Of course you can annotate function parameters just like you can annotate other variables:</p>
<pre><code class="language-typescript">// variable annotation
var sampleVariable: { bar: number }

// function parameter annotation
function foo(sampleParameter: { bar: number }) { }
</code></pre>
<p>Here I used inline type annotations. Of course you can use interfaces etc.</p>
<h3 id="return-type-annotation"><a class="header" href="#return-type-annotation">Return type annotation</a></h3>
<p>You can annotate the return type after the function parameter list with the same style as you use for a variable, e.g. <code>: Foo</code> in the below example:</p>
<pre><code class="language-typescript">interface Foo {
    foo: string;
}

// Return type annotated as `: Foo`
function foo(sample: Foo): Foo {
    return sample;
}
</code></pre>
<p>Of course I used an <code>interface</code> here, but you are free to use other annotations e.g. inline annotations.</p>
<p>Quite commonly you don’t <em>need</em> to annotate the return type of a function as it can generally be inferred by the compiler.</p>
<pre><code class="language-typescript">interface Foo {
    foo: string;
}

function foo(sample: Foo) {
    return sample; // inferred return type 'Foo'
}
</code></pre>
<p>However, it is generally a good idea to add these annotation to help with errors e.g.:</p>
<pre><code class="language-typescript">function foo() {
    return { fou: 'John Doe' }; // You might not find this misspelling of `foo` till it's too late
}

sendAsJSON(foo());
</code></pre>
<p>If you don’t plan to return anything from a function, you can annotate it as <code>:void</code>. You can generally drop <code>:void</code> and leave it to the inference engine though.</p>
<h3 id="optional-parameters"><a class="header" href="#optional-parameters">Optional Parameters</a></h3>
<p>You can mark a parameter as optional:</p>
<pre><code class="language-typescript">function foo(bar: number, bas?: string): void {
    // ..
}

foo(123);
foo(123, 'hello');
</code></pre>
<p>Alternatively you can even provide a default value (using <code>= someValue</code> after the parameter declaration) which is injected for you if the caller doesn’t provide that argument:</p>
<pre><code class="language-typescript">function foo(bar: number, bas: string = 'hello') {
    console.log(bar, bas);
}

foo(123);           // 123, hello
foo(123, 'world');  // 123, world
</code></pre>
<h3 id="overloading"><a class="header" href="#overloading">Overloading</a></h3>
<p>TypeScript allows you to <em>declare</em> function overloads. This is useful for documentation + type safety purpose. Consider the following code:</p>
<pre><code class="language-typescript">function padding(a: number, b?: number, c?: number, d?: any) {
    if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) {
        b = c = d = a;
    }
    else if (c === undefined &amp;&amp; d === undefined) {
        c = a;
        d = b;
    }
    return {
        top: a,
        right: b,
        bottom: c,
        left: d
    };
}
</code></pre>
<p>If you look at the code carefully you realize the meaning of <code>a</code>,<code>b</code>,<code>c</code>,<code>d</code> changes based on how many arguments are passed in. Also the function only expects <code>1</code>, <code>2</code> or <code>4</code> arguments. These constraints can be <em>enforced</em> and <em>documented</em> using function overloading. You just declare the function header multiple times. The last function header is the one that is actually active <em>within</em> the function body but is not available to the outside world.</p>
<p>This is shown below:</p>
<pre><code class="language-typescript">// Overloads
function padding(all: number);
function padding(topAndBottom: number, leftAndRight: number);
function padding(top: number, right: number, bottom: number, left: number);
// Actual implementation that is a true representation of all the cases the function body needs to handle
function padding(a: number, b?: number, c?: number, d?: number) {
    if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) {
        b = c = d = a;
    }
    else if (c === undefined &amp;&amp; d === undefined) {
        c = a;
        d = b;
    }
    return {
        top: a,
        right: b,
        bottom: c,
        left: d
    };
}
</code></pre>
<p>Here the first three function headers are available as valid calls to <code>padding</code>:</p>
<pre><code class="language-typescript">padding(1); // Okay: all
padding(1,1); // Okay: topAndBottom, leftAndRight
padding(1,1,1,1); // Okay: top, right, bottom, left

padding(1,1,1); // Error: Not a part of the available overloads
</code></pre>
<p>Of course it’s important for the final declaration (the true declaration as seen from inside the function) to be compatible with all the overloads. This is because that is the true nature of the function calls that the function body needs to account for.</p>
<blockquote>
<p>Function overloading in TypeScript doesn’t come with any runtime overhead. It just allows you to document the manner you expect the function to be called in and the compiler holds the rest of your code in check.</p>
</blockquote>
<h3 id="declaring-functions"><a class="header" href="#declaring-functions">Declaring Functions</a></h3>
<blockquote>
<p>Quick Tip: <em>Type Declarations</em> are how you describe the types of existing implementations. </p>
</blockquote>
<p>There are two ways to <em>declare</em> the type of a function without providing an implementation. E.g. </p>
<pre><code class="language-typescript">type LongHand = {
    (a: number): number;
};

type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>The example above are both <em>exactly</em> equivalent. The differences exist when you want to add overloads. You can only add overloads in the long hand declaration version e.g. </p>
<pre><code class="language-typescript">type LongHandAllowsOverloadDeclarations = {
    (a: number): number;
    (a: string): string;
};
</code></pre>
<p>[](### Type Compatibility)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="callable"><a class="header" href="#callable">Callable</a></h2>
<p>You can annotate callables as a part of a type or an interface as follows</p>
<pre><code class="language-typescript">interface ReturnString {
  (): string
}
</code></pre>
<p>An instance of such an interface would be a function that returns a string e.g.</p>
<pre><code class="language-typescript">declare const foo: ReturnString;
const bar = foo(); // bar is inferred as a string
</code></pre>
<h3 id="obvious-examples"><a class="header" href="#obvious-examples">Obvious examples</a></h3>
<p>Of course such a <em>callable</em> annotation can also specify any arguments / optional arguments / rest arguments as needed. e.g. here is a complex example:</p>
<pre><code class="language-typescript">interface Complex {
  (foo: string, bar?: number, ...others: boolean[]): number;
}
</code></pre>
<p>An interface can provide multiple callable annotations to specify function overloading. For example:</p>
<pre><code class="language-typescript">interface Overloaded {
    (foo: string): string
    (foo: number): number
}

// example implementation
function stringOrNumber(foo: number): number;
function stringOrNumber(foo: string): string;
function stringOrNumber(foo: any): any {
    if (typeof foo === 'number') {
        return foo * foo;
    } else if (typeof foo === 'string') {
        return `hello ${foo}`;
    }
}

const overloaded: Overloaded = stringOrNumber;

// example usage
const str = overloaded(''); // type of `str` is inferred as `string`
const num = overloaded(123); // type of `num` is inferred as `number`
</code></pre>
<p>Of course, like the body of <em>any</em> interface, you can use the body of a callable interface as a type annotation for a variable. For example:</p>
<pre><code class="language-typescript">const overloaded: {
  (foo: string): string
  (foo: number): number
} = (foo: any) =&gt; foo;
</code></pre>
<h3 id="arrow-syntax"><a class="header" href="#arrow-syntax">Arrow Syntax</a></h3>
<p>To make it easy to specify callable signatures, TypeScript also allows simple arrow type annotations. For example, a function that takes a <code>number</code> and returns a <code>string</code> can be annotated as:</p>
<pre><code class="language-typescript">const simple: (foo: number) =&gt; string
    = (foo) =&gt; foo.toString();
</code></pre>
<blockquote>
<p>Only limitation of the arrow syntax: You can’t specify overloads. For overloads you must use the full bodied <code>{ (someArgs): someReturn }</code> syntax.</p>
</blockquote>
<h3 id="newable"><a class="header" href="#newable">Newable</a></h3>
<p>Newable is just a special type of <em>callable</em> type annotation with the prefix <code>new</code>. It simply means that you need to <em>invoke</em> with <code>new</code> e.g.</p>
<pre><code class="language-typescript">interface CallMeWithNewToGetString {
  new(): string
}
// Usage
declare const Foo: CallMeWithNewToGetString;
const bar = new Foo(); // bar is inferred to be of type string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="types/type-compatibility.html#type-compatibility">Type Compatibility</a></li>
<li><a href="types/type-compatibility.html#soundness">Soundness</a></li>
<li><a href="types/type-compatibility.html#structural">Structural</a></li>
<li><a href="types/type-compatibility.html#generics">Generics</a></li>
<li><a href="types/type-compatibility.html#variance">Variance</a></li>
<li><a href="types/type-compatibility.html#functions">Functions</a>
<ul>
<li><a href="types/type-compatibility.html#return-type">Return Type</a></li>
<li><a href="types/type-compatibility.html#number-of-arguments">Number of arguments</a></li>
<li><a href="types/type-compatibility.html#optional-and-rest-parameters">Optional and rest parameters</a></li>
<li><a href="types/type-compatibility.html#types-of-arguments">Types of arguments</a></li>
</ul>
</li>
<li><a href="types/type-compatibility.html#enums">Enums</a></li>
<li><a href="types/type-compatibility.html#classes">Classes</a></li>
<li><a href="types/type-compatibility.html#generics">Generics</a></li>
<li><a href="types/type-compatibility.html#footnote-invariance">FootNote: Invariance</a></li>
</ul>
<h2 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h2>
<p>Type Compatibility (as we discuss here) determines if one thing can be assigned to another. E.g. <code>string</code> and <code>number</code> are not compatible:</p>
<pre><code class="language-typescript">let str: string = &quot;Hello&quot;;
let num: number = 123;

str = num; // ERROR: `number` is not assignable to `string`
num = str; // ERROR: `string` is not assignable to `number`
</code></pre>
<h2 id="soundness"><a class="header" href="#soundness">Soundness</a></h2>
<p>TypeScript’s type system is designed to be convenient and allows for <em>unsound</em> behaviours e.g. anything can be assigned to <code>any</code> which means telling the compiler to allow you to do whatever you want:</p>
<pre><code class="language-typescript">let foo: any = 123;
foo = &quot;Hello&quot;;

// Later
foo.toPrecision(3); // Allowed as you typed it as `any`
</code></pre>
<h2 id="structural"><a class="header" href="#structural">Structural</a></h2>
<p>TypeScript objects are structurally typed. This means the <em>names</em> don’t matter as long as the structures match</p>
<pre><code class="language-typescript">interface Point {
    x: number,
    y: number
}

class Point2D {
    constructor(public x:number, public y:number){}
}

let p: Point;
// OK, because of structural typing
p = new Point2D(1,2);
</code></pre>
<p>This allows you to create objects on the fly (like you do in vanilla JS) and still have safety whenever it can be inferred.</p>
<p>Also <em>more</em> data is considered fine:</p>
<pre><code class="language-typescript">interface Point2D {
    x: number;
    y: number;
}
interface Point3D {
    x: number;
    y: number;
    z: number;
}
var point2D: Point2D = { x: 0, y: 10 }
var point3D: Point3D = { x: 0, y: 10, z: 20 }
function iTakePoint2D(point: Point2D) { /* do something */ }

iTakePoint2D(point2D); // exact match okay
iTakePoint2D(point3D); // extra information okay
iTakePoint2D({ x: 0 }); // Error: missing information `y`
</code></pre>
<h2 id="variance"><a class="header" href="#variance">Variance</a></h2>
<p>Variance is an easy to understand and important concept for type compatibility analysis.</p>
<p>For simple types <code>Base</code> and <code>Child</code>, if <code>Child</code> is a child of <code>Base</code>, then instances of <code>Child</code> can be assigned to a variable of type <code>Base</code>.</p>
<blockquote>
<p>This is polymorphism 101</p>
</blockquote>
<p>In type compatibility of complex types composed of such <code>Base</code> and <code>Child</code> types depends on where the <code>Base</code> and <code>Child</code> in similar scenarios is driven by <em>variance</em>.</p>
<ul>
<li>Covariant : (co aka joint) only in <em>same direction</em></li>
<li>Contravariant : (contra aka negative) only in <em>opposite direction</em></li>
<li>Bivariant : (bi aka both) both co and contra.</li>
<li>Invariant : if the types aren’t exactly the same then they are incompatible.</li>
</ul>
<blockquote>
<p>Note: For a completely sound type system in the presence of mutable data like JavaScript, <code>invariant</code> is the only valid option. But as mentioned <em>convenience</em> forces us to make unsound choices.</p>
</blockquote>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<p>There are a few subtle things to consider when comparing two functions.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return Type</a></h3>
<p><code>covariant</code>: The return type must contain at least enough data.</p>
<pre><code class="language-typescript">/** Type Hierarchy */
interface Point2D { x: number; y: number; }
interface Point3D { x: number; y: number; z: number; }

/** Two sample functions */
let iMakePoint2D = (): Point2D =&gt; ({ x: 0, y: 0 });
let iMakePoint3D = (): Point3D =&gt; ({ x: 0, y: 0, z: 0 });

/** Assignment */
iMakePoint2D = iMakePoint3D; // Okay
iMakePoint3D = iMakePoint2D; // ERROR: Point2D is not assignable to Point3D
</code></pre>
<h3 id="number-of-arguments"><a class="header" href="#number-of-arguments">Number of arguments</a></h3>
<p>Fewer arguments are okay (i.e. functions can choose to ignore additional parameters). After all you are guaranteed to be called with at least enough arguments.</p>
<pre><code class="language-typescript">let iTakeSomethingAndPassItAnErr
    = (x: (err: Error, data: any) =&gt; void) =&gt; { /* do something */ };

iTakeSomethingAndPassItAnErr(() =&gt; null) // Okay
iTakeSomethingAndPassItAnErr((err) =&gt; null) // Okay
iTakeSomethingAndPassItAnErr((err, data) =&gt; null) // Okay

// ERROR: Argument of type '(err: any, data: any, more: any) =&gt; null' is not assignable to parameter of type '(err: Error, data: any) =&gt; void'.
iTakeSomethingAndPassItAnErr((err, data, more) =&gt; null);
</code></pre>
<h3 id="optional-and-rest-parameters"><a class="header" href="#optional-and-rest-parameters">Optional and Rest Parameters</a></h3>
<p>Optional (pre determined count) and Rest parameters (any count of arguments) are compatible, again for convenience.</p>
<pre><code class="language-typescript">let foo = (x:number, y: number) =&gt; { /* do something */ }
let bar = (x?:number, y?: number) =&gt; { /* do something */ }
let bas = (...args: number[]) =&gt; { /* do something */ }

foo = bar = bas;
bas = bar = foo;
</code></pre>
<blockquote>
<p>Note: optional (in our example <code>bar</code>) and non optional (in our example <code>foo</code>) are only compatible if strictNullChecks is false.</p>
</blockquote>
<h3 id="types-of-arguments"><a class="header" href="#types-of-arguments">Types of arguments</a></h3>
<p><code>bivariant</code> : This is designed to support common event handling scenarios</p>
<pre><code class="language-typescript">/** Event Hierarchy */
interface Event { timestamp: number; }
interface MouseEvent extends Event { x: number; y: number }
interface KeyEvent extends Event { keyCode: number }

/** Sample event listener */
enum EventType { Mouse, Keyboard }
function addEventListener(eventType: EventType, handler: (n: Event) =&gt; void) {
    /* ... */
}

// Unsound, but useful and common. Works as function argument comparison is bivariant
addEventListener(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y));

// Undesirable alternatives in presence of soundness
addEventListener(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + &quot;,&quot; + (&lt;MouseEvent&gt;e).y));
addEventListener(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + &quot;,&quot; + e.y)));

// Still disallowed (clear error). Type safety enforced for wholly incompatible types
addEventListener(EventType.Mouse, (e: number) =&gt; console.log(e));
</code></pre>
<p>Also makes <code>Array&lt;Child&gt;</code> assignable to <code>Array&lt;Base&gt;</code> (covariance) as the functions are compatible. Array covariance requires all <code>Array&lt;Child&gt;</code> functions to be assignable to <code>Array&lt;Base&gt;</code> e.g. <code>push(t:Child)</code> is assignable to <code>push(t:Base)</code> which is made possible by function argument bivariance.</p>
<p><strong>This can be confusing for people coming from other languages</strong> who would expect the following to error but will not in TypeScript:</p>
<pre><code class="language-typescript">/** Type Hierarchy */
interface Point2D { x: number; y: number; }
interface Point3D { x: number; y: number; z: number; }

/** Two sample functions */
let iTakePoint2D = (point: Point2D) =&gt; { /* do something */ }
let iTakePoint3D = (point: Point3D) =&gt; { /* do something */ }

iTakePoint3D = iTakePoint2D; // Okay : Reasonable
iTakePoint2D = iTakePoint3D; // Okay : WHAT
</code></pre>
<h2 id="enums-2"><a class="header" href="#enums-2">Enums</a></h2>
<ul>
<li>Enums are compatible with numbers, and numbers are compatible with enums.</li>
</ul>
<pre><code class="language-typescript">enum Status { Ready, Waiting };

let status = Status.Ready;
let num = 0;

status = num; // OKAY
num = status; // OKAY
</code></pre>
<ul>
<li>Enum values from different enum types are considered incompatible. This makes enums useable <em>nominally</em> (as opposed to structurally)</li>
</ul>
<pre><code class="language-typescript">enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

let status = Status.Ready;
let color = Color.Red;

status = color; // ERROR
</code></pre>
<h2 id="classes-1"><a class="header" href="#classes-1">Classes</a></h2>
<ul>
<li>Only instance members and methods are compared. <em>constructors</em> and <em>statics</em> play no part.</li>
</ul>
<pre><code class="language-typescript">class Animal {
    feet: number;
    constructor(name: string, numFeet: number) { /** do something */ }
}

class Size {
    feet: number;
    constructor(meters: number) { /** do something */ }
}

let a: Animal;
let s: Size;

a = s;  // OK
s = a;  // OK
</code></pre>
<ul>
<li><code>private</code> and <code>protected</code> members <em>must originate from the same class</em>. Such members essentially make the class <em>nominal</em>.</li>
</ul>
<pre><code class="language-typescript">/** A class hierarchy */
class Animal { protected feet: number; }
class Cat extends Animal { }

let animal: Animal;
let cat: Cat;

animal = cat; // OKAY
cat = animal; // OKAY

/** Looks just like Animal */
class Size { protected feet: number; }

let size: Size;

animal = size; // ERROR
size = animal; // ERROR
</code></pre>
<h2 id="generics-1"><a class="header" href="#generics-1">Generics</a></h2>
<p>Since TypeScript has a structural type system, type parameters only affect compatibility when used by a member. For example, in the  following <code>T</code> has no impact on compatibility:</p>
<pre><code class="language-typescript">interface Empty&lt;T&gt; {
}
let x: Empty&lt;number&gt;;
let y: Empty&lt;string&gt;;

x = y;  // okay, y matches structure of x
</code></pre>
<p>However, if <code>T</code> is used, it will play a role in compatibility based on its <em>instantiation</em> as shown below:</p>
<pre><code class="language-typescript">interface NotEmpty&lt;T&gt; {
    data: T;
}
let x: NotEmpty&lt;number&gt;;
let y: NotEmpty&lt;string&gt;;

x = y;  // error, x and y are not compatible
</code></pre>
<p>In cases where generic arguments haven’t been <em>instantiated</em> they are substituted by <code>any</code> before checking compatibility:</p>
<pre><code class="language-typescript">let identity = function&lt;T&gt;(x: T): T {
    // ...
}

let reverse = function&lt;U&gt;(y: U): U {
    // ...
}

identity = reverse;  // Okay because (x: any)=&gt;any matches (y: any)=&gt;any
</code></pre>
<p>Generics involving classes are matched by relevant class compatibility as mentioned before. e.g. </p>
<pre><code class="language-typescript">class List&lt;T&gt; {
  add(val: T) { }
}

class Animal { name: string; }
class Cat extends Animal { meow() { } }

const animals = new List&lt;Animal&gt;();
animals.add(new Animal()); // Okay 
animals.add(new Cat()); // Okay 

const cats = new List&lt;Cat&gt;();
cats.add(new Animal()); // Error 
cats.add(new Cat()); // Okay
</code></pre>
<h2 id="footnote-invariance"><a class="header" href="#footnote-invariance">FootNote: Invariance</a></h2>
<p>We said invariance is the only sound option. Here is an example where both <code>contra</code> and <code>co</code> variance are shown to be unsafe for arrays.</p>
<pre><code class="language-typescript">/** Hierarchy */
class Animal { constructor(public name: string){} }
class Cat extends Animal { meow() { } }

/** An item of each */
var animal = new Animal(&quot;animal&quot;);
var cat = new Cat(&quot;cat&quot;);

/**
 * Demo : polymorphism 101
 * Animal &lt;= Cat
 */
animal = cat; // Okay
cat = animal; // ERROR: cat extends animal

/** Array of each to demonstrate variance */
let animalArr: Animal[] = [animal];
let catArr: Cat[] = [cat];

/**
 * Obviously Bad : Contravariance
 * Animal &lt;= Cat
 * Animal[] &gt;= Cat[]
 */
catArr = animalArr; // Okay if contravariant
catArr[0].meow(); // Allowed but BANG 🔫 at runtime


/**
 * Also Bad : covariance
 * Animal &lt;= Cat
 * Animal[] &lt;= Cat[]
 */
animalArr = catArr; // Okay if covariant
animalArr.push(new Animal('another animal')); // Just pushed an animal into catArr!
catArr.forEach(c =&gt; c.meow()); // Allowed but BANG 🔫 at runtime
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-signatures"><a class="header" href="#index-signatures">Index Signatures</a></h1>
<p>An <code>Object</code> in JavaScript (and hence TypeScript) can be accessed with a <strong>string</strong> to hold a reference to any other JavaScript <strong>object</strong>.</p>
<p>Here is a quick example:</p>
<pre><code class="language-typescript">let foo: any = {};
foo['Hello'] = 'World';
console.log(foo['Hello']); // World
</code></pre>
<p>We store a string <code>&quot;World&quot;</code> under the key <code>&quot;Hello&quot;</code>. Remember we said it can store any JavaScript <strong>object</strong>, so lets store a class instance just to show the concept:</p>
<pre><code class="language-typescript">class Foo {
  constructor(public message: string){};
  log(){
    console.log(this.message)
  }
}

let foo: any = {};
foo['Hello'] = new Foo('World');
foo['Hello'].log(); // World
</code></pre>
<p>Also remember that we said that it can be accessed with a <strong>string</strong>. If you pass any other object to the index signature the JavaScript runtime actually calls <code>.toString</code> on it before getting the result. This is demonstrated below:</p>
<pre><code class="language-typescript">let obj = {
  toString(){
    console.log('toString called')
    return 'Hello'
  }
}

let foo: any = {};
foo[obj] = 'World'; // toString called
console.log(foo[obj]); // toString called, World
console.log(foo['Hello']); // World
</code></pre>
<p>Note that <code>toString</code> will get called whenever the <code>obj</code> is used in an index position.</p>
<p>Arrays are slightly different. For <code>number</code> indexing JavaScript VMs will try to optimise (depending on things like is it actually an array and do the structures of items stored match etc.). So <code>number</code> should be considered as a valid object accessor in its own right (distinct from <code>string</code>). Here is a simple array example:</p>
<pre><code class="language-typescript">let foo = ['World'];
console.log(foo[0]); // World
</code></pre>
<p>So that’s JavaScript. Now let’s look at TypeScript’s graceful handling of this concept.</p>
<h2 id="typescript-index-signature"><a class="header" href="#typescript-index-signature">TypeScript Index Signature</a></h2>
<p>First off, because JavaScript <em>implicitly</em> calls <code>toString</code> on any object index signature, TypeScript will give you an error to prevent beginners from shooting themselves in the foot (I see users shooting themselves in the foot when using JavaScript all the time on stackoverflow):</p>
<pre><code class="language-typescript">let obj = {
  toString(){
    return 'Hello'
  }
}

let foo: any = {};

// ERROR: the index signature must be string, number ...
foo[obj] = 'World';

// FIX: TypeScript forces you to be explicit
foo[obj.toString()] = 'World';
</code></pre>
<p>The reason for forcing the user to be explicit is because the default <code>toString</code> implementation on an object is pretty awful, e.g. on v8 it always returns <code>[object Object]</code>:</p>
<pre><code class="language-typescript">let obj = {message:'Hello'}
let foo: any = {};

// ERROR: the index signature must be string, number ...
foo[obj] = 'World';

// Here is where you actually stored it!
console.log(foo[&quot;[object Object]&quot;]); // World
</code></pre>
<p>Of course <code>number</code> is supported because</p>
<ol>
<li>its needed for excellent Array / Tuple support.</li>
<li>even if you use it for an <code>obj</code> its default <code>toString</code> implementation is nice (not <code>[object Object]</code>).</li>
</ol>
<p>Point 2 is shown below:</p>
<pre><code class="language-typescript">console.log((1).toString()); // 1
console.log((2).toString()); // 2
</code></pre>
<p>So lesson 1:</p>
<blockquote>
<p>TypeScript index signatures must be either <code>string</code> or <code>number</code></p>
</blockquote>
<p>Quick note: <code>symbols</code> are also valid and supported by TypeScript. But let’s not go there just yet. Baby steps.</p>
<h3 id="declaring-an-index-signature"><a class="header" href="#declaring-an-index-signature">Declaring an index signature</a></h3>
<p>So we’ve been using <code>any</code> to tell TypeScript to let us do whatever we want. We can actually specify an <em>index</em> signature explicitly. E.g. say you want to make sure that anything that is stored in an object using a string conforms to the structure <code>{message: string}</code>. This can be done with the declaration <code>{ [index:string] : {message: string} }</code>. This is demonstrated below:</p>
<pre><code class="language-typescript">let foo:{ [index:string] : {message: string} } = {};

/**
 * Must store stuff that conforms to the structure
 */
/** Ok */
foo['a'] = { message: 'some message' };
/** Error: must contain a `message` of type string. You have a typo in `message` */
foo['a'] = { messages: 'some message' };

/**
 * Stuff that is read is also type checked
 */
/** Ok */
foo['a'].message;
/** Error: messages does not exist. You have a typo in `message` */
foo['a'].messages;
</code></pre>
<blockquote>
<p>TIP: the name of the index signature e.g. <code>index</code> in <code>{ [index:string] : {message: string} }</code> has no significance for TypeScript and is only for readability. e.g. if it’s user names you can do <code>{ [username:string] : {message: string} }</code> to help the next dev who looks at the code (which just might happen to be you).</p>
</blockquote>
<p>Of course <code>number</code> indexes are also supported e.g. <code>{ [count: number] : SomeOtherTypeYouWantToStoreEgRebate }</code></p>
<h3 id="all-members-must-conform-to-the-string-index-signature"><a class="header" href="#all-members-must-conform-to-the-string-index-signature">All members must conform to the <code>string</code> index signature</a></h3>
<p>As soon as you have a <code>string</code> index signature, all explicit members must also conform to that index signature. This is shown below:</p>
<pre><code class="language-typescript">/** Okay */
interface Foo {
  [key:string]: number;
  x: number;
  y: number;
}
/** Error */
interface Bar {
  [key:string]: number;
  x: number;
  y: string; // ERROR: Property `y` must be of type number
}
</code></pre>
<p>This is to provide safety so that any string access gives the same result:</p>
<pre><code class="language-typescript">interface Foo {
  [key:string]: number;
  x: number;
}
let foo: Foo = {x:1,y:2};

// Directly
foo['x']; // number

// Indirectly
let x = 'x'
foo[x]; // number
</code></pre>
<h3 id="using-a-limited-set-of-string-literals"><a class="header" href="#using-a-limited-set-of-string-literals">Using a limited set of string literals</a></h3>
<p>An index signature can require that index strings be members of a union of literal strings by using <em>Mapped Types</em> e.g.:</p>
<pre><code class="language-typescript">type Index = 'a' | 'b' | 'c'
type FromIndex = { [k in Index]?: number }

const good: FromIndex = {b:1, c:2}

// Error:
// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.
// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.
const bad: FromIndex = {b:1, c:2, d:3};
</code></pre>
<p>This is often used together with <code>keyof typeof</code> to capture vocabulary types, described on the next page.</p>
<p>The specification of the vocabulary can be deferred generically:</p>
<pre><code class="language-typescript">type FromSomeIndex&lt;K extends string&gt; = { [key in K]: number }
</code></pre>
<h3 id="having-both-string-and-number-indexers"><a class="header" href="#having-both-string-and-number-indexers">Having both <code>string</code> and <code>number</code> indexers</a></h3>
<p>This is not a common use case, but TypeScript compiler supports it nonetheless.</p>
<p>However, it has the restriction that the <code>string</code> indexer is more strict than the <code>number</code> indexer. This is intentional e.g. to allow typing stuff like:</p>
<pre><code class="language-typescript">interface ArrStr {
  [key: string]: string | number; // Must accommodate all members

  [index: number]: string; // Can be a subset of string indexer

  // Just an example member
  length: number;
}
</code></pre>
<h3 id="design-pattern-nested-index-signature"><a class="header" href="#design-pattern-nested-index-signature">Design Pattern: Nested index signature</a></h3>
<blockquote>
<p>API consideration when adding index signatures</p>
</blockquote>
<p>Quite commonly in the JS community you will see APIs that abuse string indexers. e.g. a common pattern among CSS in JS libraries:</p>
<pre><code class="language-typescript">interface NestedCSS {
  color?: string;
  [selector: string]: string | NestedCSS | undefined;
}

const example: NestedCSS = {
  color: 'red',
  '.subclass': {
    color: 'blue'
  }
}
</code></pre>
<p>Try not to mix string indexers with <em>valid</em> values this way. E.g. a typo in the padding will remain uncaught:</p>
<pre><code class="language-typescript">const failsSilently: NestedCSS = {
  colour: 'red', // No error as `colour` is a valid string selector
}
</code></pre>
<p>Instead separate out the nesting into its own property e.g. in a name like <code>nest</code> (or <code>children</code> or <code>subnodes</code> etc.):</p>
<pre><code class="language-typescript">interface NestedCSS {
  color?: string;
  nest?: {
    [selector: string]: NestedCSS;
  }
}

const example: NestedCSS = {
  color: 'red',
  nest: {
    '.subclass': {
      color: 'blue'
    }
  }
}

const failsSilently: NestedCSS = {
  colour: 'red', // TS Error: unknown property `colour`
}
</code></pre>
<h3 id="excluding-certain-properties-from-the-index-signature"><a class="header" href="#excluding-certain-properties-from-the-index-signature">Excluding certain properties from the index signature</a></h3>
<p>Sometimes you need to combine properties into the index signature. This is not advised, and you <em>should</em> use the Nested index signature pattern mentioned above. </p>
<p>However, if you are modeling <em>existing JavaScript</em> you can get around it with an intersection type. The following shows an example of the error you will encounter without using an intersection:</p>
<pre><code class="language-typescript">type FieldState = {
  value: string
}

type FormState = {
  isValid: boolean  // Error: Does not conform to the index signature
  [fieldName: string]: FieldState
}
</code></pre>
<p>Here is the workaround using an intersection type:</p>
<pre><code class="language-typescript">type FieldState = {
  value: string
}

type FormState =
  { isValid: boolean }
  &amp; { [fieldName: string]: FieldState }
</code></pre>
<p>Note that even though you can declare it to model existing JavaScript, you cannot create such an object using TypeScript:</p>
<pre><code class="language-typescript">type FieldState = {
  value: string
}

type FormState =
  { isValid: boolean }
  &amp; { [fieldName: string]: FieldState }


// Use it for some JavaScript object you are getting from somewhere 
declare const foo:FormState; 

const isValidBool = foo.isValid;
const somethingFieldState = foo['something'];

// Using it to create a TypeScript object will not work
const bar: FormState = { // Error `isValid` not assignable to `FieldState
  isValid: false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-types"><a class="header" href="#moving-types">Moving Types</a></h1>
<p>TypeScript’s type system is extremely powerful and allows moving and slicing types in ways not possible in any other single language out there.</p>
<p>This is because TypeScript is designed to allow you to work seamlessly with a <em>highly dynamic</em> language like JavaScript. Here we cover a few tricks for moving types around in TypeScript.</p>
<p>Key motivation for these : You change one thing and everything else just updates automatically and you get nice errors if something is going to break, like a well designed constraint system.</p>
<h2 id="copying-both-the-type--value"><a class="header" href="#copying-both-the-type--value">Copying both the Type + Value</a></h2>
<p>If you want to move a class around, you might be tempted to do the following:</p>
<pre><code class="language-typescript">class Foo { }
var Bar = Foo;
var bar: Bar; // ERROR: cannot find name 'Bar'
</code></pre>
<p>This is an error because <code>var</code> only copied the <code>Foo</code> into the <em>variable</em> declaration space and you therefore cannot use <code>Bar</code> as a type annotation. The proper way is to use the <code>import</code> keyword. Note that you can only use the <code>import</code> keyword in such a way if you are using <em>namespaces</em> or <em>modules</em> (more on these later):</p>
<pre><code class="language-typescript">namespace importing {
    export class Foo { }
}

import Bar = importing.Foo;
var bar: Bar; // Okay
</code></pre>
<p>This <code>import</code> trick only works for things that are <em>both type and variable</em>.</p>
<h2 id="capturing-the-type-of-a-variable"><a class="header" href="#capturing-the-type-of-a-variable">Capturing the type of a variable</a></h2>
<p>You can actually use a variable in a type annotation using the <code>typeof</code> operator. This allows you to tell the compiler that one variable is the same type as another. Here is an example to demonstrate this:</p>
<pre><code class="language-typescript">var foo = 123;
var bar: typeof foo; // `bar` has the same type as `foo` (here `number`)
bar = 456; // Okay
bar = '789'; // ERROR: Type `string` is not `assignable` to type `number`
</code></pre>
<h2 id="capturing-the-type-of-a-class-member"><a class="header" href="#capturing-the-type-of-a-class-member">Capturing the type of a class member</a></h2>
<p>You can traverse into any non-nullable object type to retrieve the type of a property:</p>
<pre><code class="language-typescript">class Foo {
  foo: number; // some member whose type we want to capture
}

let bar: Foo['foo']; // `bar` has type `number`
</code></pre>
<p>Alternatively, similar to capturing the type of a variable, you just declare a variable purely for type capturing purposes:</p>
<pre><code class="language-typescript">// Purely to capture type
declare let _foo: Foo;

// Same as before
let bar: typeof _foo.foo; // `bar` has type `number`
</code></pre>
<h2 id="capturing-the-type-of-magic-strings"><a class="header" href="#capturing-the-type-of-magic-strings">Capturing the type of magic strings</a></h2>
<p>Lots of JavaScript libraries and frameworks work off of raw JavaScript strings. You can use <code>const</code> variables to capture their type e.g.</p>
<pre><code class="language-typescript">// Capture both the *type* _and_ *value* of magic string:
const foo = &quot;Hello World&quot;;

// Use the captured type:
let bar: typeof foo;

// bar can only ever be assigned to `Hello World`
bar = &quot;Hello World&quot;; // Okay!
bar = &quot;anything else &quot;; // Error!
</code></pre>
<p>In this example <code>bar</code> has the literal type <code>&quot;Hello World&quot;</code>. We cover this more in the <a href="types/./literal-types.html">literal type section</a>.</p>
<h2 id="capturing-key-names"><a class="header" href="#capturing-key-names">Capturing Key Names</a></h2>
<p>The <code>keyof</code> operator lets you capture the key names of a type. E.g. you can use it to capture the key names of a variable by first grabbing its type using <code>typeof</code>:</p>
<pre><code class="language-typescript">const colors = {
  red: 'reddish',
  blue: 'bluish'
}
type Colors = keyof typeof colors;

let color: Colors; // same as let color: &quot;red&quot; | &quot;blue&quot;
color = 'red'; // okay
color = 'blue'; // okay
color = 'anythingElse'; // Error: Type '&quot;anythingElse&quot;' is not assignable to type '&quot;red&quot; | &quot;blue&quot;'
</code></pre>
<p>This allows you to have stuff like string enums + constants quite easily, as you just saw in the above example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixins"><a class="header" href="#mixins">Mixins</a></h1>
<p>TypeScript (and JavaScript) classes support strict single inheritance. So you <em>cannot</em> do:</p>
<pre><code class="language-typescript">class User extends Tagged, Timestamped { // ERROR : no multiple inheritance
}
</code></pre>
<p>Another way of building up classes from reusable components is to build them by combining simpler partial classes called mixins.</p>
<p>The idea is simple, instead of a <em>class A extending class B</em> to get its functionality, <em>function B takes class A</em> and returns a new class with this added functionality. Function <code>B</code> is a mixin.</p>
<blockquote>
<p>[A mixin is] a function that</p>
<ol>
<li>takes a constructor,</li>
<li>creates a class that extends that constructor with new functionality</li>
<li>returns the new class</li>
</ol>
</blockquote>
<p>A complete example</p>
<pre><code class="language-typescript">// Needed for all mixins
type Constructor&lt;T = {}&gt; = new (...args: any[]) =&gt; T;

////////////////////
// Example mixins
////////////////////

// A mixin that adds a property
function Timestamped&lt;TBase extends Constructor&gt;(Base: TBase) {
  return class extends Base {
    timestamp = Date.now();
  };
}

// a mixin that adds a property and methods
function Activatable&lt;TBase extends Constructor&gt;(Base: TBase) {
  return class extends Base {
    isActivated = false;

    activate() {
      this.isActivated = true;
    }

    deactivate() {
      this.isActivated = false;
    }
  };
}

////////////////////
// Usage to compose classes
////////////////////

// Simple class
class User {
  name = '';
}

// User that is Timestamped
const TimestampedUser = Timestamped(User);

// User that is Timestamped and Activatable
const TimestampedActivatableUser = Timestamped(Activatable(User));

////////////////////
// Using the composed classes
////////////////////

const timestampedUserExample = new TimestampedUser();
console.log(timestampedUserExample.timestamp);

const timestampedActivatableUserExample = new TimestampedActivatableUser();
console.log(timestampedActivatableUserExample.timestamp);
console.log(timestampedActivatableUserExample.isActivated);

</code></pre>
<p>Let’s decompose this example.</p>
<h2 id="take-a-constructor"><a class="header" href="#take-a-constructor">Take a constructor</a></h2>
<p>Mixins take a class and extend it with new functionality. So we need to define what is a <em>constructor</em>. Easy as:</p>
<pre><code class="language-typescript">// Needed for all mixins
type Constructor&lt;T = {}&gt; = new (...args: any[]) =&gt; T;
</code></pre>
<h2 id="extend-the-class-and-return-it"><a class="header" href="#extend-the-class-and-return-it">Extend the class and return it</a></h2>
<p>Pretty easy:</p>
<pre><code class="language-typescript">// A mixin that adds a property
function Timestamped&lt;TBase extends Constructor&gt;(Base: TBase) {
  return class extends Base {
    timestamp = Date.now();
  };
}
</code></pre>
<p>And that is it 🌹</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>TypeScript provides dedicated type syntax for arrays to make it easier for you to annotate and document your code. The syntax is basically postfixing <code>[]</code> to any valid type annotation (e.g. <code>:boolean[]</code>). It allows you to safely do any array manipulation that you would normally do and protects you from errors like assigning a member of the wrong type.  This is demonstrated below:</p>
<pre><code class="language-typescript">var boolArray: boolean[];

boolArray = [true, false];
console.log(boolArray[0]); // true
console.log(boolArray.length); // 2
boolArray[1] = true;
boolArray = [false, false];

boolArray[0] = 'false'; // Error!
boolArray = 'false'; // Error!
boolArray = [true, 'false']; // Error!
</code></pre>
<h2 id="creating-arrays"><a class="header" href="#creating-arrays">Creating arrays</a></h2>
<p>Creating an empty array is super easy: </p>
<pre><code class="language-typescript">const foo: string[] = [];
</code></pre>
<p>If you want an array to loop over: </p>
<pre><code class="language-typescript">[...new Array(6)]; 
</code></pre>
<p>If you want to create an array pre-filled with some content use the ES6 <code>Array.prototype.fill</code>: </p>
<pre><code class="language-typescript">const foo: string[] = new Array(3).fill('');
console.log(foo); // ['','',''];
</code></pre>
<p>If you want to create an array of a predefined length with calls you can use the spread operator: </p>
<p><code>&gt;tags:</code> #Loop_Over [[Array]] #Map [[Important]] #Triple_Dot</p>
<pre><code class="language-typescript">const someNumbers = [...new Array(3)].map((_,i) =&gt; i * 10);
console.log(someNumbers); // [0,10,20];
</code></pre>
<h2 id="index-signatures-1"><a class="header" href="#index-signatures-1">Index Signatures</a></h2>
<p>In TypeScript we can use as index signature <code>string</code>, <code>number</code>, and <code>symbol</code>:</p>
<pre><code class="language-typescript">type K = {
    [name: string | number]: string;
};
const k: K = { x: 'x', 1: 'b' };
console.log(k['x']);
console.log(k[1]);
console.log(k['1']); // Same result as k[1]
</code></pre>
<p>Please note that JavaScript automatically converts an index with <code>number</code> to an index with <code>string</code> so <code>k[1]</code> or <code>k[&quot;1&quot;]</code> return the same value.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapped-types-1"><a class="header" href="#mapped-types-1">Mapped Types</a></h2>
<p>Mapped Types in TypeScript allow you to create new types based on an existing type by transforming each property using a mapping function. By mapping existing types, you can create new types that represent the same information in a different format. To create a mapped type, you access the properties of an existing type using the <code>keyof</code> operator and then alter them to produce a new type.
In the following example:</p>
<pre><code class="language-typescript">type MyMappedType&lt;T&gt; = {
    [P in keyof T]: T[P][];
};
type MyType = {
    foo: string;
    bar: number;
};
type MyNewType = MyMappedType&lt;MyType&gt;;
const x: MyNewType = {
    foo: ['hello', 'world'],
    bar: [1, 2, 3],
};
</code></pre>
<p>we define MyMappedType to map over T’s properties, creating a new type with each property as an array of its original type. Using this, we create MyNewType to represent the same info as MyType, but with each property as an array.</p>
<h2 id="mapped-type-modifiers"><a class="header" href="#mapped-type-modifiers">Mapped Type Modifiers</a></h2>
<p>Mapped Type Modifiers in TypeScript enable the transformation of properties within an existing type:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>readonly</code> or <code>+readonly</code>: This renders a property in the mapped type as read-only.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>-readonly</code>: This allows a property in the mapped type to be mutable.</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>?</code>: This designates a property in the mapped type as optional.</li>
</ul>
<p><code>&gt;tags:</code> [[Important]] [[Map]] [[modifier]] [[readonly]]</p>
<p>Examples:</p>
<pre><code class="language-typescript">type ReadOnly&lt;T&gt; = { readonly [P in keyof T]: T[P] }; // All properties marked as read-only

type Mutable&lt;T&gt; = { -readonly [P in keyof T]: T[P] }; // All properties marked as mutable

type MyPartial&lt;T&gt; = { [P in keyof T]?: T[P] }; // All properties marked as optional
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="iterators-and-generators"><a class="header" href="#iterators-and-generators">Iterators and Generators</a></h3>
<p>Both Interators and Generators are well supported in TypeScript.</p>
<p>Iterators are objects that implement the iterator protocol, providing a way to access elements of a collection or sequence one by one. It is a structure that contains a pointer to the next element in the iteration. They have a <code>next()</code> method that returns the next value in the sequence along with a boolean indicating if the sequence is <code>done</code>.</p>
<pre><code class="language-typescript">class NumberIterator implements Iterable&lt;number&gt; {
    private current: number;

    constructor(
        private start: number,
        private end: number
    ) {
        this.current = start;
    }

    public next(): IteratorResult&lt;number&gt; {
        if (this.current &lt;= this.end) {
            const value = this.current;
            this.current++;
            return { value, done: false };
        } else {
            return { value: undefined, done: true };
        }
    }

    [Symbol.iterator](): Iterator&lt;number&gt; {
        return this;
    }
}

const iterator = new NumberIterator(1, 3);

for (const num of iterator) {
    console.log(num);
}
</code></pre>
<p>Generators are special functions defined using the <code>function*</code> syntax that simplifies the creation of iterators. They use the <code>yield</code> keyword to define the sequence of values and automatically pause and resume execution when values are requested.</p>
<p>Generators make it easier to create iterators and are especially useful for working with large or infinite sequences.</p>
<p>Example:</p>
<pre><code class="language-typescript">function- [x] numberGenerator(start: number, end: number): Generator&lt;number&gt; {
    for (let i = start; i &lt;= end; i++) {
        yield i;
    }
}

const generator = numberGenerator(1, 5);

for (const num of generator) {
    console.log(num);
}
</code></pre>
<p>Iterator itself is not a TypeScript or ES6 feature, Iterator is a Behavioral Design Pattern common for Object oriented programming languages. It is, generally, an object which implements the following interface:</p>
<pre><code class="language-typescript">interface Iterator&lt;T&gt; {
    next(value?: any): IteratorResult&lt;T&gt;;
    return?(value?: any): IteratorResult&lt;T&gt;;
    throw?(e?: any): IteratorResult&lt;T&gt;;
}
</code></pre>
<p>([More on that <code>&lt;T&gt;</code> notation later][generics])<br />
This interface allows to retrieve a value from some collection or sequence
which belongs to the object.</p>
<p>The <code>IteratorResult</code> is simply a <code>value</code>+<code>done</code> pair: </p>
<pre><code class="language-typescript">interface IteratorResult&lt;T&gt; {
    done: boolean;
    value: T;
}
</code></pre>
<p>Imagine that there’s an object of some frame, which includes the list of components of which this frame consists. With Iterator interface it is possible to retrieve components from this frame object like below:</p>
<pre><code class="language-typescript">class Component {
  constructor (public name: string) {}
}

class Frame implements Iterator&lt;Component&gt; {

  private pointer = 0;

  constructor(public name: string, public components: Component[]) {}

  public next(): IteratorResult&lt;Component&gt; {
    if (this.pointer &lt; this.components.length) {
      return {
        done: false,
        value: this.components[this.pointer++]
      }
    } else {
      return {
        done: true,
        value: null
      }
    }
  }

}

let frame = new Frame(&quot;Door&quot;, [new Component(&quot;top&quot;), new Component(&quot;bottom&quot;), new Component(&quot;left&quot;), new Component(&quot;right&quot;)]);
let iteratorResult1 = frame.next(); //{ done: false, value: Component { name: 'top' } }
let iteratorResult2 = frame.next(); //{ done: false, value: Component { name: 'bottom' } }
let iteratorResult3 = frame.next(); //{ done: false, value: Component { name: 'left' } }
let iteratorResult4 = frame.next(); //{ done: false, value: Component { name: 'right' } }
let iteratorResult5 = frame.next(); //{ done: true, value: null }

//It is possible to access the value of iterator result via the value property:
let component = iteratorResult1.value; //Component { name: 'top' }
</code></pre>
<p>Again. Iterator itself is not a TypeScript feature, this code could work without implementing Iterator and IteratorResult interfaces explicitly. However, it is very helpful to use these common ES6 <a href="collection/../oop/interfaces.html">interfaces</a> for code consistency.</p>
<p>Ok, Nice, but could be more helpful. ES6 defines the <em>iterable protocol</em> which includes the [Symbol.iterator] <code>symbol</code> if the Iterable interface is implemented:</p>
<pre><code class="language-typescript">//...
class Frame implements Iterable&lt;Component&gt; {

  constructor(public name: string, public components: Component[]) {}

  [Symbol.iterator]() {
    let pointer = 0;
    let components = this.components;

    return {
      next(): IteratorResult&lt;Component&gt; {
        if (pointer &lt; components.length) {
          return {
            done: false,
            value: components[pointer++]
          }
        } else {
          return {
            done: true,
            value: null
          }
        }
      }
    }
  }
}

let frame = new Frame(&quot;Door&quot;, [new Component(&quot;top&quot;), new Component(&quot;bottom&quot;), new Component(&quot;left&quot;), new Component(&quot;right&quot;)]);
for (let cmp of frame) {
  console.log(cmp);
}

</code></pre>
<p>Unfortunately <code>frame.next()</code> won’t work with this pattern and it also looks a bit clunky. IterableIterator interface to the rescue!</p>
<pre><code class="language-typescript">//...
class Frame implements IterableIterator&lt;Component&gt; {

  private pointer = 0;

  constructor(public name: string, public components: Component[]) {}

  public next(): IteratorResult&lt;Component&gt; {
    if (this.pointer &lt; this.components.length) {
      return {
        done: false,
        value: this.components[this.pointer++]
      }
    } else {
      return {
        done: true,
        value: null
      }
    }
  }

  [Symbol.iterator](): IterableIterator&lt;Component&gt; {
    return this;
  }

}
//...

</code></pre>
<p>Both <code>frame.next()</code> and <code>for</code> cycle now work fine with IterableIterator interface.</p>
<p>Iterator does not have to iterate a finite value.
The typical example is a Fibonacci sequence:</p>
<p><code>&gt;tags:</code> [[Important]] [[Fib]] [[Fibonacci]] [[IterableIterator]] [[Iterator]] [[Symbol]]</p>
<pre><code class="language-typescript">class Fib implements IterableIterator&lt;number&gt; {

  protected fn1 = 0;
  protected fn2 = 1;

  constructor(protected maxValue?: number) {}

  public next(): IteratorResult&lt;number&gt; {
    var current = this.fn1;
    this.fn1 = this.fn2;
    this.fn2 = current + this.fn1;
    if (this.maxValue != null &amp;&amp; current &gt;= this.maxValue) {
      return {
        done: true,
        value: null
      } 
    } 
    return {
      done: false,
      value: current
    }
  }

  [Symbol.iterator](): IterableIterator&lt;number&gt; {
    return this;
  }

}

let fib = new Fib();

fib.next() //{ done: false, value: 0 }
fib.next() //{ done: false, value: 1 }
fib.next() //{ done: false, value: 1 }
fib.next() //{ done: false, value: 2 }
fib.next() //{ done: false, value: 3 }
fib.next() //{ done: false, value: 5 }

let fibMax50 = new Fib(50);
console.log(Array.from(fibMax50)); // [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]

let fibMax21 = new Fib(21);
for(let num of fibMax21) {
  console.log(num); //Prints fibonacci sequence 0 to 21
}
</code></pre>
<h3 id="the-for-await-of-statement"><a class="header" href="#the-for-await-of-statement">The for-await-of Statement</a></h3>
<p>This is a JavaScript feature fully supported in TypeScript which allows you to iterate over asynchronous iterable objects from target version es2018.</p>
<pre><code class="language-typescript">async function- [x] asyncNumbers(): AsyncIterableIterator&lt;number&gt; {
    yield Promise.resolve(1);
    yield Promise.resolve(2);
    yield Promise.resolve(3);
}

(async () =&gt; {
    for await (const num of asyncNumbers()) {
        console.log(num);
    }
})();
</code></pre>
<h3 id="building-code-with-iterators-for-es5-target"><a class="header" href="#building-code-with-iterators-for-es5-target">Building code with iterators for ES5 target</a></h3>
<p>Code examples above require ES6 target. However, it could work with ES5 target as well if target JS engine supports <code>Symbol.iterator</code>. This can be achieved by using ES6 lib with ES5 target (add es6.d.ts to your project) to make it compile. Compiled code should work in node 4+, Google Chrome and in some other browsers.</p>
<p>TypeScript also supports async iterators and async Generators.</p>
<p>To learn more:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a><br />
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator</a></p>
<p><a href="collection/../types/generic/generic.html">generics</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generators"><a class="header" href="#generators">Generators</a></h2>
<p><code>function *</code> is the syntax used to create a <strong>generator function</strong>. Calling a generator function returns a <em>generator object</em>. The generator object just follows the iterator interface (i.e. the <code>next</code>, <code>return</code> and <code>throw</code> functions). </p>
<p>There are two key motivations behind generator functions: </p>
<h3 id="lazy-iterators"><a class="header" href="#lazy-iterators">Lazy Iterators</a></h3>
<p>Generator functions can be used to create <strong>lazy iterators</strong> e.g. the following function returns an <strong>infinite</strong> list of integers on demand:</p>
<pre><code class="language-typescript">function* infiniteSequence() {
    var i = 0;
    while(true) {
        yield i++;
    }
}

var iterator = infiniteSequence();
while (true) {
    console.log(iterator.next()); // { value: xxxx, done: false } forever and ever
}
</code></pre>
<p>Of course if the iterator does end, you get the result of <code>{ done: true }</code> as demonstrated below:</p>
<pre><code class="language-typescript">function* idMaker(){
  let index = 0;
  while(index &lt; 3)
    yield index++;
}

let gen = idMaker();

console.log(gen.next()); // { value: 0, done: false }
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { done: true }
</code></pre>
<h3 id="externally-controlled-execution"><a class="header" href="#externally-controlled-execution">Externally Controlled Execution</a></h3>
<p>This is the part of generators that is truly exciting. It essentially allows a function to pause its execution and pass control (fate) of the remainder of the function execution to the caller.</p>
<p><code>&gt;tags:</code> [[Important]] [[Yield]] [[Generator]]</p>
<p><strong>A generator function does not execute when you call it. It just creates a generator object</strong>. Consider the following example along with a sample execution:</p>
<pre><code class="language-typescript">function* generator(){
    console.log('Execution started');
    yield 0;
    console.log('Execution resumed');
    yield 1;
    console.log('Execution resumed');
}

var iterator = generator();
console.log('Starting iteration'); // This will execute before anything in the generator function body executes
console.log(iterator.next()); // { value: 0, done: false }
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
</code></pre>
<p>If you run this you get the following output:</p>
<pre><code class="language-bash">node outside.js
Starting iteration
Execution started
{ value: 0, done: false }
Execution resumed
{ value: 1, done: false }
Execution resumed
{ value: undefined, done: true }
</code></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The function only starts execution once <code>next</code> is called on the generator object.</li>
<li><input disabled="" type="checkbox" checked=""/>
The function <strong>pauses</strong> as soon as a <code>yield</code> statement is encountered.</li>
<li><input disabled="" type="checkbox" checked=""/>
The function <strong>resumes</strong> when <code>next</code> is called.</li>
</ul>
<blockquote>
<p>So essentially the execution of the generator function is controllable by the generator object.</p>
</blockquote>
<p>Our communication using the generator has been mostly one way with the generator returning values for the iterator. One extremely powerful feature of generators in JavaScript is that they allow two way communications (with caveats).</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
you can <strong>control</strong> the resulting value of the <strong><code>yield</code></strong> expression using <code>iterator.next(valueToInject)</code></li>
<li><input disabled="" type="checkbox" checked=""/>
you can throw an exception at the point of the <code>yield</code> expression using <code>iterator.throw(error)</code></li>
</ul>
<p>The following example demonstrates <code>iterator.next(valueToInject)</code>:</p>
<pre><code class="language-typescript">function* generator() {
    const bar = yield 'foo'; // bar may be *any* type
    console.log(bar); // bar!
}

const iterator = generator();
// Start execution till we get first yield value
const foo = iterator.next();
console.log(foo.value); // foo
// Resume execution injecting bar
const nextThing = iterator.next('bar');
</code></pre>
<p>Since <code>yield</code> returns the parameter passed to the iterator’s <code>next</code> function, and all iterators’ <code>next</code> functions accept a parameter of any type, <strong>TypeScript will always assign the <code>any</code> type to the result of the <code>yield</code> operator (<code>bar</code> above).</strong></p>
<blockquote>
<p>You are on your own to coerce the result to the type you expect, and ensure that only values of that type are passed to next (such as by scaffolding an additional type-enforcement layer that calls <code>next</code> for you.) If strong typing is important to you, you may want to avoid two-way communication altogether, as well as packages that rely heavily on it (e.g., redux-saga).</p>
</blockquote>
<p>The following example demonstrates <code>iterator.throw(error)</code>:</p>
<pre><code class="language-typescript">function* generator() {
    try {
        yield 'foo';
    }
    catch(err) {
        console.log(err.message); // bar!
    }
}

var iterator = generator();
// Start execution till we get first yield value
var foo = iterator.next();
console.log(foo.value); // foo
// Resume execution throwing an exception 'bar'
var nextThing = iterator.throw(new Error('bar'));
</code></pre>
<p>So here is the summary:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>yield</code> allows a generator function to pause its communication and pass control to an external system</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>the external system can push a value into the generator function body</strong></li>
<li><input disabled="" type="checkbox" checked=""/>
the external system can throw an exception into the generator function body</li>
</ul>
<p>How is this useful? Jump to the next section <a href="collection/../async/async.html"><strong>async/await</strong></a> and find out.</p>
<p><a href="collection/../collection/iterators.html">iterator</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>TypeScript is a superset of JavaScript, so the “class” keyword can be used as a type and value at runtime.</p>
<h2 id="differences-between-type-and-interface"><a class="header" href="#differences-between-type-and-interface">Differences between Type and Interface</a></h2>
<p>Declaration merging (augmentation):</p>
<p><strong>Interfaces support declaration merging</strong>, which means that you can define multiple interfaces with the same name, and TypeScript will merge them into a single interface with the combined properties and methods. On the other hand, <strong>types do not support declaration merging</strong>. This can be helpful when you want to add extra functionality or customize existing types without modifying the original definitions or patching missing or incorrect types.</p>
<pre><code class="language-typescript">interface A { //Writing Type instead of interface causes error
    x: string;
}
interface A { //Writing Type instead of interface causes error
    y: string;
}
const j: A = {
    x: 'xx',
    y: 'yy',
};
</code></pre>
<p>Extending other types/interfaces:</p>
<p>Both types and interfaces can extend other types/interfaces, but the syntax is different. With interfaces, you use the <code>extends</code> keyword to inherit properties and methods from other interfaces. However, <strong>an interface cannot extend a complex type like a union type.</strong></p>
<pre><code class="language-typescript">interface A {
    x: string;
    y: number;
}
interface B extends A {
    z: string;
}
const car: B = {
    x: 'x',
    y: 123,
    z: 'z',
};
</code></pre>
<p>For types, you use the &amp; operator to combine multiple types into a single type (intersection).</p>
<pre><code class="language-typescript">interface A {
    x: string;
    y: number;
}

type B = A &amp; {
    j: string;
};

const c: B = {
    x: 'x',
    y: 123,
    j: 'j',
};
</code></pre>
<h3 id="union-and-intersection-types"><a class="header" href="#union-and-intersection-types">Union and Intersection Types</a></h3>
<p>Types are more flexible when it comes to defining Union and Intersection Types. With the <code>type</code> keyword, you can easily create union types using the <code>|</code> operator and intersection types using the <code>&amp;</code> operator. <strong>While interfaces can also represent union types indirectly, they don’t have built-in support for intersection types.</strong></p>
<pre><code class="language-typescript">type Department = 'dep-x' | 'dep-y'; // Union

type Person = {
    name: string;
    age: number;
};

type Employee = {
    id: number;
    department: Department;
};

type EmployeeInfo = Person &amp; Employee; // Intersection
</code></pre>
<p>Example with interfaces:</p>
<pre><code class="language-typescript">interface A {
    x: 'x';
}
interface B {
    y: 'y';
}

type C = A | B; // Union of interfaces
</code></pre>
<pre><code class="language-typescript">class Animal {
    constructor(public name: string) {}
}
class Dog extends Animal {
    constructor(
        public name: string,
        public bark: () =&gt; void
    ) {
        super(name);
    }
}
class Cat extends Animal {
    constructor(
        public name: string,
        public meow: () =&gt; void
    ) {
        super(name);
    }
}
type Mammal = Dog | Cat;

const makeNoise = (mammal: Mammal) =&gt; {
    if (mammal instanceof Dog) {
        mammal.bark();
    } else {
        mammal.meow();
    }
};

const dog = new Dog('Fido', () =&gt; console.log('bark'));
makeNoise(dog);
</code></pre>
<p>In JavaScript, a “class” has a “prototype” property, and the “instanceof” operator can be used to test if the prototype property of a constructor appears anywhere in the prototype chain of an object.</p>
<p>TypeScript has no effect on runtime performance, as all types will be erased. However, TypeScript does introduce some build time overhead.</p>
<h2 id="future-javascript--now"><a class="header" href="#future-javascript--now">Future JavaScript =&gt; Now</a></h2>
<p>TypeScript provides a number of features that are planned in ES6 for current JavaScript engines (that only support ES5 etc). The TypeScript team is actively adding these features and this list is only going to get bigger over time and we will cover this in its own section. But just as a specimen here is an example of a class:</p>
<pre><code class="language-typescript">class Point {
    constructor(public x: number, public y: number) {
    }
    add(point: Point) {
        return new Point(this.x + point.x, this.y + point.y);
    }
}

var p1 = new Point(0, 10);
var p2 = new Point(10, 20);
var p3 = p1.add(p2); // { x: 10, y: 30 }
</code></pre>
<p>and the lovely fat arrow function:</p>
<pre><code class="language-typescript">var inc = x =&gt; x+1;
</code></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<p>Enums are comparable and valid with numbers and vice versa, but comparing Enum values from different Enum types is invalid.</p>
<p>[[Error_TS2367]]</p>
<!-- skip -->
<pre><code class="language-typescript">enum X {
    A,
    B,
}
enum Y {
    A,
    B,
    C,
}
const xa: number = X.A; // Valid
const ya: Y = 0; // Valid
X.A === Y.A; // Invalid
</code></pre>
<p><code>&gt;Out:</code></p>
<p>error TS2367: This comparison appears to be unintentional because the types ‘X’ and ‘Y’ have no overlap.</p>
<p>Instances of a class are subject to a compatibility check for their private and protected members:</p>
<!-- skip -->
<pre><code class="language-typescript">class X {
    public a: string;
    constructor(value: string) {
        this.a = value;
    }
}

class Y {
    private a: string;
    constructor(value: string) {
        this.a = value;
    }
}

let x: X = new Y('y'); // Invalid
</code></pre>
<p>The comparison check does not take into consideration the different inheritance hierarchy, for instance:</p>
<pre><code class="language-typescript">class X {
    public a: string;
    constructor(value: string) {
        this.a = value;
    }
}
class Y extends X {
    public a: string;
    constructor(value: string) {
        super(value);
        this.a = value;
    }
}
class Z {
    public a: string;
    constructor(value: string) {
        this.a = value;
    }
}
let x: X = new X('x');
let y: Y = new Y('y');
let z: Z = new Z('z');
x === y; // Valid
x === z; // Valid even if z is from a different inheritance hierarchy
</code></pre>
<p>Generics are compared using their structures based on the resulting type after applying the generic parameter, only the final result is compared as a non-generic type.</p>
<!-- skip -->
<pre><code class="language-typescript">interface X&lt;T&gt; {
    a: T;
}
let x: X&lt;number&gt; = { a: 1 };
let y: X&lt;string&gt; = { a: 'a' };
x === y; // Invalid as the type argument is used in the final structure
</code></pre>
<pre><code class="language-typescript">interface X&lt;T&gt; {}
const x: X&lt;number&gt; = 1;
const y: X&lt;string&gt; = 'a';
x === y; // Valid as the type argument is not used in the final structure
</code></pre>
<p>When generics do not have their type argument specified, all the unspecified arguments are treated as types with “any”:</p>
<pre><code class="language-typescript">type X = &lt;T&gt;(x: T) =&gt; T;
type Y = &lt;K&gt;(y: K) =&gt; K;
let x: X = x =&gt; x;
let y: Y = y =&gt; y;
x = y; // Valid
</code></pre>
<p>Remember:</p>
<!-- skip -->
<pre><code class="language-typescript">let a: number = 1;
let b: number = 2;
a = b; // Valid, everything is assignable to itself

let c: any;
c = 1; // Valid, all types are assignable to any

let d: unknown;
d = 1; // Valid, all types are assignable to unknown. Unknown is a type-safe as a alternative for 'any'

let e: unknown;
let e1: unknown = e; // Valid, unknown is only assignable to itself and any
let e2: any = e; // Valid
let e3: number = e; // Invalid

let f: never;
f = 1; // Invalid, nothing is assignable to never

let g: void;
let g1: any;
g = 1; // Invalid, void is not assignable to or from anything expect any
g = g1; // Valid
</code></pre>
<p>Please note that when “strictNullChecks” is enabled, “null” and “undefined” are treated similarly to “void”; otherwise, they are similar to “never”.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generics-2"><a class="header" href="#generics-2">Generics</a></h2>
<p>Generics allow you to create reusable components and functions that <strong>can work with multiple types</strong>. With generics, you can parameterize types, functions, and interfaces, allowing them to <strong>operate on different types without explicitly specifying them beforehand.</strong></p>
<p>The key motivation for generics is to document meaningful type dependencies between members. The members can be:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Class instance members</li>
<li><input disabled="" type="checkbox" checked=""/>
Class methods</li>
<li><input disabled="" type="checkbox" checked=""/>
function arguments</li>
<li><input disabled="" type="checkbox" checked=""/>
function return value</li>
</ul>
<p>Many algorithms and data structures in computer science do not depend on the <em>actual type</em> of the object. However, you still want to enforce a constraint between various variables. A simple toy example is a function that takes a list of items and returns a reversed list of items. The constraint here is between what is passed in to the function and what is returned by the function:</p>
<pre><code class="language-typescript">function reverse&lt;T&gt;(items: T[]): T[] {
    var toreturn = [];
    for (let i = items.length - 1; i &gt;= 0; i--) {
        toreturn.push(items[i]);
    }
    return toreturn;
}

var sample = [1, 2, 3];
var reversed = reverse(sample);
console.log(reversed); // 3,2,1

// Safety!
reversed[0] = '1';     // Error!
reversed = ['1', '2']; // Error!

reversed[0] = 1;       // Okay
reversed = [1, 2];     // Okay
</code></pre>
<p>Here you are basically saying that the function <code>reverse</code> takes an array (<code>items: T[]</code>) of <em>some</em> type <code>T</code> (notice the type parameter in <code>reverse&lt;T&gt;</code>) and returns an array of type <code>T</code> (notice <code>: T[]</code>). Because the <code>reverse</code> function returns items of the same type as it takes, TypeScript knows the <code>reversed</code> variable is also of type <code>number[]</code> and will give you Type safety. Similarly if you pass in an array of <code>string[]</code> to the reverse function the returned result is also an array of <code>string[]</code> and you get similar type safety as shown below:</p>
<pre><code class="language-typescript">var strArr = ['1', '2'];
var reversedStrs = reverse(strArr);

reversedStrs = [1, 2]; // Error!
</code></pre>
<p>In fact JavaScript arrays already have a <code>.reverse</code> function and TypeScript does indeed use generics to define its structure:</p>
<pre><code class="language-typescript">interface Array&lt;T&gt; {
 reverse(): T[];
 // ...
}
</code></pre>
<p>This means that you get type safety when calling <code>.reverse</code> on any array as shown below:</p>
<pre><code class="language-typescript">var numArr = [1, 2];
var reversedNums = numArr.reverse();

reversedNums = ['1', '2']; // Error!
</code></pre>
<p>We will discuss more about the <code>Array&lt;T&gt;</code> interface later when we present <code>lib.d.ts</code> in the section <strong>Ambient Declarations</strong>.</p>
<h3 id="generic-type-1"><a class="header" href="#generic-type-1">Generic Type</a></h3>
<p>To define a generic type, you use angle brackets (<code>&lt;&gt;</code>) to specify the type parameters, for instance:</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
const a = identity('x');
const b = identity(123);

const getLen = &lt;T,&gt;(data: ReadonlyArray&lt;T&gt;) =&gt; data.length;
const len = getLen([1, 2, 3]);
</code></pre>
<h3 id="generic-classes-1"><a class="header" href="#generic-classes-1">Generic Classes</a></h3>
<p>Generics can be applied also to classes, in this way they can work with multiple types by using type parameters. This is useful to create reusable class definitions that can operate on different data types while maintaining type safety.</p>
<pre><code class="language-typescript">class Container&lt;T&gt; {
    private item: T;

    constructor(item: T) {
        this.item = item;
    }

    getItem(): T {
        return this.item;
    }
}

const numberContainer = new Container&lt;number&gt;(123);
console.log(numberContainer.getItem()); // 123

const stringContainer = new Container&lt;string&gt;('hello');
console.log(stringContainer.getItem()); // hello
</code></pre>
<h3 id="generic-constraints-1"><a class="header" href="#generic-constraints-1">Generic Constraints</a></h3>
<p>Generic parameters can be constrained using the <code>extends</code> keyword followed by a type or interface that the type parameter must satisfy.</p>
<p>In the following example T it is must containing a properly <code>length</code> in order to be valid:</p>
<!-- skip -->
<pre><code class="language-typescript">const printLen = &lt;T extends { length: number }&gt;(value: T): void =&gt; {
    console.log(value.length);
};

printLen('Hello'); // 5
printLen([1, 2, 3]); // 3
printLen({ length: 10 }); // 10
printLen(123); // Invalid
</code></pre>
<p><code>&gt;tags:</code> [[Important]] #Propagated_Type [[Generic]] [[PointFree]] [[Propagate]]</p>
<p>An interesting feature of generic introduced in version 3.4 RC is Higher order function type inference which introduced  propagated generic type arguments:</p>
<pre><code class="language-typescript">declare function pipe&lt;A extends any[], B, C&gt;(
    ab: (...args: A) =&gt; B,
    bc: (b: B) =&gt; C
): (...args: A) =&gt; C;

declare function list&lt;T&gt;(a: T): T[];
declare function box&lt;V&gt;(x: V): { value: V };

const listBox = pipe(list, box); // &lt;T&gt;(a: T) =&gt; { value: T[] }
const boxList = pipe(box, list); // &lt;V&gt;(x: V) =&gt; { value: V }[]
</code></pre>
<p>This functionality allows more easily typed safe pointfree style programming which is common in functional programming.</p>
<h3 id="generic-contextual-narrowing-1"><a class="header" href="#generic-contextual-narrowing-1">Generic contextual narrowing</a></h3>
<p>Contextual narrowing for generics is the mechanism in TypeScript that allows the compiler to narrow down the type of a generic parameter based on the context in which it is used, it is useful when working with generic types in conditional statements:</p>
<pre><code class="language-typescript">function process&lt;T&gt;(value: T): void {
    if (typeof value === 'string') {
        // Value is narrowed down to type 'string'
        console.log(value.length);
    } else if (typeof value === 'number') {
        // Value is narrowed down to type 'number'
        console.log(value.toFixed(2));
    }
}

process('hello'); // 5
process(3.14159); // 3.14
</code></pre>
<h2 id="motivation-and-samples-1"><a class="header" href="#motivation-and-samples-1">Motivation and samples</a></h2>
<p>Consider the simple <code>Queue</code> (first in, first out) data structure implementation. A simple one in TypeScript / JavaScript looks like:</p>
<pre><code class="language-typescript">class Queue {
  private data = [];
  push(item) { this.data.push(item); }
  pop() { return this.data.shift(); }
}
</code></pre>
<p>One issue with this implementation is that it allows people to add <em>anything</em> to the queue and when they pop it - it can be <em>anything</em>. This is shown below, where someone can push a <code>string</code> onto the queue while the usage actually assumes that only <code>numbers</code> were pushed in:</p>
<pre><code class="language-typescript">class Queue {
  private data = [];
  push(item) { this.data.push(item); }
  pop() { return this.data.shift(); }
}

const queue = new Queue();
queue.push(0);
queue.push(&quot;1&quot;); // Oops a mistake

// a developer walks into a bar
console.log(queue.pop().toPrecision(1));
console.log(queue.pop().toPrecision(1)); // RUNTIME ERROR
</code></pre>
<p>One solution (and in fact the only one in languages that don’t support generics) is to go ahead and create <em>special</em> classes just for these constraints. E.g. a quick and dirty number queue:</p>
<pre><code class="language-typescript">class QueueNumber extends Queue {
  push(item: number) { super.push(item); }
  pop(): number { return this.data.shift(); }
}

const queue = new QueueNumber();
queue.push(0);
queue.push(&quot;1&quot;); // ERROR : cannot push a string. Only numbers allowed

// ^ if that error is fixed the rest would be fine too
</code></pre>
<p>Of course this can quickly become painful e.g. if you want a string queue you have to go through all that effort again. What you really want is a way to say that whatever the type is of the stuff getting <em>pushed</em> it should be the same for whatever gets <em>popped</em>. This is done easily with a <em>generic</em> parameter (in this case, at the class level):</p>
<pre><code class="language-typescript">/** A class definition with a generic parameter */
class Queue&lt;T&gt; {
  private data = [];
  push(item: T) { this.data.push(item); }
  pop(): T | undefined { return this.data.shift(); }
}

/** Again sample usage */
const queue = new Queue&lt;number&gt;();
queue.push(0);
queue.push(&quot;1&quot;); // ERROR : cannot push a string. Only numbers allowed

// ^ if that error is fixed the rest would be fine too
</code></pre>
<p>Another example that we have already seen is that of a <em>reverse</em> function, here the constraint is between what gets passed into the function and what the function returns:</p>
<pre><code class="language-typescript">function reverse&lt;T&gt;(items: T[]): T[] {
    var toreturn = [];
    for (let i = items.length - 1; i &gt;= 0; i--) {
        toreturn.push(items[i]);
    }
    return toreturn;
}

var sample = [1, 2, 3];
var reversed = reverse(sample);
console.log(reversed); // 3,2,1

// Safety!
reversed[0] = '1';     // Error!
reversed = ['1', '2']; // Error!

reversed[0] = 1;       // Okay
reversed = [1, 2];     // Okay
</code></pre>
<p>In this section you have seen examples of generics being defined <em>at class level</em> and at <em>function level</em>. One minor addition worth mentioning is that you can have generics created just for a member function. As a toy example consider the following where we move the <code>reverse</code> function into a <code>Utility</code> class:</p>
<pre><code class="language-typescript">class Utility {
  reverse&lt;T&gt;(items: T[]): T[] {
      var toreturn = [];
      for (let i = items.length - 1; i &gt;= 0; i--) {
          toreturn.push(items[i]);
      }
      return toreturn;
  }
}
</code></pre>
<blockquote>
<p>TIP: You can call the generic parameter whatever you want. It is conventional to use <code>T</code>, <code>U</code>, or <code>V</code> when you have simple generics. If you have more than one generic argument try to use meaningful names like <code>TKey</code> and <code>TValue</code>. The convention is to prefix with <code>T</code> because generics are also called <em>templates</em> in other languages like C++.</p>
</blockquote>
<h3 id="design-pattern-convenience-generic-1"><a class="header" href="#design-pattern-convenience-generic-1">Design Pattern: Convenience generic</a></h3>
<p>Consider the function: </p>
<pre><code class="language-typescript">declare function parse&lt;T&gt;(name: string): T;
</code></pre>
<p>In this case you can see that the type <code>T</code> is only used in one place. So there is no constraint <em>between</em> members. This is equivalent to a type assertion in terms of type safety:</p>
<pre><code class="language-typescript">declare function parse(name: string): any;

const something = parse('something') as TypeOfSomething;
</code></pre>
<p>Generics used <em>only once</em> are no better than an assertion in terms of type safety. That said they do provide <em>convenience</em> to your API.</p>
<p>A more obvious example is a function that loads a json response. It returns a promise of <em>whatever type you pass in</em>:</p>
<pre><code class="language-typescript">const getJSON = &lt;T&gt;(config: {
    url: string,
    headers?: { [key: string]: string },
  }): Promise&lt;T&gt; =&gt; {
    const fetchConfig = ({
      method: 'GET',
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      ...(config.headers || {})
    });
    return fetch(config.url, fetchConfig)
      .then&lt;T&gt;(response =&gt; response.json());
  }
</code></pre>
<p>Note that you still have to explicitly annotate what you want, but the <code>getJSON&lt;T&gt;</code> signature <code>(config) =&gt; Promise&lt;T&gt;</code> saves you a few key strokes (you don’t need to annotate the return type of <code>loadUsers</code> as it can be inferred):</p>
<pre><code class="language-typescript">type LoadUsersResponse = {
  users: {
    name: string;
    email: string;
  }[];  // array of user objects
}
function loadUsers() {
  return getJSON&lt;LoadUsersResponse&gt;({ url: 'https://example.com/users' });
}
</code></pre>
<p>Also <code>Promise&lt;T&gt;</code> as a return value is definitely better than alternatives like <code>Promise&lt;any&gt;</code>.</p>
<p>Another example is where a generic is only used as an argument: </p>
<pre><code class="language-typescript">declare function send&lt;T&gt;(arg: T): void;
</code></pre>
<p>Here the generic <code>T</code> can be used to annote the type that you want the argument to match e.g. </p>
<pre><code class="language-typescript">send&lt;Something&gt;({
  x:123,
  // Also you get autocomplete  
}); // Will TSError if `x:123` does not match the structure expected for Something

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="classes-2"><a class="header" href="#classes-2">Classes</a></h3>
<p>The reason why it’s important to have classes in JavaScript as a first class item is that:</p>
<ol>
<li><a href="oop/./tips/classesAreUseful.html">Classes offer a useful structural abstraction</a></li>
<li>Provides a consistent way for developers to use classes instead of every framework (emberjs,reactjs etc) coming up with their own version.</li>
<li>Object Oriented Developers already understand classes.</li>
</ol>
<p><code>Finally JavaScript developers can *have </code>class<code>*. Here we have a basic class called Point:</code></p>
<pre><code class="language-typescript">class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    add(point: Point) {
        return new Point(this.x + point.x, this.y + point.y);
    }
}

var p1 = new Point(0, 10);
var p2 = new Point(10, 20);
var p3 = p1.add(p2); // {x:10,y:30}
</code></pre>
<p>This class generates the following JavaScript on ES5 emit:</p>
<pre><code class="language-typescript">var Point = (function () {
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    Point.prototype.add = function (point) {
        return new Point(this.x + point.x, this.y + point.y);
    };
    return Point;
})();
</code></pre>
<p>This is a fairly idiomatic traditional JavaScript class pattern now as a first class language construct.</p>
<pre><code class="language-typescript">class Foo {}; 
var someVar = Foo; //variable space declaretion
var someOtherVar = 123; //Valid
</code></pre>
<h3 id="newtarget"><a class="header" href="#newtarget">New.target</a></h3>
<p>You can use in TypeScript the <code>new.target</code> meta-property which enables you to determine if a function or constructor was invoked using the new operator. It allows you to detect whether an object was created as a result of a constructor call.</p>
<pre><code class="language-typescript">class Parent {
    constructor() {
        console.log(new.target); // Logs the constructor function used to create an instance
    }
}

class Child extends Parent {
    constructor() {
        super();
    }
}

const parentX = new Parent(); // [Function: Parent]
const child = new Child(); // [Function: Child]
</code></pre>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Classes in TypeScript (like other languages) support <em>single</em> inheritance using the <code>extends</code> keyword as shown below:</p>
<pre><code class="language-typescript">class Point3D extends Point {
    z: number;
    constructor(x: number, y: number, z: number) {
        super(x, y);
        this.z = z;
    }
    add(point: Point3D) {
        var point2D = super.add(point);
        return new Point3D(point2D.x, point2D.y, this.z + point.z);
    }
}
</code></pre>
<p>If you have a constructor in your class then you <em>must</em> call the parent constructor from your constructor (TypeScript will point this out to you). This ensures that the stuff that it needs to set on <code>this</code> gets set. Followed by the call to <code>super</code> you can add any additional stuff you want to do in your constructor (here we add another member <code>z</code>).</p>
<p>Note that you override parent member functions easily (here we override <code>add</code>) and still use the functionality of the super class in your members (using <code>super.</code> syntax).</p>
<h3 id="statics-1"><a class="header" href="#statics-1">Statics</a></h3>
<p>TypeScript classes support <code>static</code> properties that are shared by all instances of the class. A natural place to put (and access) them is on the class itself and that is what TypeScript does:</p>
<pre><code class="language-typescript">class Something {
    static instances = 0;
    constructor() {
        Something.instances++;
    }
}

var s1 = new Something();
var s2 = new Something();
console.log(Something.instances); // 2
</code></pre>
<p>You can have static members as well as static functions.</p>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>TypeScript supports access modifiers <code>public</code>,<code>private</code> and <code>protected</code> which determine the accessibility of a <code>class</code> member as shown below:</p>
<table><thead><tr><th>accessible on</th><th><code>public</code></th><th><code>protected</code></th><th><code>private</code></th></tr></thead><tbody>
<tr><td>class</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>class children</td><td>yes</td><td>yes</td><td>no</td></tr>
<tr><td>class instances</td><td>yes</td><td>no</td><td>no</td></tr>
</tbody></table>
<p>If an access modifier is not specified it is implicitly <code>public</code> as that matches the <em>convenient</em> nature of JavaScript 🌹.</p>
<p>Note that at runtime (in the generated JS) these have no significance but will give you compile time errors if you use them incorrectly. An example of each is shown below:</p>
<pre><code class="language-typescript">class FooBase {
    public x: number;
    private y: number;
    protected z: number;
}

// EFFECT ON INSTANCES
var foo = new FooBase();
foo.x; // okay
foo.y; // ERROR : private
foo.z; // ERROR : protected

// EFFECT ON CHILD CLASSES
class FooChild extends FooBase {
    constructor() {
      super();
        this.x; // okay
        this.y; // ERROR: private
        this.z; // okay
    }
}
</code></pre>
<p>As always these modifiers work for both member properties and member functions.</p>
<p>In TypeScript, constructors can be marked as private or protected, which restricts their accessibility and usage.</p>
<p><code>Private Constructors:</code>
An experimental proposal to the ECMAScript standard introduces the concept of a private field by using the hash (#) symbol before a property name.</p>
<pre><code class="language-typescript">// Class 'ClassES6Private' defines a private property '#id' of type number
class ClassES6Private {
  // Property '#id' is a private field and can only be accessed within the class
  #id: number;

  // Constructor initializes the private '#id' field with the passed 'id' argument
  constructor(id: number) {
    this.#id = id;
  }
}

// Instantiate a new object of type 'ClassES6Private' with an 'id' of 10
let es6PrivateClass = new ClassES6Private(10);

// Attempt to change the private '#id' field
es6PrivateClass.#id = 20;
</code></pre>
<p>Can be called only within the class itself. Private constructors are often used in scenarios where you want to enforce a singleton pattern or restrict the creation of instances to a factory method within the class</p>
<p><code>Protected Constructors:</code>
Protected constructors are useful when you want to create a base class that should not be instantiated directly but can be extended by subclasses.</p>
<pre><code class="language-typescript">class BaseClass {
    protected constructor() {}
}

class DerivedClass extends BaseClass {
    private value: number;

    constructor(value: number) {
        super();
        this.value = value;
    }
}

// Attempting to instantiate the base class directly will result in an error
// const baseObj = new BaseClass(); // Error: Constructor of class 'BaseClass' is protected.

// Create an instance of the derived class
const derivedObj = new DerivedClass(10);
</code></pre>
<p>These modifiers are essential for enforcing encapsulation and establishing boundaries for accessing and modifying the internal state of a class.</p>
<p>The <code>private</code> modifier restricts access to the class member only within the containing class.</p>
<p>The <code>protected</code> modifier allows access to the class member within the containing class and its derived classes.</p>
<p>The <code>public</code> modifier provides unrestricted access to the class member, allowing it to be accessed from anywhere.“</p>
<h3 id="abstract"><a class="header" href="#abstract">Abstract</a></h3>
<p><code>abstract</code> can be thought of as an access modifier. We present it separately because opposed to the previously mentioned modifiers it can be on a <code>class</code> as well as any member of the class. Having an <code>abstract</code> modifier primarily means that such functionality <em>cannot be directly invoked</em> and a child class must provide the functionality.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Can an abstract class have a constructor in TypeScript? Yes, and it can be called by subclasses.</li>
<li><input disabled="" type="checkbox" checked=""/>
Can an abstract class have static methods in TypeScript? Yes, and they can be overridden in subclasses.</li>
</ul>
<ul>
<li><code>abstract</code> <strong>classes</strong> cannot be directly instantiated. Instead the user must create some <code>class</code> that inherits from the <code>abstract class</code>.</li>
</ul>
<pre><code class="language-typescript">abstract class FooCommand {}

class BarCommand extends FooCommand {}

const fooCommand: FooCommand = new FooCommand(); // Cannot create an instance of an abstract class.

const barCommand = new BarCommand(); // You can create an instance of a class that inherits from an abstract class.
</code></pre>
<ul>
<li><code>abstract</code> <strong>members</strong> cannot be directly accessed and a child class must provide the functionality.</li>
</ul>
<pre><code class="language-typescript">abstract class FooCommand {
  abstract execute(): string;
}

class BarErrorCommand  extends FooCommand {} // 'BarErrorCommand' needs implement abstract member 'execute'.

class BarCommand extends FooCommand {
  execute() {
    return `Command Bar executed`;
  }
}

const barCommand = new BarCommand();

barCommand.execute(); // Command Bar executed
</code></pre>
<h4 id="abstract-vs-interface"><a class="header" href="#abstract-vs-interface">Abstract vs Interface</a></h4>
<p>An abstract class can have methods with implementation but an interface can’t.</p>
<h3 id="constructor-is-optional"><a class="header" href="#constructor-is-optional">Constructor is optional</a></h3>
<p>The class does not need to have a constructor. e.g. the following is perfectly fine. </p>
<pre><code class="language-typescript">class Foo {}
var foo = new Foo();
</code></pre>
<h3 id="define-using-constructor"><a class="header" href="#define-using-constructor">Define using constructor</a></h3>
<p>Having a member in a class and initializing it like below:</p>
<pre><code class="language-typescript">class Foo {
    x: number;
    constructor(x:number) {
        this.x = x;
    }
}
</code></pre>
<p>is such a common pattern that TypeScript provides a shorthand where you can prefix the member with an <em>access modifier</em> and it is automatically declared on the class and copied from the constructor. So the previous example can be re-written as (notice <code>public x:number</code>):</p>
<pre><code class="language-typescript">class Foo {
    constructor(public x:number) {
    }
}
</code></pre>
<h3 id="property-initializer"><a class="header" href="#property-initializer">Property initializer</a></h3>
<p>This is a nifty feature supported by TypeScript (from ES7 actually). You can initialize any member of the class outside the class constructor, useful to provide default (notice <code>members = []</code>)</p>
<pre><code class="language-typescript">class Foo {
    members = [];  // Initialize directly
    add(x) {
        this.members.push(x);
    }
}
</code></pre>
<h3 id="get--set"><a class="header" href="#get--set">Get &amp; Set</a></h3>
<p>Getters and setters are special methods that allow you to define custom access and modification behavior for class properties. They enable you to encapsulate the internal state of an object and provide additional logic when getting or setting the values of properties.
In TypeScript, getters and setters are defined using the <code>get</code> and <code>set</code> keywords respectively. Here’s an example:</p>
<pre><code class="language-typescript">class MyClass {
    private _myProperty: string;

    constructor(value: string) {
        this._myProperty = value;
    }
    get myProperty(): string {
        return this._myProperty;
    }
    set myProperty(value: string) {
        this._myProperty = value;
    }
}
</code></pre>
<h3 id="auto-accessors-in-classes"><a class="header" href="#auto-accessors-in-classes">Auto-Accessors in Classes</a></h3>
<p>TypeScript version 4.9 adds support for auto-accessors, a forthcoming ECMAScript feature. They resemble class properties but are declared with the “accessor” keyword.</p>
<pre><code class="language-typescript">class Animal {
    accessor name: string;

    constructor(name: string) {
        this.name = name;
    }
}
</code></pre>
<p>Auto-accessors are “de-sugared” <strong>into private <code>get</code> and <code>set</code> accessors, operating on an inaccessible property.</strong></p>
<!-- skip -->
<pre><code class="language-typescript">class Animal {
    #__name: string;

    get name() {
        return this.#__name;
    }
    set name(value: string) {
        this.#__name = name;
    }

    constructor(name: string) {
        this.name = name;
    }
}
</code></pre>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<pre><code class="language-typescript">abstract class Animal {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    abstract makeSound(): void;
}

class Cat extends Animal {
    makeSound(): void {
        console.log(`${this.name} meows.`);
    }
}

const cat = new Cat('Whiskers');
cat.makeSound(); // Output: Whiskers meows.
</code></pre>
<h3 id="with-generics"><a class="header" href="#with-generics">With Generics</a></h3>
<p>Classes with generics allow you to define reusable classes which can work with different types.</p>
<pre><code class="language-typescript">class Container&lt;T&gt; {
    private item: T;

    constructor(item: T) {
        this.item = item;
    }

    getItem(): T {
        return this.item;
    }

    setItem(item: T): void {
        this.item = item;
    }
}

const container1 = new Container&lt;number&gt;(42);
console.log(container1.getItem()); //  42

const container2 = new Container&lt;string&gt;('Hello');
container2.setItem('World');
console.log(container2.getItem()); // World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h2>
<p>The purpose of an interface in TypeScript is to define a <strong>blueprint for objects</strong>.
Interfaces have <em>zero</em> runtime JS impact. There is a lot of power in TypeScript interfaces to declare the structure of variables.</p>
<p>The following two are equivalent declarations, the first uses an <em>inline annotation</em>, the second uses an <em>interface</em>:</p>
<pre><code class="language-typescript">// Sample A
declare var myPoint: { x: number; y: number; };

// Sample B
interface Point {
    x: number; y: number;
}
declare var myPoint: Point;
</code></pre>
<p>However, the beauty of <em>Sample B</em> is that if someone authors a library that builds on the <code>myPoint</code> library to add new members, they can easily add to the existing declaration of <code>myPoint</code>:</p>
<pre><code class="language-typescript">// Lib a.d.ts
interface Point {
    x: number; y: number;
}
declare var myPoint: Point;

// Lib b.d.ts
interface Point {
    z: number;
}

// Your code
var myPoint.z; // Allowed!
</code></pre>
<p>This is because <strong>interfaces in TypeScript are open ended</strong>. This is a vital tenet of TypeScript that it allows you to mimic the extensibility of JavaScript using <em>interfaces</em>.</p>
<p>Interfaces are the core way in TypeScript to compose multiple type annotations into a single named annotation. Consider the following example:</p>
<pre><code class="language-typescript">interface Name {
    first: string;
    second: string;
}

var name: Name;
name = {
    first: 'John',
    second: 'Doe'
};

name = {           // Error : `second` is missing
    first: 'John'
};
name = {           // Error : `second` is the wrong type
    first: 'John',
    second: 1337
};
</code></pre>
<p>Here we’ve composed the annotations <code>first: string</code> + <code>second: string</code> into a new annotation <code>Name</code> that enforces the type checks on individual members. Interfaces have a lot of power in TypeScript and we will dedicate an entire section to how you can use that to your advantage.</p>
<h3 id="narrowing-a-type-on-a-derived-interface"><a class="header" href="#narrowing-a-type-on-a-derived-interface">Narrowing a type on a derived interface</a></h3>
<pre><code class="language-typescript">// Interface `IBaseStringOrNumber` defines a property `id` that can be either a string or a number
interface IBaseStringOrNumber {
    id: string | number;
}

// Interface `IDerivedFromBaseNumber` extends `IBaseStringOrNumber` and defines the property `id` as being a number type
interface IDerivedFromBaseNumber
    extends IBaseStringOrNumber {
    id: number;
}
</code></pre>
<h3 id="generic-constraint"><a class="header" href="#generic-constraint">Generic Constraint</a></h3>
<p>Can we specify a generic constraint on a function parameter in TypeScript? Yes</p>
<pre><code class="language-typescript">// This class takes an array of strings or numbers and concatenates them into a single string
class Concatenator&lt;T extends Array&lt;string&gt; | Array&lt;number&gt;&gt; {
  
  // Method that concatenates the array of items into a string
  public concatenateArray(items: T): string {
    
    // Initialize an empty string to store the concatenated values
    let returnString = &quot;&quot;;

    // Loop through each item in the array
    for (let i = 0; i &lt; items.length; i++) {
      // If this is not the first item, add a comma before appending the value
      returnString += i &gt; 0 ? &quot;,&quot; : &quot;&quot;;
      
      // Append the current value to the return string
      returnString += items[i].toString();
    }

    // Return the final concatenated string
    return returnString;
  }
}
</code></pre>
<h3 id="inline-type-annotation"><a class="header" href="#inline-type-annotation">Inline Type Annotation</a></h3>
<p>Instead of creating a new <code>interface</code> you can annotate anything you want <em>inline</em> using <code>:{ /*Structure*/ }</code>. The previous example presented again with an inline type:</p>
<pre><code class="language-typescript">var name: {
    first: string;
    second: string;
};
name = {
    first: 'John',
    second: 'Doe'
};

name = {           // Error : `second` is missing
    first: 'John'
};
name = {           // Error : `second` is the wrong type
    first: 'John',
    second: 1337
};
</code></pre>
<p>Inline types are great for quickly providing a one off type annotation for something. It saves you the hassle of coming up with (a potentially bad) type name. However, if you find yourself putting in the same type annotation inline multiple times it’s a good idea to consider refactoring it into an interface (or a <code>type alias</code> covered later in this section).</p>
<h2 id="classes-can-implement-interfaces"><a class="header" href="#classes-can-implement-interfaces">Classes can implement interfaces</a></h2>
<p>If you want to use <em>classes</em> that must follow an object structure that someone declared for you in an <code>interface</code> you can use the <code>implements</code> keyword to ensure compatibility:</p>
<pre><code class="language-typescript">interface Point {
    x: number; y: number;
}

class MyPoint implements Point {
    x: number; y: number; // Same as Point
}
</code></pre>
<p>Basically in the presence of that <code>implements</code>, any changes in that external <code>Point</code> interface will result in a compile error in your code base so you can easily keep it in sync:</p>
<pre><code class="language-typescript">interface Point {
    x: number; y: number;
    z: number; // New member
}

class MyPoint implements Point { // ERROR : missing member `z`
    x: number; y: number;
}
</code></pre>
<p>Note that <code>implements</code> restricts the structure of the class <em>instances</em> i.e.:</p>
<pre><code class="language-typescript">var foo: Point = new MyPoint();
</code></pre>
<p>And stuff like <code>foo: Point = MyPoint</code> is not the same thing.</p>
<h2 id="keyof"><a class="header" href="#keyof">Keyof</a></h2>
<p><code>&gt;tags:</code> [[Important]] [[Keyof]]</p>
<pre><code class="language-typescript">Define an interface `IPerson` with properties `id` and `name`
interface IPerson {
  id: number;
  name: string;
}

// Generate a string literal type for the properties of the interface `IPerson`
type PersonPropertyName = keyof IPerson;
//This is equivalent to the following string literal:
type PersonPropertyLiteral = &quot;id&quot; | &quot;name&quot;;
</code></pre>
<h2 id="in-1"><a class="header" href="#in-1">In</a></h2>
<p>Purpose of the in keyword in TypeScript interface To specify a constraint for the types of properties.</p>
<pre><code class="language-typescript">    if ('id' in obj) {
      console.log(`obj.name : ${obj.name}`);
    }
</code></pre>
<h2 id="tips"><a class="header" href="#tips">TIPs</a></h2>
<h3 id="not-every-interface-is-implementable-easily"><a class="header" href="#not-every-interface-is-implementable-easily">Not every interface is implementable easily</a></h3>
<p>Interfaces are designed to declare <em>any arbitrarily crazy</em> structure that might be present in JavaScript.</p>
<p>Consider the following interface where something is callable with <code>new</code>:</p>
<pre><code class="language-typescript">interface Crazy {
    new (): {
        hello: number
    };
}
</code></pre>
<p><code>&gt;tags:</code> [[Error_TS2420]] [[Interface]] error TS2420: Class ‘CrazyClass’ incorrectly implements interface ‘Crazy’.</p>
<p>You would essentially have something like:</p>
<pre><code class="language-typescript">class CrazyClass implements Crazy {
    constructor() {
        return { hello: 123 };
    }
}
// Because
const crazy = new CrazyClass(); // crazy would be {hello:123}
</code></pre>
<p>You can <em>declare</em> all the crazy JS out there with interfaces and even use them safely from TypeScript. Doesn’t mean you can use TypeScript classes to implement them.</p>
<h2 id="extending-types-1"><a class="header" href="#extending-types-1">Extending Types</a></h2>
<p>It is possible to extend an <code>interface</code> (copy members from another type):</p>
<pre><code class="language-typescript">interface X {
    a: string;
}
interface Y extends X {
    b: string;
}
</code></pre>
<p>It is also possible to extend from multiple types:</p>
<pre><code class="language-typescript">interface A {
    a: string;
}
interface B {
    b: string;
}
interface Y extends A, B {
    y: string;
}
</code></pre>
<p>The <code>extends</code> keyword works only on interfaces and classes, for types use an intersection:</p>
<pre><code class="language-typescript">type A = {
    a: number;
};
type B = {
    b: number;
};
type C = A &amp; B;
</code></pre>
<p>It is possible to extend a type using an inference but not vice versa:</p>
<pre><code class="language-typescript">type A = {
    a: string;
};
interface B extends A {
    b: string;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h1>
<p>TypeScript does not support multiple inheritance in the traditional sense and instead allows inheritance from a single base class.
TypeScript supports multiple interfaces. An interface can define a contract for the structure of an object, and a class can implement multiple interfaces. This allows a class to inherit behavior and structure from multiple sources.</p>
<pre><code class="language-typescript">interface Flyable {
    fly(): void;
}

interface Swimmable {
    swim(): void;
}

class FlyingFish implements Flyable, Swimmable {
    fly() {
        console.log('Flying...');
    }

    swim() {
        console.log('Swimming...');
    }
}

const flyingFish = new FlyingFish();
flyingFish.fly();
flyingFish.swim();
</code></pre>
<h3 id="implements-with-extends"><a class="header" href="#implements-with-extends">Implements with Extends</a></h3>
<pre><code class="language-typescript">// This is the BaseClass implementation that implements the IBase interface
// The `id` property is set to a default value of 0
class BaseClass implements IBase {
  id: number = 0;
}

// This is the DerivedFromBaseClass that extends the BaseClass
// and implements the IDerivedFromBase interface
// The `name` property is set to a default value of &quot;nameString&quot;
class DerivedFromBaseClass
  extends BaseClass
  implements IDerivedFromBase {
  name: string = &quot;nameString&quot;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function overloading</a></h2>
<p>Function overloading allows you to define multiple function signatures for the same function name, each with different parameter types and return type.
When you call an overloaded function, TypeScript uses the provided arguments to determine the correct function signature:</p>
<pre><code class="language-typescript">function makeGreeting(name: string): string;
function makeGreeting(names: string[]): string[];

function makeGreeting(person: unknown): unknown {
    if (typeof person === 'string') {
        return `Hi ${person}!`;
    } else if (Array.isArray(person)) {
        return person.map(name =&gt; `Hi, ${name}!`);
    }
    throw new Error('Unable to greet');
}

makeGreeting('Simon');
makeGreeting(['Simone', 'John']);
</code></pre>
<h2 id="method-overloading"><a class="header" href="#method-overloading">Method overloading</a></h2>
<p>Method overloading allows a class to have multiple methods with the same name but different parameter types or a different number of parameters. This allows us to call a method in different ways based on the arguments passed.</p>
<pre><code class="language-typescript">class MyClass {
    add(a: number, b: number): number; // Overload signature 1
    add(a: string, b: string): string; // Overload signature 2

    add(a: number | string, b: number | string): number | string {
        if (typeof a === 'number' &amp;&amp; typeof b === 'number') {
            return a + b;
        }
        if (typeof a === 'string' &amp;&amp; typeof b === 'string') {
            return a.concat(b);
        }
        throw new Error('Invalid arguments');
    }
}

const r = new MyClass();
console.log(r.add(10, 5)); // Logs 15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="decorators"><a class="header" href="#decorators">Decorators</a></h2>
<p>Decorators, however, allow us to inject code into the actual definition of a class <strong>before a class instance has been created</strong>. They are similar to <strong>attributes</strong> in C# or annotations in Java.
Angular, where they are primarily used for dependency injection, or Vue, where they are used to inject functions into a class definition.
Decorators provide <strong>a mechanism to add metadata, modify behavior, validate, or extend the functionality</strong> of the target element. They are functions that execute at runtime. Multiple decorators can be applied to a declaration.</p>
<p>Decorators are experimental features, and the following examples are only compatible with TypeScript version 5 or above using ES6.</p>
<p>A decorator is a function that is called with a specific set of parameters. These parameters are automatically populated by the JavaScript runtime and contain information about the class, method, or property to which the decorator has been applied. The number of parameters, and their types, determine where a decorator can be applied. </p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
logs a message to the console, indicating that it has been invoked.</li>
<li><input disabled="" type="checkbox" checked=""/>
Decorators are only invoked once when a class is defined.</li>
<li><input disabled="" type="checkbox" checked=""/>
Decorators are <strong>called in the reverse order</strong> of their appearance within our code.</li>
</ul>
<p>To illustrate this syntax, let’s define a class decorator as follows:</p>
<pre><code class="language-typescript">function simpleDecorator(constructor: Function) {
 console.log('simpleDecorator called');
}
function secondDecorator(constructor: Function) {
 console.log(`secondDecorator called`);
}

@simpleDecorator
@secondDecorator
class ClassWithSimpleDecorator {
}
let instance_1 = new ClassWithSimpleDecorator();
let instance_2 = new ClassWithSimpleDecorator();
console.log(`instance_1 : ${JSON.stringify(instance_1)}`);
console.log(`instance_2 : ${JSON.stringify(instance_2)}`);
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">secondDecorator called
simpleDecorator called
instance_1 : {}
instance_2 : {}
</code></pre>
<p>For TypeScript versions prior to 5, they should be enabled using the <code>experimentalDecorators</code> property in your <code>tsconfig.json</code> or by using <code>--experimentalDecorators</code> in your command line (but the following example won’t work).</p>
<p><strong>Some of the common use cases for decorators include</strong>:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Watching property changes.</li>
<li><input disabled="" type="checkbox" checked=""/>
Watching method calls.</li>
<li><input disabled="" type="checkbox" checked=""/>
Adding extra properties or methods.</li>
<li><input disabled="" type="checkbox" checked=""/>
Runtime validation.</li>
<li><input disabled="" type="checkbox" checked=""/>
Automatic serialization and deserialization.</li>
<li><input disabled="" type="checkbox" checked=""/>
Logging.</li>
<li><input disabled="" type="checkbox" checked=""/>
Authorization and authentication.</li>
<li><input disabled="" type="checkbox" checked=""/>
Error guarding.</li>
</ul>
<p>Note: Decorators for version 5 do not allow decorating parameters.</p>
<p>Let’s take a quick look at the types of decorators, which are:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Class decorators: These are decorators that can be applied to a class definition.</li>
<li><input disabled="" type="checkbox" checked=""/>
Property decorators: These are decorators that can be applied to a property within a class.</li>
<li><input disabled="" type="checkbox" checked=""/>
Method decorators: These are decorators that can be applied to a method on a class.</li>
<li><input disabled="" type="checkbox" checked=""/>
Parameter decorators: These are decorators that can be applied to a parameter of a method within a class.</li>
</ul>
<pre><code class="language-typescript">// Define a function called classDecorator which takes a constructor function as input
function classDecorator(
  constructor: Function
) {}

// Define a function called propertyDecorator which takes an object and a string property key as input
function propertyDecorator(
  target: any,
  propertyKey: string
) {}

// Define a function called methodDecorator which takes an object, a string method name, and an optional property descriptor object as input
function methodDecorator(
  target: any,
  methodName: string,
  descriptor?: PropertyDescriptor
) {}

// Define a function called parameterDecorator which takes an object, a string method name, and a number representing a parameter index as input
function parameterDecorator(
  target: any,
  methodName: string,
  parameterIndex: number
) {}

// Define a class called ClassWithAllTypesOfDecorators and apply the classDecorator to it
@classDecorator
class ClassWithAllTypesOfDecorators {
  // Apply the propertyDecorator to the id property of the class
  @propertyDecorator
  id: number = 1;

  // Apply the methodDecorator to the print method of the class
  @methodDecorator
  print() { }

  // Apply the parameterDecorator to the id parameter of the setId method of the class
  setId(@parameterDecorator id: number) { }
}

</code></pre>
<h2 id="decorator-factories"><a class="header" href="#decorator-factories">Decorator factories</a></h2>
<p>We can see that the anonymous function returned by the decoratorFactory function is invoked with the string “testName” as the value of the name argument.</p>
<p>There are two things to note regarding decorator factory functions.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Firstly, they must return a function that has the correct number of parameters and types of parameters, depending on what type of decorator they are.</li>
<li><input disabled="" type="checkbox" checked=""/>
Secondly, the parameters defined for the decorator factory function can be used anywhere within the function definition, which includes within the anonymous decorator function itself.</li>
</ul>
<pre><code class="language-typescript">function decoratorFactory(name: string) {
  // Return a decorator function that takes a constructor function as input and logs the name parameter to the console
  return (constructor: Function) =&gt; {
    console.log(`decorator function called with : ${name}`);
  }
}
// Apply the decorator generated by decoratorFactory function to the ClassWithDecoratorFactory class
@decoratorFactory('testName')
class ClassWithDecoratorFactory {
}
</code></pre>
<hr />
<p><code>Can a class decorator be used to modify the constructor of a class in TypeScript?</code></p>
<p>Yes, by defining a new constructor function and assigning it to the constructor property of the class.
ref.to decorator-ex-11(ex-13).ts</p>
<p><code>Can a method decorator modify the behavior of the method it is decorating in TypeScript?</code>
Yes, a method decorator can modify the method’s behavior by wrapping the method in a new function or modifying its implementation directly.</p>
<p><code>Can a property decorator be used to modify the type of a property in TypeScript?</code>
No, the type of a property can’t be modified by a decorator.</p>
<p>Types of decorators:</p>
<h4 id="class-decorators"><a class="header" href="#class-decorators">Class Decorators</a></h4>
<p>Class Decorators are useful for extending an existing class, such as adding properties or methods, or collecting instances of a class. In the following example, we add a <code>toString</code> method that converts the class into a string representation.</p>
<pre><code class="language-typescript">type Constructor&lt;T = {}&gt; = new (...args: any[]) =&gt; T;

function toString&lt;Class extends Constructor&gt;(
    Value: Class,
    context: ClassDecoratorContext&lt;Class&gt;
) {
    return class extends Value {
        constructor(...args: any[]) {
            super(...args);
            console.log(JSON.stringify(this));
            console.log(JSON.stringify(context));
        }
    };
}

@toString
class Person {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    greet() {
        return 'Hello, ' + this.name;
    }
}
const person = new Person('Simon');
/*- [x]* Logs:
{&quot;name&quot;:&quot;Simon&quot;}
{&quot;kind&quot;:&quot;class&quot;,&quot;name&quot;:&quot;Person&quot;}
*/
</code></pre>
<h4 id="property-decorator"><a class="header" href="#property-decorator">Property Decorator</a></h4>
<p>Property decorators are useful for modifying the behavior of a property, such as changing the initialization values. In the following code, we have a script that sets a property to always be in uppercase:</p>
<pre><code class="language-typescript">function upperCase&lt;T&gt;(
    target: undefined,
    context: ClassFieldDecoratorContext&lt;T, string&gt;
) {
    return function (this: T, value: string) {
        return value.toUpperCase();
    };
}

class MyClass {
    @upperCase
    prop1 = 'hello!';
}

console.log(new MyClass().prop1); // Logs: HELLO!
</code></pre>
<h4 id="method-decorator"><a class="header" href="#method-decorator">Method Decorator</a></h4>
<p>Method decorators allow you to change or enhance the behavior of methods. Below is an example of a simple logger:</p>
<pre><code class="language-typescript">function log&lt;This, Args extends any[], Return&gt;(
    target: (this: This, ...args: Args) =&gt; Return,
    context: ClassMethodDecoratorContext&lt;
        This,
        (this: This, ...args: Args) =&gt; Return
    &gt;
) {
    const methodName = String(context.name);

    function replacementMethod(this: This, ...args: Args): Return {
        console.log(`LOG: Entering method '${methodName}'.`);
        const result = target.call(this, ...args);
        console.log(`LOG: Exiting method '${methodName}'.`);
        return result;
    }

    return replacementMethod;
}

class MyClass {
    @log
    sayHello() {
        console.log('Hello!');
    }
}

new MyClass().sayHello();
</code></pre>
<p>It logs:</p>
<pre><code class="language-bash">LOG: Entering method 'sayHello'.
Hello!
LOG: Exiting method 'sayHello'.
</code></pre>
<h4 id="getter-and-setter-decorators"><a class="header" href="#getter-and-setter-decorators">Getter and Setter Decorators</a></h4>
<p>Getter and setter decorators allow you to change or enhance the behavior of class accessors. They are useful, for instance, for validating property assignments. Here’s a simple example for a getter decorator:</p>
<pre><code class="language-typescript">function range&lt;This, Return extends number&gt;(min: number, max: number) {
    return function (
        target: (this: This) =&gt; Return,
        context: ClassGetterDecoratorContext&lt;This, Return&gt;
    ) {
        return function (this: This): Return {
            const value = target.call(this);
            if (value &lt; min || value &gt; max) {
                throw 'Invalid';
            }
            Object.defineProperty(this, context.name, {
                value,
                enumerable: true,
            });
            return value;
        };
    };
}

class MyClass {
    private _value = 0;

    constructor(value: number) {
        this._value = value;
    }
    @range(1, 100)
    get getValue(): number {
        return this._value;
    }
}

const obj = new MyClass(10);
console.log(obj.getValue); // Valid: 10

const obj2 = new MyClass(999);
console.log(obj2.getValue); // Throw: Invalid!
</code></pre>
<h4 id="decorator-metadata"><a class="header" href="#decorator-metadata">Decorator Metadata</a></h4>
<p>Decorator Metadata simplifies the process for decorators to apply and utilize metadata in any class. They can access a new metadata property on the context object, which can serve as a key for both primitives and objects.
Metadata information can be accessed on the class via <code>Symbol.metadata</code>.</p>
<p>we will need to set the emitDecoratorMetadata flag in our tsconfig.json file to true as follows:</p>
<pre><code class="language-json">{
 &quot;compilerOptions&quot;: {
 // other compiler options
 &quot;experimentalDecorators&quot;: true,
 &quot;emitDecoratorMetadata&quot;: true
 }
}
</code></pre>
<p>For example</p>
<pre><code class="language-typescript">function metadataParameterDec(
 target: any,
 methodName: string,
 parameterIndex: number
) {}
// Define a class called `ClassWithMetadata`.
class ClassWithMetadata {
 // Define a method called `print`.
 print(
  // Apply `metadataParameterDec` decorator on `id` parameter.
  @metadataParameterDec id: number, name: string
 ) {}
}

</code></pre>
<p>If the emitDecoratorMetadata flag of our tsconfig.json file is <strong>set to false</strong> or is not present, then the compiler will emit the following JavaScript:</p>
<pre><code class="language-typescript">function metadataParameterDec(target, methodName, parameterIndex) {
}
var ClassWithMetadata = /** @class */ (function () {
    function ClassWithMetadata() {
    }
    ClassWithMetadata.prototype.print = function (id, name) {
    };
    __decorate([
        __param(0, metadataParameterDec)
    ], ClassWithMetadata.prototype, &quot;print&quot;, null);
    return ClassWithMetadata;
}());
</code></pre>
<p>Generated JS will show more info with inject code of __decorate because we enable the feature of <strong>emitDecoratorMetadata=true</strong></p>
<pre><code class="language-js">function metadataParameterDec(target, methodName, parameterIndex) {
}
var ClassWithMetadata = /** @class */ (function () {
    function ClassWithMetadata() {
    }
    ClassWithMetadata.prototype.print = function (id, name) {
    };
    __decorate([
        __param(0, metadataParameterDec),
        __metadata(&quot;design:type&quot;, Function),
        __metadata(&quot;design:paramtypes&quot;, [Number, String]),
        __metadata(&quot;design:returntype&quot;, void 0)
    ], ClassWithMetadata.prototype, &quot;print&quot;, null);
    return ClassWithMetadata;
}());
</code></pre>
<p>The information that is recorded by the TypeScript compiler when using the emitDecoratorMetadata compiler flag can be read and interpreted at runtime.</p>
<p><code>Note:</code> <strong>As reflect-metadata is a third-party</strong> library, we need to install it using npm install reflect-metadata when using on a local machine.</p>
<p>We can now start to use this metadata by calling the Reflect.getMetadata function that this library provides, as follows:</p>
<pre><code class="language-typescript">import 'reflect-metadata';

function reflectParameterDec(target: any,
 methodName: string,
 parameterIndex: number)
{
 let designType = Reflect.getMetadata(
 &quot;design:type&quot;, target, methodName);
 console.log(`design type: ${designType.name}`)
 let designParamTypes = Reflect.getMetadata(
 &quot;design:paramtypes&quot;, target, methodName);
 for (let paramType of designParamTypes) {
 console.log(`param type : ${paramType.name}`);
 }
 let designReturnType = Reflect.getMetadata(
 &quot;design:returntype&quot;, target, methodName);
 console.log(`return types : ${designReturnType.name}`);
}

class ClassWithReflectMetaData {
 print(
 @reflectParameterDec
 id: number,
 name: string
 ): number
 {
 return 1000;
 }
}

</code></pre>
<p>When we run this code snippet, we get the following output:</p>
<pre><code class="language-md">design type: Function
param type : Number
param type : String
return types : Number
</code></pre>
<p><code>&gt;tags:</code> [[Important]] [[Debug]] [[Serialization]] [[Dependency_Injection]] [[Decorator]]</p>
<p>Using decorator metadata allows us to retain some of this type of information and opens the door to using this type of information to <strong>generate code analysis tools</strong>, for example, or to write frameworks for dependency injection.</p>
<blockquote>
<p>Metadata can be used for various purposes, such as debugging, serialization, or dependency injection with decorators.</p>
</blockquote>
<pre><code class="language-typescript">//@ts-ignore
Symbol.metadata ??= Symbol('Symbol.metadata'); // Simple polify

type Context =
    | ClassFieldDecoratorContext
    | ClassAccessorDecoratorContext
    | ClassMethodDecoratorContext; // Context contains property metadata: DecoratorMetadata

function setMetadata(_target: any, context: Context) {
    // Set the metadata object with a primitive value
    context.metadata[context.name] = true;
}

class MyClass {
    @setMetadata
    a = 123;

    @setMetadata
    accessor b = 'b';

    @setMetadata
    fn() {}
}

const metadata = MyClass[Symbol.metadata]; // Get metadata information

console.log(JSON.stringify(metadata)); // {&quot;bar&quot;:true,&quot;baz&quot;:true,&quot;foo&quot;:true}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<p>One of the most powerful and popular JavaScript libraries that specializes in event processing is the Reactive Extensions for JavaScript library, or simply RxJS.</p>
<p>What is an Observable in the context of RxJS?
<strong>It’s an object that emits values over time.</strong></p>
<p>What is the purpose of the pipe operator in RxJS?
<strong>To transform the values emitted by an Observable.</strong></p>
<p><strong>RxJS uses the Gang of Four (GoF) design pattern</strong>, named the Observable pattern, as the basis for registering interest in an event, as well as doing something when an event has been triggered. Along with these basic principles of the Observer design pattern, RxJS provides a plethora of utility functions to transform event data as and when it comes in.</p>
<p>At the heart of the RxJS library is the concept of Observables, which are source event streams. This has given rise to using the term Observables to describe RxJS source streams and what can be done to them. So when someone says use Observables, they really mean use the RxJS library with its source streams and utility functions.</p>
<p>We will explore Observables, which really means the RxJS library, how it is used, and how it can help us when working with <strong>event-based or asynchronous data</strong>.
<strong>In essence, subscribers are alive as long as the Observable stream is emitting values.</strong></p>
<h3 id="pipe"><a class="header" href="#pipe">Pipe</a></h3>
<p>The RxJS library provides a pipe function to all Observables, <strong>similar to the subscribe function</strong>. This pipe function takes a variable number of functions as parameters and will execute these functions on each value that is emitted by the Observable.</p>
<p>The functions that are provided to <strong>the pipe function are generally known as Observable operators</strong>, which all accept an Observable as input, and return an Observable as output. The pipe function emits an Observable stream.The pipe function allows us to combine multiple operator functions, which will each be applied to the values emitted by an Observable.</p>
<h3 id="avoid-swallowing-values"><a class="header" href="#avoid-swallowing-values">Avoid Swallowing Values</a></h3>
<p>because the map function does not return a value, our subscribe function on line 8 must define the type of the incoming value parameter as void.
Unfortunately, the emitted value will be undefined because we have not returned anything within our map function.</p>
<pre><code class="language-ts">import { map, of } from &quot;rxjs&quot;;
const emitOneTwo = of(1, 2); // create an Observable that emits 1 and 2
const swallowedValues = emitOneTwo.pipe(
  map((value: number) =&gt; {
    console.log(`swallowing ${value}`); // log value but don't return it
    // not returning a value;
  })
);
swallowedValues.subscribe((value: void) =&gt; {
  console.log(`subscriber received value: ${value}`); // log the void value received
});
</code></pre>
<p>Solution:</p>
<pre><code class="language-ts">// Observable emitting values of type number or null
const swallowedValues: Observable&lt;number | null&gt; =
  emitOneTwo.pipe(
    // Map emitted values based on a condition
    map((value: number) =&gt; {
      if (value &lt; 2) {
        return null;
      }
      return value;
    })
  );

// Subscribe to the Observable and log received values
swallowedValues.subscribe((value: number | null) =&gt; {
  console.log(`subscriber received value: ${value}`)
});

</code></pre>
<p>Failing to return a value will automatically make the entire Observable return a type of unknown.</p>
<p>It is, therefore, good practice to strongly type the parameters of subscribe functions so that we know what value we are expecting an Observable to emit.</p>
<h3 id="the-mergemap-operator"><a class="header" href="#the-mergemap-operator">The mergeMap operator</a></h3>
<p><code>&gt;tags:</code> [[Important]] [[Observer]] [[MergeMap]] [[Operator]] [[Subscribe]]
The mergeMap operator is used to return a single value from an Observable stream, so that we do not need to subscribe to the inner Observable.</p>
<p><code>Ref.To Observer-ex10-11</code></p>
<pre><code class="language-ts">productList
  .pipe(
    // Map each product ID to an Observable of its name and description
    map((value: IProductId) =&gt; {
      console.log(`Product id: ${value.id}`); // Log the product ID
      return getProductName(value.id); // Return an Observable of the product name and description
    })
  )
  .subscribe((value: Observable&lt;IProductDescription&gt;) =&gt; {
    // Subscribe to each Observable of product names and descriptions
    value.subscribe((value: IProductDescription) =&gt; {
      console.log(`product name : ${value.name}`); // Log the product name
      console.log(`product desc : ${value.description}`); // Log the product description
    });
  });
</code></pre>
<p>To:</p>
<pre><code class="language-ts">productList.pipe(
  // Use mergeMap to flatten the nested Observable stream returned by getProductName
  mergeMap((value: IProductId): Observable&lt;IProductDescription&gt; =&gt; {
    // Log the current product ID
    console.log(`Product id: ${value?.id}`);
    // Use getProductName to fetch the name and description of the current product
    return getProductName(value.id);
  })
).subscribe((value: IProductDescription) =&gt; {
  // Log the name and description of each product returned by getProductName
  console.log(`product name : ${value.name}`)
  console.log(`product desc : ${value.description}`)
});
</code></pre>
<p>Note: The code for this mergeMap function is identical to our earlier map function, where it logs a message to the console and then calls the getProductName function with the id property of the value passed in as an argument. The difference between this code sample and the previous code sample is in the subscribe function.</p>
<h3 id="concatmap-operator"><a class="header" href="#concatmap-operator">ConcatMap Operator</a></h3>
<p><code>&gt;tags:</code> [[Important]] [[ConcatMap]]
We are receiving values emitted by the Observable based on the time that they were emitted.
Note, too, that we have three emit events followed by three receive events. This means that each value received by the delayedEmit Observable is processed immediately.
If it is important to process the emitted values in order, no matter when they arrive, we can use the concatMap function <strong>instead of the mergeMap function</strong>.</p>
<pre><code class="language-ts">import { concatMap, delay, of } from &quot;rxjs&quot;;

// Create an observable that emits values 3, 2, 1
const emitTreeTwoOne = of(3, 2, 1);

// Create a new observable that delays each emission from emitTreeTwoOne based on its value
const delayedEmit = emitTreeTwoOne.pipe(
  concatMap((value: number) =&gt; {
    console.log(
      `&gt;&gt; emit &gt;&gt;
       ${new Date().toLocaleTimeString()}
       value: ${value},
       delaying: ${1000 * value} ms`
    );
    // Emit the value after a delay
    return of(value).pipe(delay(1000 * value))
  })
);

// Subscribe to the delayedEmit observable to receive its emissions
delayedEmit.subscribe(value =&gt; {
  console.log(`&lt;&lt; receive &lt;&lt;
    ${new Date().toLocaleTimeString()}
    received value: ${value}`);
});
</code></pre>
<p><code>&gt; Output witch concatMap:</code></p>
<pre><code class="language-md">&gt;&gt; emit &gt;&gt;
...
&lt;&lt; receive &lt;&lt;
&gt;&gt; emit &gt;&gt;
...
&lt;&lt; receive &lt;&lt;
</code></pre>
<p><code>&gt; Output witch mergeMap:</code></p>
<pre><code class="language-md">&gt;&gt; emit &gt;&gt;
...
&gt;&gt; emit &gt;&gt;
...
&lt;&lt; receive &lt;&lt;
&lt;&lt; receive &lt;&lt;
</code></pre>
<h3 id="forkjoin-in-rxjs"><a class="header" href="#forkjoin-in-rxjs">forkJoin in RxJS</a></h3>
<p><code>&gt;tags:</code> [[Important]] [[ForkJoin]]</p>
<p><strong>forkJoin operator can be used to combine the latest values emitted by two or more Observables.</strong>
When we have a number of Observable streams that need to all complete before we do something, we can use the forkJoin function. This situation occurs quite often when dealing with REST requests at the start of a page load, where the page may need to load data from a number of different REST APIs before displaying the page.
Let’s assume that we are building a web page to show products available in a catalog.</p>
<p>What might we want on this page?</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
We may need one REST request that loads a store catalog based on the current date and another REST request that loads sales specials for the day.</li>
<li><input disabled="" type="checkbox" checked=""/>
Our page may want to display the sale items on the top of the page or in a scrolling banner, as well as all store items in the main body of the page.</li>
<li><input disabled="" type="checkbox" checked=""/>
We may also need a further REST request to load information related to the customer, such as their logged-in status or their country of origin.</li>
<li><input disabled="" type="checkbox" checked=""/>
Only <strong>when all of these requests have been completed can we display the page in full</strong> and allow the customer to add items to their shopping basket.</li>
</ul>
<p><strong>forkJoin solves timing issues with multiple streams</strong></p>
<p>Let’s see how the forkJoin function helps in this case:</p>
<pre><code class="language-ts">const threeNumbers: Observable&lt;number[]&gt; //= ...
const twoStrings: Observable&lt;string[]&gt; //= ...
forkJoin(
  [threeNumbers, 
     twoStrings]
).subscribe(
([threeNumbersOutput, twoStringsOutput]) =&gt; {
  console.log(`&lt;&lt; threeNumbersOutput: ${threeNumbersOutput}`);
  console.log(`&lt;&lt; twoStringsOutput: ${twoStringsOutput}`);
}
);
</code></pre>
<h3 id="multicasting-with-the-subject-class"><a class="header" href="#multicasting-with-the-subject-class">Multicasting with the Subject class</a></h3>
<p><code>&gt;tags:</code> [[Important]] [[Subject]] [[Subscriber]] [[Observer]] #Event_Bus</p>
<p>So, what if we want to keep an Observable stream open and register one or more subscribers that will wait around until a new value is emitted? Think in terms of an event bus, where multiple subscribers register their interest in a topic on an event bus and then react when an event is raised that they are interested in. RxJS provides the Subject class for this express purpose.</p>
<p>A Subject maintains a list of listeners that have registered their interest. A Subject is also an Observable stream, and therefore, listeners can subscribe to the stream and use the same syntax and functions that are used for normal Observable streams.</p>
<p>What makes a Subject interesting is that it has the ability to multicast, which means that it <strong>allows multiple subscribers to the same stream and will notify all interested subscribers when an event happens.</strong></p>
<pre><code class="language-ts">//...
class Listener {
  private eventSubscription: Subscription;
  constructor(
    broadCastService: BroadcastService,
    eventKey: EventKeys,
    private listenerName: string
  ) {
    _.bindAll(this, &quot;reactToEvent&quot;);
    this.eventSubscription = broadCastService
      .on(eventKey)
      .subscribe(this.reactToEvent);
  }
  private reactToEvent(event: string) {
    console.log(`Listener [${this.listenerName}]
      received event : ${event}`);
  }
  public unregister() {
    this.eventSubscription.unsubscribe();
  }
}
//...
</code></pre>
<p>The implementation of the constructor starts with a call to the underscore function named bindAll on line 8, which binds the value of this within a class function to the class instance itself. Remember that when an instance of the class BroadcastService emits an event, it will emit the event with its own scoped value of this.</p>
<p>In other words, when an event is emitted by the Broadcast service, the this variable will be scoped to be this as seen by the BroadcastService class instance and not this as seen by the instance of the Listener class instance.</p>
<p>Calling the bindAll function with this as seen by the Listener class instance and the name of the function to bind to, “reactToEvent”, will ensure that when the reactToEvent is called, this will refer to this as scoped to the Listener class instance.</p>
<p>Following our bindAll function call, the constructor then sets the class property named eventSubscription, on line 9, to the Observable returned by the on function of the BroadcastService. Note how we are calling the on function with the value of the eventKey parameter in order to register for specific events we are interested in.</p>
<p>We then subscribe to the Observable stream returned by the on function on line 11 and call the reactToEvent function defined in the Listener class.</p>
<p>Using an event bus within our code is a powerful design pattern that can be used when completely unrelated components need to be notified of a particular event. Think of the case where a user logs out of a website. They may have an open shopping cart and may also be viewing content that is only available to registered users. We can build an event bus to notify all interested components of an event, such as the user logging out, and each component can then take the necessary steps to modify their rendered content accordingly. An event bus allows us <strong>to utilize a design pattern known as the Domain Events Pattern</strong>, where multiple components can react to a specific domain event.</p>
<p>This design pattern strengthens the quality and extensibility of our code base by allowing each component to focus on its particular area of interest and also reacting to external events that occur across the entire domain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singleton-pattern"><a class="header" href="#singleton-pattern">Singleton Pattern</a></h1>
<p>The conventional singleton pattern is really something that is used to overcome the fact that all code must be in a <code>class</code>.</p>
<pre><code class="language-typescript">class Singleton {
    private static instance: Singleton;
    private constructor() {
        // do something construct...
    }
    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
            // ... any one time initialization goes here ...
        }
        return Singleton.instance;
    }
    someMethod() { }
}

let something = new Singleton() // Error: constructor of 'Singleton' is private.

let instance = Singleton.getInstance() // do something with the instance...
</code></pre>
<p>However, if you don’t want lazy initialization you can instead just use a <code>namespace</code>: </p>
<pre><code class="language-typescript">namespace Singleton {
    // ... any one time initialization goes here ...
    export function someMethod() { }
}
// Usage
Singleton.someMethod();
</code></pre>
<blockquote>
<p>Warning : Singleton is just a fancy name for <a href="http://stackoverflow.com/a/142450/390330">global</a></p>
</blockquote>
<p>For most projects <code>namespace</code> can additionally be replaced by a <em>module</em>.</p>
<pre><code class="language-typescript">// someFile.ts
// ... any one time initialization goes here ...
export function someMethod() { }

// Usage
import {someMethod} from &quot;./someFile&quot;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h2>
<p>In any programming language, functions are said to be <strong>first-class citizens</strong> if they can be treated like any other variable. For instance, they can be passed as an argument to other functions, can be returned by another function, and can be assigned as a value to a variable.</p>
<p><code>first-class citizens</code>
Functions can be treated as ordinary values. They can be passed in as parameters, returned from other functions, and so on.
What are not the advantages of types? Types make code compilation faster.</p>
<p><code>&gt; Note:</code> In functional programming, we write programs by letting objects interact with each other is a myth.</p>
<p>What are the advantages of functional programming?</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Functional programming helps us deal with parallel programming.</li>
<li><input disabled="" type="checkbox" checked=""/>
Functional programming makes managing complex applications easier.</li>
</ul>
<p>To write functional code in JavaScript, we can turn to <strong>libraries such as Lodash, Ramda, or Folktale.</strong>
We’ve already discussed Ramda Ramda and Folktale, but unfortunately, they’re insufficient. Ramda lacks the extremely useful concept of monads, on which several more advanced functional programming techniques are based. Folktale is a small library with some of the essential monads, but it has very few other features. It lacks some more powerful functional programming features like monad transformers. Another disadvantage of Folktale is that the library hasn’t received much support during the last few years.</p>
<p>Instead, we’ll use a TypeScript library called <strong>fp-ts</strong>. It has several advantages:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
It’s written in TypeScript.</li>
<li><input disabled="" type="checkbox" checked=""/>
It has many stars on GitHub.</li>
<li><input disabled="" type="checkbox" checked=""/>
It’s actively maintained.</li>
<li><input disabled="" type="checkbox" checked=""/>
It has powerful monads.</li>
<li><input disabled="" type="checkbox" checked=""/>
It has an ecosystem of libraries that add even more functionality.</li>
</ul>
<h3 id="statement-vs-expression"><a class="header" href="#statement-vs-expression">Statement vs Expression</a></h3>
<p>What is the difference between a statement and an expression?
An expression always produces a value; a statement does not.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>However, be sure to set the target property in tsconfig.json no lower than es6. Later on, we will use webpack to build our output and show the tsconfig.json file that goes with that setup.</p>
<pre><code class="language-bash">pnpm i --save fp-ts@~2.8.6
</code></pre>
<h2 id="closure"><a class="header" href="#closure">Closure</a></h2>
<p>Closures can be used to <strong>hide information</strong> from other functions.
The behaviour depicted in the code snippet below is called closure. With closures, the inner function has access to all the information available in the outer function. This is why the value of the parameter outer is still available when we call ourInnerFunction that was returned from withInnerFunction.
The functions receiving or returning other functions are called <strong>higher-order functions</strong>.</p>
<pre><code class="language-ts">function withInnerFunction(outer) {
    return function ourInnerFunction(inner) {
        console.log(`Outer function received ${outer}, inner got ${inner}`);
    };
}

const returnedFunction = withInnerFunction('a');

// some time later in our program, we actually need to call returnedFunction 
returnedFunction('b');
</code></pre>
<p>To:</p>
<pre><code class="language-ts">const withInnerFunction = (outer) =&gt; (inner) =&gt; console.log(`Outer function received ${outer}, inner ${inner}`);
const returnedFunction = withInnerFunction('a');
returnedFunction('b');
</code></pre>
<p>This is interesting because it allows us to pass additional information that might <strong>serve as an environment or state into our function.</strong> Closures and first-class functions allow for more interesting behavior such <strong>as creating factories for building functions, keeping parameter lists short, reducing code duplication, and so on</strong>. Furthermore, <em>closures are the only way to make a variable private in JavaScript because we can circumvent all the other methods.</em></p>
<p>Note: Arrow functions are essentially the same as functions defined using the function keyword, except when it comes to the this keyword. However, we will not use the this keyword in this course.</p>
<h3 id="adts--pipes"><a class="header" href="#adts--pipes">ADTs | Pipes</a></h3>
<p>Algebraic data types (ADTs) in functional programming can be extremely useful. We’ll discuss them in detail later on. However, in TypeScript, we can use <strong>discriminating unions (also called tagged unions) to get sum types</strong>. These sum types are a category of ADTs, and creating them does require a bit of ceremony, though. In a language like Haskell, we can make very powerful pattern matching on sum types. There are libraries in the fp-ts ecosystem that try to add some of this power to TypeScript, e.g., <strong>morphic-ts</strong>. However, TypeScript can already do some cool things with these unions.
Product types is a kind of ADTs that allow us to easily model subtypes that have different properties, occusionally, the need for optional values or (boolean) flags.</p>
<h2 id="pure-function"><a class="header" href="#pure-function">Pure Function</a></h2>
<p>A pure function is one with a result that’s based solely on the input it receives. So, as long as the input doesn’t change, the output doesn’t change either. This means that it has <strong>no side effects</strong>. <strong>So A pure function is not a function that always returns a value.</strong></p>
<h2 id="referential-transparency"><a class="header" href="#referential-transparency">Referential Transparency</a></h2>
<p>A related concept, referential transparency, also helps us in coding. It means that we can replace a function call with the value it produces. </p>
<pre><code class="language-ts">function biggerProgram() {
    const result = addOne(5);
    return result * 2;
}
</code></pre>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>Immutability is another frequently mentioned element of functional programming. <strong>Instead of changing our existing data structures, we create new data structures</strong> whenever we change any information. This makes reasoning easier. No other process could’ve changed the array we just received from our function because it’s an entirely new data structure! We can see another obvious advantage of immutability in parallel programming. In the words of Adam Smith, “Threads coming together with mutable data ends in a conspiracy against your sanity”.</p>
<p>Note: Even when we’re not doing any fancy parallel programming, some easily <strong>missed mutability bugs can waste our time</strong>. For instance, <em>let’s assume we have arrays of the const type, and we’re using shift to get the first element of those arrays. The usage of shift mutates our arrays in place. Such bugs can cause problems within our program.</em></p>
<p><strong>Performance may suffer in some cases</strong>, especially when our language isn’t written for immutability. As always, this is a matter of trade-offs. Is excellent performance essential, or is the combination of a lack of bugs, easier maintenance, and decent performance acceptable?</p>
<p>Note: <strong>JavaScript, sadly, wasn’t written with immutability in mind</strong>. Therefore, several <em>libraries offer to add immutable data structures.</em> It’s better to have the language handle everything for us, though, despite the loss of immutability.</p>
<h2 id="declarative-programming-style"><a class="header" href="#declarative-programming-style">Declarative programming style</a></h2>
<p>Functional programming tries to lift this behavior to a higher level of <strong>abstraction</strong>. Whenever possible, the low-level behavior is left to the computer.
First, functional programming offers a more <strong>declarative</strong> style of programming. Object-oriented programming has an <strong>imperative</strong> feel because our program consists of a list of instructions to execute (or objects to execute). 
Declarative: I want a dinner with chicken.
Imperative: Kitchen -&gt; Open Fridge -&gt;  Removing Chicken from Fridge -&gt; Dinner on the table.</p>
<p>Declarative example:</p>
<pre><code class="language-ts">const exampleArray = [1, 2, 3, 4];

function addOneToEach(arr) {
    for(let i = 0; i &lt; arr.length; i++) {
        arr[i] = arr[i] + 1; //mutable data structures
    }
    return arr;
}

console.log(addOneToEach(exampleArray));
</code></pre>
<p>Imperative example:</p>
<pre><code class="language-ts">const exampleArray = [1, 2, 3, 4];

function fpAddOneToEach(arr) {
    return arr.map(el =&gt; el + 1); // add 1 to each element of array, immutable data structures
}

console.log(fpAddOneToEach(exampleArray));
</code></pre>
<p><strong>Another advantage of higher-order functions is that they often use immutable data structures</strong>. 
<strong>The loop in the first example above, on the other hand, mutates the existing array and is error prone(imperative)</strong></p>
<p>Note: Modify the second code snippet above and include the loop version (from the first example), followed by the functional programming version (from the second example). Notice how the functional programming version now returns [3, 4, 5, 6] instead of [2, 3, 4, 5]. This is because the exampleArray has been modified by the loop version.</p>
<h2 id="tacit-programming"><a class="header" href="#tacit-programming">Tacit programming</a></h2>
<p>Recall composition and our addOne function from an earlier example. Using it within map is trivial, as shown below.</p>
<pre><code class="language-ts">const exampleArray = [1, 2, 3, 4];

function addOne(el) {
    return el + 1;
}

function fpAddOneToEach(arr) {
    return arr.map(addOne);
}

console.log(fpAddOneToEach(exampleArray));
</code></pre>
<p>The above is called <strong>point-free style or tacit programming</strong>. The function we passed in expects one argument, and map produces one. We don’t have to write <code>el =&gt; addOne(el)</code> because JavaScript knows it has to pass the incoming value to the function.</p>
<p>So, with <strong>higher-order functions like filter and map</strong>, <em>we only have to write logic that filters or transforms a single element. The rest is handled by the higher-order function</em>. 
We know how to increment a single value, and we can now handle arrays without writing any additional code!</p>
<p>Additionally, in functional languages, maps are available for more than just arrays, further extending the usefulness of this function. Because functions like <strong>map and filter are more abstract</strong> and less bound to specifics, they can be applied in many situations. They work with any kind of array we throw at them. In contrast, the object methods only know how to do things for one specific class. </p>
<p><code>The corresponding Javadoc mentions the following:</code></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Stream pipeline results may be <strong>nondeterministic or incorrect</strong> if the behavioral parameters to the <strong>stream operations are stateful</strong>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Side effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards.</li>
</ul>
<p>In summary, choose pure functions for reliable behavior when using streams. The Javadoc notes in several locations that this is also a requirement for parallelism, for reasons that are no longer a mystery. That is, pure functions behave in a predictable fashion. However, with side effects and mutations, the result might be unpredictable.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Recursion is another way that functional programming deals with repetition and avoiding loops. Recursion means <strong>solving a problem by breaking it up into smaller problems</strong>.</p>
<p>Recursion often leads to elegant solutions for complicated problems. However, it’s not frequently used in mainstream languages like JavaScript because the <strong>repeated function calls cause the stack to grow</strong>, possibly resulting in a stack overflow. In this course, we’ll mainly use <strong>higher-order functions to solve problems involving repetition.</strong></p>
<h2 id="higher-order-functions-and-composition"><a class="header" href="#higher-order-functions-and-composition">Higher-order functions and composition</a></h2>
<p><strong>The composition order (right to left)</strong> is probably inspired by mathematics. That is, if we have an f(g(x)) function, we first calculate g(x) and pass the result, y, to the outer function, f(y).</p>
<p>Abstraction makes the program cleaner, shorter, and reusable.</p>
<p>we created new functionality out of existing functions, similar to what we did with map and filter. The composition has several nice qualities to it. For one, we don’t have to change our existing functions. Instead, our new functionality is created out of existing code</p>
<pre><code class="language-ts">const compose = (...fns) =&gt; (...args) =&gt; {
    return fns.reduceRight((res, fn) =&gt; [fn.call(null, ...res)], args)[0];
};

const coolName = (name) =&gt; `${name} a.k.a. King`;
const yelling = (name) =&gt; name.toUpperCase();
const yellingACoolerName = compose(yelling, coolName);
const result = yellingACoolerName('sam'); //Line 10
console.log(result); //Output: SAM A.K.A. KING
</code></pre>
<p>Line 10: We start with a reduceRight on our array of functions. First up is coolName, which receives the sam parameter as the preliminary result. The function is called and adds a cool suffix to the name. Next, our reduce starts working on the yelling function. It, too, receives a preliminary result, which is the name with the suffix that was just added. It returns this parameter in uppercase.</p>
<p><code>Note:</code>
For those with Linux experience, this type of composition is similar to the Unix Philosophy of piping. That is, to work with small programs that do one thing well and use pipes to combine them to form larger functionality. As those familiar with Bash will know, the versatility and power of piping, using only basic Unix components, is impressive.</p>
<h3 id="information-hiding-using-composition"><a class="header" href="#information-hiding-using-composition">Information hiding using composition</a></h3>
<p><strong>We can also use composition for information hiding</strong>. For example, we could decide to only expose yellingACoolerName, hiding the functions it’s made of. Because we don’t use classes, modules provide our most important means of hiding information.</p>
<h2 id="what-is-currying"><a class="header" href="#what-is-currying">What is currying?</a></h2>
<p>Currying involves <strong>converting</strong> the function, <strong>combining</strong> multiple arguments into a series of functions that are executed one after another. In other word, process changes a function with multiple arguments into multiple functions that take a single argument and <strong>return the next function.</strong></p>
<p>Whenever we feed it an argument, we can write a function that returns another function that also accepts an argument and returns a function. <strong>This continues to happen until the final argument is passed</strong>. When that happens, the code block executes. This is called currying, and it’s very popular in functional languages like Haskell and F#. The following code snippet is a boilerplate example of currying:</p>
<pre><code class="language-ts">const decrypt = (m) =&gt; `{ &quot;userType&quot;: &quot;admin&quot;, &quot;message&quot;: &quot;${m}&quot; }`;
const userTypeLens = (fallback) =&gt; (userInfo) =&gt; userInfo.userType || fallback;
const auth = (type) =&gt; type === 'admin' ? ({ allow: true }) : ({ allow: false }); //Line 3
const userTypeLensDefaultNone = userTypeLens('none'); //Line 7
const compose = (...fns) =&gt; (...args) =&gt; {
    return fns.reduceRight((res, fn) =&gt; [fn.call(null, ...res)], args)[0];
};

//Remember to read from right to left or bottom to top
const authAnswer = compose(
    JSON.stringify,
    auth,
    userTypeLensDefaultNone,
    JSON.parse,
    decrypt,
);

console.log(authAnswer('a message'));
</code></pre>
<p>Line 3: Here, we retrieve a field from the incoming argument, userInfo, and return a fallback if the field is missing. Lenses in functional programming are used to retrieve or change data in a data structure. They make it easy to modify a single value within immutable, complicated structures. Real lenses such as “monocle-ts” are more complicated than this example.</p>
<p>Line 7: We fill in our fallback value, which is the string none.</p>
<p><code>Note:</code>
Closely linked to <strong>currying is the partial application</strong>, which feeds a functioning part of the arguments it needs at a given time and calls the function with the remaining arguments later. Python has a function called partial that can help us accomplish the same result.</p>
<h4 id="why-is-currying-useful"><a class="header" href="#why-is-currying-useful">Why is currying useful?</a></h4>
<p>Currying allows us to <strong>add configurations or dependencies to a function</strong> at one point and call it at a later time. We ensure that our function has everything it needs to run correctly. It merely has to wait for the final input data for execution. Furthermore, currying can make our code easier to understand when dealing with functions that take many arguments. There’s another reason for currying in the composition context. In our example above, each function we use inside the authAnswer requires one argument. Conveniently, all our functions return one value, namely a string, boolean, or an object, making them easy to compose.</p>
<h2 id="combining-currying-and-composition"><a class="header" href="#combining-currying-and-composition">Combining Currying and Composition</a></h2>
<p>Learn how to use currying and composition together for functions that take multiple arguments.</p>
<h3 id="function-with-one-parameter-value"><a class="header" href="#function-with-one-parameter-value">Function with one parameter value</a></h3>
<p>Composing is easy when we have a scenario like this:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Function ONE accepts a parameter of type A and returns a value of type B.</li>
<li><input disabled="" type="checkbox" checked=""/>
Function TWO accepts a parameter of type B and returns a value of type C.</li>
<li><input disabled="" type="checkbox" checked=""/>
Function THREE accepts a parameter of type C and returns a value of type D.</li>
</ul>
<p>Note: In a Haskell or F# type of notation, the signatures of the functions above will be as follows:</p>
<pre><code class="language-md">ONE :: A -&gt; B
TWO :: B -&gt; C
THREE :: C -&gt; D
COMBINED :: A -&gt; D
</code></pre>
<h3 id="function-with-multiple-parameter-values"><a class="header" href="#function-with-multiple-parameter-values">Function with multiple parameter values</a></h3>
<p><code>Example of currying:</code></p>
<pre><code class="language-ts">const TWO = (first) =&gt; (second) =&gt; {
    if(first &amp;&amp; second) {
        return 'ok';
    }
    throw Error('Did not receive two params!');
}
const twoWhichWeWillPassToThree = TWO('first argument already given');
console.log(twoWhichWeWillPassToThree('giving second argument'));
</code></pre>
<p>Rewriting the above, we have:</p>
<pre><code class="language-md">ONE :: A -&gt; C
TWO :: B -&gt; C -&gt; D
THREE :: D -&gt; E
COMBINED :: A -&gt; E
</code></pre>
<p>This can’t be combined, so we give function TWO a value B, which returns a new function for us to use: <code>FUNCTION_RETURNED_BY_TWO :: C -&gt; D</code>.</p>
<p>This fits perfectly. Currying can be a huge help when composing functions with input and output values that are mismatched. We give what we can, and the rest will be filled in later. Consequently, a function’s final argument is often the data we’re operating on, while earlier arguments consist of things like configuration and dependencies. This is because we’ll usually already know what those configurations or dependencies will be. However, we only know what the data looks like when we receive it.</p>
<p><img src="fp/../assets/images/curried_functions.png" alt="Curried Functions" /></p>
<p>Note: Though they occasionally get in the way, types are generally very useful when composing functions. If a function expects type A and we instead feed it a function that returns A, it will complain. Meanwhile, JavaScript accepts everything we throw at it and crashes at runtime. In our example(fp-ex15.ts), try using <code>userTypeLens</code> (line 3) instead of the partially applied variant <code>userTypeLensDefaultNone</code> (line 7). JavaScript now returns <code>{ allow: false }</code>, despite receiving an admin.</p>
<h2 id="problems-with-currying-and-composition"><a class="header" href="#problems-with-currying-and-composition">Problems with Currying and Composition</a></h2>
<h3 id="asynchronous-actions"><a class="header" href="#asynchronous-actions">Asynchronous actions</a></h3>
<p>Now, we know how to compose functions to create our software. We also know how currying can help with functions that don’t naturally fit together because they have the wrong types or number of parameters. However, we’ll still have some issues with TypeScript and JavaScript. The most important issue might be that a lot happens asynchronously. Take a look at the following code snippet:</p>
<pre><code class="language-ts">const compose = (...fns) =&gt; (...args) =&gt; {
    return fns.reduceRight((res, fn) =&gt; [fn.call(null, ...res)], args)[0];
};
const givesAPromise = (num) =&gt; Promise.resolve(num);
const doubleIt = (num) =&gt; num * 2;
const doubled = compose(doubleIt, givesAPromise);
console.log(doubled(2)); // Output NaN 
</code></pre>
<p>How do we fix it? If we want to write pure JavaScript, we could use then(), which is provided by Promise, to retrieve a result to work with. This is certainly not a bad idea. However, we might run into some limits and, more generally, our entire program will have to use Promises everywhere.</p>
<h2 id="what-are-monads"><a class="header" href="#what-are-monads">What are monads?</a></h2>
<p>How can we avoid exceptions? How will we handle error cases without them? If Promises aren’t ideal for asynchronous behavior, what should we use instead? Enter the dreaded monads!
In several functional languages, putting the <code>value inside the monad is called return</code>. But, because return is a keyword in JavaScript, we’ll find various other words for it, like <code>of</code>.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Monads can be compared to a container.</li>
<li><input disabled="" type="checkbox" checked=""/>
The various constructors for monads in fp-ts are called lifting functions.</li>
</ul>
<h2 id="functors"><a class="header" href="#functors">Functors</a></h2>
<p>We have a value inside a container. What does that get us? Well, monads have several functions that influence or change that value. For example, the monad function map takes a function that might be applied to the value inside the container. Why do we say “might”? (Please attention to line 4 of follow example)</p>
<p><code>Note:</code>
Technically, <strong>monads only define bind, chain, or flatmap methods</strong>, <em>but not a map</em>, which is part of the definition of a Functor. However, monads are functors, so our current explanation is good enough.</p>
<p><img src="fp/../assets/images/functor.png" alt="Functor" /></p>
<h3 id="option-monad"><a class="header" href="#option-monad">Option monad</a></h3>
<p>An example might make things easier to understand. Let’s take a look at the Option monad from fp-ts.</p>
<h4 id="the-map-function"><a class="header" href="#the-map-function">The map function</a></h4>
<p><code>Line 4:</code> We can also tell Option that we don’t currently have any values to give to it (hence the name Option). It can have a value, <strong>but it might not</strong>. So, we tell it that we have nothing by passing none, a constant representing an empty Optional.</p>
<p><code>Line 5:</code> Now, we call map and pass it the function we defined in line 2 as a first argument. The second argument is the value we created in line 3.</p>
<p><code>Line 7:</code> Here, we log the value contained inside the monad. Because it’s wrapped inside our container, we need a helper to get it out. The getOrElse function retrieves the value or uses the function we pass in as the first argument as a fallback if the Option turns out to be empty. If empty, our fallback returns the string with no value present. Here, the result will be A VALUE. The function passed to map in line 5 converts the original value passed in line 3 to uppercase.</p>
<pre><code class="language-ts">import {getOrElse, map, none, some} from &quot;fp-ts/lib/Option&quot;;
const upperCaseIt = (value: string) =&gt; value.toUpperCase();
const optionWithAString = some('a value');
const optionEmpty = none;
const upperCased = map(upperCaseIt)(optionWithAString); //Line 5
const upperCasedEmpty = map(upperCaseIt)(optionEmpty);
console.log(getOrElse(() =&gt; 'no value present')(upperCased)); //Line 7
console.log(getOrElse(() =&gt; 'no value present')(upperCasedEmpty));
</code></pre>
<p><strong>Option gives us a way out. It offers us the ability to apply functions to values without worrying about how null will make it crash</strong>. If the value is missing, null or undefined, for example, our code will sit there, do nothing, and give back the same none value.</p>
<h4 id="the-chain-function"><a class="header" href="#the-chain-function">The chain function</a></h4>
<p>The chain function can <strong>combine and flatten monads</strong> in fp-ts.</p>
<pre><code class="language-ts">import {chain, getOrElse, none, some} from &quot;fp-ts/lib/Option&quot;;
const upperCaseSam = (name) =&gt; name === 'Sam' ? some(name.toUpperCase()) : none;
const optionWithNameSam = some('Sam');
const optionWithNameSmith = some('Smith');
const upperCasedName = chain(upperCaseSam)(optionWithNameSam);
const noneUpperCasedName = chain(upperCaseSam)(optionWithNameSmith);
console.log(getOrElse(() =&gt; 'no value present')(upperCasedName));
console.log(getOrElse(() =&gt; 'no value present')(noneUpperCasedName));
</code></pre>
<p><code>Line 5:</code> We apply the function defined at line 2 to the Option defined on line 3. Line 6: We apply the function defined at line 2 to the Option defined on line 4.</p>
<p><code>Line 8:</code> This prints no value present to the console. This is the default value. Therefore, our Option will be none. We had a container with the value Sam, and we applied a function to that inner value that returned another container with SAM inside it, defined as Option&lt;Option<string>&gt;. At least, this is what we would’ve gotten if we used map. 
Instead, we used chain, which <strong>flattened out the containers after receiving the results of the function. So, Option&lt;Option<string>&gt; became Option<string>.</strong></p>
<p><code>Note:</code>
Why is <strong>flattening</strong> so useful? </p>
<p>While monads offer a lot of useful behavior, nesting offers no additional advantages. It just produces more repetitive code because we’d have to unwrap the value multiple times. So, it’s best <strong>to get rid of the additional wrappings.</strong></p>
<p>That leaves us with an outer Option that contains an empty none Option. Consequently, our chain decides that this result, once flattened, is equal to none. The empty Option infects all of the outer ones. It signifies a missing value, no matter how many times we wrap it with Option.</p>
<h3 id="advantages-of-monads"><a class="header" href="#advantages-of-monads">Advantages of Monads</a></h3>
<h4 id="combining-effects-and-purity"><a class="header" href="#combining-effects-and-purity">Combining effects and purity</a></h4>
<p>Monads exist to handle effects. As discussed earlier, functional programming likes purity. However, <strong>effects such as writing to a database or calling some API ruin this purity.</strong> <em>This is because the call might work one moment and fail the next, making our results unpredictable.</em> <strong>This is where monads are helpful. Because they act as containers</strong>, they can store effective behavior. For example, we have monads just for storing effects, typically called IO monads.</p>
<p>Furthermore, with map, we can create functions that further transform the value saved in our container. Here comes the important thing, at least from a functional programming perspective. That is, the IO monad doesn’t create an effect until it’s called. This means that everything is pure until we call the program containing the IO monad(s). With this, effects and purity are combined.</p>
<blockquote>
<p><em>monads make our type system more powerful because they offer more information about what a function is doing.</em>
<em>In short, more behavior is made explicit, and this information helps create better and safer programs.</em></p>
</blockquote>
<p>Monads help us be more explicit about what a function will do and return. For example:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
If a function has an effect, it’s wrapped in an IO monad.</li>
<li><input disabled="" type="checkbox" checked=""/>
If a function is async, it’s wrapped in an Async or Task monad (both these names and others are used).</li>
<li><input disabled="" type="checkbox" checked=""/>
If the function has a failure path, an Either monad will be used.</li>
<li><input disabled="" type="checkbox" checked=""/>
If some value might not exist inside the function, Option monad will be used.</li>
<li><input disabled="" type="checkbox" checked=""/>
If a function does two or more of the things mentioned above, we’ll use monad transformers.</li>
</ul>
<p><code>Note:</code>
Monad transformers are basically monads stacked on top of each other, combining all the useful qualities of the underlying elements.</p>
<p><code>Note:</code>
For the following, remember that monads are functors and get their map from Functor. If you’re unfamiliar with functors, just replace “functor” with “monad” in the explanation.</p>
<p><strong>The newtype-ts library</strong> is a helper library for fp-ts that <strong>offers a NonZeroInteger type</strong> that gives non-zero values. This is also akin to design by contract, a prominent part of the Eiffel programming language. An interface in this language is described as a contract, which the interface must obey. This includes preconditions, postconditions, side effects, and other factors.</p>
<h4 id="better-composition"><a class="header" href="#better-composition">Better composition</a></h4>
<p><strong>Monads also help with composition</strong>. Because every <strong>monad has map and chain functions, we can use them to transform values in a flow or pipeline</strong> similar to the one we saw earlier with our compose helper. This is also possible with Promises and the then() function. However, with monads, everything will compose better. Plus, we can use different types of monads together to create more powerful functionality. In addition, the difference between chain and map makes what’s happening underneath more explicit. If we see a chain for the asynchronous task, another asynchronous process occurs in the function that we passed in.</p>
<h2 id="either"><a class="header" href="#either">Either</a></h2>
<p>Either (alternatively called <strong>Result in</strong>, for example, F#) <strong>is a monad</strong> we often use as an alternative <strong>for exception handling</strong>. It contains either (hence the name) a left or a right value. No further processing occurs if the value is left and you call map or chain. Similar to Option’s none, it just sits there and does nothing. The difference is that we can still retrieve the value originally entered there. This is why we often use Either for error handling. If something goes wrong, stop processing by placing a value (preferably an error message) on the left. <strong>If everything is fine, use right to do things with the value we have</strong>.</p>
<p>Each function is short and simple. The first function simply checks if the fields are present. If they are, we pass back the event wrapped in an Either (right because everything is OK). If not, we place an appropriate <strong>error message in left</strong>. The other two functions have other parameters, but similar checks. We could extract some common behavior, but that doesn’t seem worthwhile yet.</p>
<p>Our application will have to use all these checks. We have several options to combine them. The first is perhaps the most simple. Apply one check and then use chain to apply the others one by one.</p>
<h3 id="when-to-use-either"><a class="header" href="#when-to-use-either">When to use Either</a></h3>
<p>We already mentioned why we should use validation. Now, let’s see when we should use Either. Either has the advantage of being a bit simpler, so <strong>if we only have to do a few validations</strong>, it might work equally well. 
<em>Suppose we have a check that takes a bit of calculating, say, a synchronous password verification. ​​If we can reject invalid requests</em> <strong>before</strong> <em>we have to run this expensive verification</em>, we can save time and money. 
This would not be the case with Validation.</p>
<p>Another reason to use Either, which seems to be a lot less common, is <strong>when we have a few exclusive failure modes</strong> <em>that take widely different paths</em>. 
<em>For example,</em> <strong>our success path returns a 2xx, but our failure paths are a 3xx, a 4xx, or 5xx (i.e., redirects, bad requests, and server errors).</strong></p>
<p><code>Remember:</code> Either doesn’t have to be used exclusively as an alternative for exception handling.</p>
<h5 id="either-vs-validation"><a class="header" href="#either-vs-validation">Either vs. Validation</a></h5>
<p>Suppose we receive data from a frontend where a user has just filled in their information. A situation where the user fixes their errors one at a time instead of just getting back a list of all problems might not be ideal. This might lead to user frustration and additional calls to our backend because the data is resubmitted multiple times. This is why Validation can be a useful alternative to Either.</p>
<p><img src="fp/../assets/images/either.png" alt="Either" /></p>
<p>To demonstrate its potential, we’ll rewrite our three checks… The first thing we’ll need is a semigroup for an array of strings. We’ll pass it to the getValidation helper from Either.</p>
<pre><code class="language-ts">//helper function
import * as E from 'fp-ts/lib/Either';
import {getSemigroup} from 'fp-ts/lib/NonEmptyArray'

const applicativeValidation = E.getValidation(getSemigroup&lt;string&gt;());
</code></pre>
<p>A semigroup is a way of combining two values of the same type. The function is called concat. The product of two numbers, for example, is a semigroup where concat is the multiple of the two number values. The sum of two numbers is also a semigroup where the numbers are combined by addition.</p>
<pre><code class="language-ts">// Validation functions
import {NonEmptyArray} from 'fp-ts/lib/NonEmptyArray'; // additional import

type Validation = (e: UserRegistrationDto) 
    =&gt; E.Either&lt;NonEmptyArray&lt;string&gt;, UserRegistrationDto&gt;; 

const fieldsNotEmptyV: Validation = (e) =&gt; {
    return e.firstName &amp;&amp; e.lastName &amp;&amp; e.age &amp;&amp; e.sex &amp;&amp; e.country ?
        E.right(e) : E.left(['Not all required fields were filled in.']);
}; 

const validateAgeV: Validation = (e) =&gt; {
    return e.age &gt;= 18 &amp;&amp; e.age &lt; 150 ?
        E.right(e) : E.left([`Received an invalid age of ${e.age}`]);
}; 

const validateGenderV: Validation = (e) =&gt; {
    return e.sex === 'M' || e.sex === 'F' || e.sex === 'X' ?
        E.right(e) : E.left([`Received an invalid sex ${e.sex}`]);
}; 
</code></pre>
<p>Regards to above, </p>
<ul>
<li>Lines 3-4: Create a type to save some repetitive work.</li>
<li>Lines 6-19: These functions are similar to those we previously wrote, except we wrap our left in an array. Instead of rewriting our code, we could have created a helper that wraps the string in an array. To do that, Either offers mapLeft, which only transforms left values. We added a V suffix to our function names for clarity.</li>
</ul>
<p>The pipe is very similar to our earlier one as well.</p>
<pre><code class="language-ts">import {pipe} from &quot;fp-ts/lib/pipeable&quot;;
import {sequenceT} from &quot;fp-ts/lib/Apply&quot;; 

const result = pipe(
    exampleEvent,
    e =&gt; sequenceT(applicativeValidation)(
        fieldsNotEmptyV(e),
        validateAgeV(e),
        validateGenderV(e),
    ), 
    E.map(([first]) =&gt; first), 
);
console.log(result)
</code></pre>
<p><code>Note:</code> In the functional world, traverse and sequence handle lists (by which we mean anything iterable, so not limited to a List type) of elements. <strong>The sequence function can be used to “swap” the list and monad.</strong> For example, we can go from a list of optionals to an optional list (but only if none of the optionals contain empty values). The traverse function is similar but applies a function to each element in the list.</p>
<h2 id="what-is-lifting"><a class="header" href="#what-is-lifting">What is lifting?</a></h2>
<p>According to Bartosz Milewski’s lectures on category theory, lifting actually comes from the representation of the relation between a Functor and an ordinary mapping of functions, as follows:</p>
<p>Fa -&gt;  Fb   (3)</p>
<p>^       ^
|       |   (2)</p>
<p>a  -&gt;   b   (1)</p>
<p>The transformation of a value we call a into a different value b is represented by an arrow from left to right, shown by (1).
The up arrows shown by (2) signify a value transformation into a Functor, explaining the F that appears just before the character. We saw earlier that monads in many languages have a function to put a value inside a monad. So, the up arrow would be something like Option.of(a) in practice.
With the horizontal arrow, shown by (3), we’re dealing with transformations between Functors. A Functor with value a is changed into a Functor containing a value b.</p>
<p><code>Relation between a Functor and an ordinary mapping of functions:</code></p>
<p><img src="fp/../assets/images/relation_functor_mapping.png" alt="Relation between a Functor and an ordinary mapping of functions" /></p>
<p>All of this comes from category theory, where we deal with Objects and Morphisms. The former are the letters, the latter are the arrows between them. So, with a -&gt; b, the arrow is a morphism from object a to b. Once applied to functional programming, the objects are types, and the arrows are functions. The horizontal arrows show functions transforming one value into another, and below are just ordinary values. At the same time, we see Functors wrapping those same values above. Now, lifting is simply moving from function (1) to function (3) and is called lifting because of the convention that requires us to write the version with the Functors above the normal one! We move up into the realm of Functors. Functional programming languages provide specific functions for this action. In PureScript, these are called lift with a suffix indicating the number of arguments the lifted function takes. For example, lift2 lifts a function of two arguments.</p>
<p>We can use this because we currently have a function that works with values, not Functors or monads, that is., createUser. The functions that create the parameters we need produce monads, though. So, we lift our createUser function, and if functions that generate parameters don’t return a monad, we wrap them in one.</p>
<p>A simple example in PureScript would look like this:</p>
<pre><code class="language-ts">firstValue :: Maybe String
firstValue = Just &quot;a&quot; 

secondValue :: Maybe String
secondValue = Just &quot;b&quot; 

needsLifting :: String -&gt; String -&gt; String
needsLifting a b = a &lt;&gt; b 

doesNotWork = needsLifting firstValue secondValue 

getLiftResult = lift2 needsLifting firstValue secondValue 
</code></pre>
<p>Let’s look at the explanation of the above code:</p>
<p>Lines 2 and 5: Let’s suppose these are the results from some other functions, and they return Maybe values (which is the name for an Option in PureScript).
Line 8: This function works with normal values, taking Strings as input and producing the concatenated version.
Line 10: When we do this, our compiler complains that it expects a String and gets a Maybe string, which isn’t the same. If we were to wrap it in one, the compiler would start complaining about the second parameter.
Line 12: Here, we start with lift2 and give it a function to lift and the required number of parameters (two) wrapped in a functor, and everything compiles. The function returns the result, wrapped in another Maybe, because the function has been lifted into the world of functors.</p>
<h2 id="taskeither-vs-task"><a class="header" href="#taskeither-vs-task">TaskEither vs. Task</a></h2>
<p>TaskEither is a monad transformer provided by fp-ts. It’s actually a monad Transformer. We already mentioned how we can stack monads on top of each other to combine their effects. That helps us understand why Either reference is there. What about Task? We haven’t seen that one before!</p>
<p>Task is a monad for asynchronous non-failing calls. A Promise is easily converted into a Task. Simply create a function that returns a Promise. That’s it!</p>
<pre><code class="language-ts">const thisIsATask: T.Task&lt;number&gt; = () =&gt; Promise.resolve(42);
</code></pre>
<p>This monad is useful because it’s a monad. We can perform all kinds of transformations, like with any other monad:</p>
<pre><code class="language-ts">// result is still T.Task&lt;number&gt;
const result = pipe(
    thisIsATask,
    T.map(n =&gt; n + 1) // after getting back the result, we increase it by 1
);
</code></pre>
<p>Similarly, we can use chain to combine multiple Tasks. That means we now have the power of monads along with their composability and ease of use for the common asynchronous Node functionality. Eventually, when we actually need the results, we call the Task as a function and it returns the Promise it contains.
We’re now creating a Task and telling our code to perform a map on it when it’s run. It doesn’t start running, though. We can test this by adding a console.log statement. Nothing prints.</p>
<pre><code class="language-ts">// now result is Promise&lt;number&gt;
const asTask: T.Task&lt;number&gt; = () =&gt; {
    return new Promise((resolve) =&gt; {
        console.log('Doing stuff')
        return resolve(42);
    });
};

const result = pipe(
    thisIsATask,
    T.map(n =&gt; n + 1)
);
</code></pre>
<p>Before we continue, let’s take a small detour. As we mentioned several times before, functional programming tries to keep everything pure and thus easy to reason with. Side effects and I/O ruin this condition because they add impurity to our program. If our function uses I/O, it gives different results, despite having the same input. For instance, if we call the Lambda we’re monitoring more frequently, we get back a different sum. This is why FP does the best it can and moves all this content to the edge. So, despite what we might be expecting, this is pure because nothing is actually happening. There’s no asynchronous behavior (that is, a Promise) being run.</p>
<p>At some point, we’ll actually have to run the Task. Otherwise, why did we create it? That said, FP leaves this responsibility to the application’s user. Do we actually want to get things done? In that case, simply invoke the function and we’ll be responsible for the result!</p>
<p><code>Notice</code> that the logging appears. As a result, the program we’re writing will be pure and free of side effects. That is, it will be pure until, at the final step, we invoke the function to get back a Promise that contains the results we desperately desire. On a high level, we’re describing what we want the code to do. When it’s run, an interpreter decides what must actually happen. It decides whether it needs side effects. If the interpreter is a mock one, it might not need any side effects! Real interpreters probably will, though.</p>
<h3 id="combining-task-and-either"><a class="header" href="#combining-task-and-either">Combining Task and Either</a></h3>
<p>Let’s return to the subject at hand. We know what a Task is and we already knew Either. What’s their combined power? That answer is simple.That is, handling asynchronous tasks that might fail. Instead of writing a try or catch, we use the TaskEither monad and it either returns an error when the catch is triggered, or gives back our result. Our call to AWS can definitely fail, for example, if we made a mistake in the function’s name.</p>
<p>Here’s the first function from our file again:</p>
<pre><code class="language-ts">const getMetricInfo = (between: Between, fun: string) =&gt; 
    (metric: Metric): TE.TaskEither&lt;string, StatsResult&gt; =&gt; {

    const paramsForCW = generateCWMetricStatisticsParams(metric, between);
    const metricToStatsResult = metricsToStatsResult(fun, metric); //return -&gt; next code block
</code></pre>
<h3 id="taskeithers-map"><a class="header" href="#taskeithers-map">TaskEither’s map</a></h3>
<p>Next, we use TaskEither’s map to transform the output StatsResult type we defined earlier. Finally, but importantly, we start the flow by feeding in the function name, fun. Without that function call, nothing would happen. We’d merely have a function waiting for an argument.</p>
<p>Because flow is simply a compose in a different order, we also know why we partially applied our functions earlier. That is, only one parameter is passed to the next function, but two of our functions required three parameters! We gave them the two we already had, knowing that the flow would deliver the third and final parameter.</p>
<p>Note that we originally wrote the flow above like this:</p>
<pre><code class="language-ts">    return flow(
        paramsForCW,
        p =&gt; TE.tryCatch(() =&gt; getCWMetrics(p), String),
        TE.map(metricToStatsResult)
    )(fun);
};
</code></pre>
<p>We can see that the call takes a Between, the function name, and a metric name. It returns a TaskEither, with the error as a string (the left) and the successful result as a StatsResult. What about paramsForCW and metricToStatsResult? Both are partially applied functions. The parameter generation function has received a metric name and between but is still missing a function name. The metricToStatsResult function has the function and metric names but is waiting for the output of the Cloudwatch call. So, both const values are functions waiting for just one more parameter. We’ve used this technique of partially applying before, in our introduction, when we were demonstrating composing.</p>
<p>Furthermore, flow is a helper from the fp-ts library for composing functions. It’s actually just compose, but applied from left to right. It starts generating parameters, passing those to our cloudwatch function, which is inside a TaskEither constructor (lifting function) tryCatch. The latter eventually runs what we pass in (that is, our Promise-generating cloudwatch function) and in the case of failure, it uses the constructor we gave as a second argument to build an error. Here we pass the String constructor to get the error as a string. Note that tryCatch actually requires a Lazy<Promise> as the first parameter. In practice, this simply means that we pass in a function that returns a Promise. This is because that is effectively lazy, that is, not evaluated immediately.</p>
<h4 id="eager-or-lazy"><a class="header" href="#eager-or-lazy">Eager or Lazy</a></h4>
<p>Programming languages can be sorted by their type of evaluation, eager or lazy, with Haskell as one example of the latter. Essentially, in a lazy language, something is only evaluated when necessary. This might seem more complex, but it has its advantages. For one, there are potential performance gains because what isn’t needed is never evaluated (Java developers can compare this with Hibernate’s eager vs. lazy fetch modes). Another advantage is the ability to work with infinities, for example, taking the first five elements of an infinite list. Our program would never come to an end if we had to evaluate the entire list! A lazy language, on the other hand, just evaluates the first five elements, which is all it needs at that point, and returns those.</p>
<h3 id="continue-of-taskeithers-map"><a class="header" href="#continue-of-taskeithers-map">Continue of TaskEither’s map</a></h3>
<p>Though we like this version because we could further abstract away the tryCatch as a utility with a predetermined error constructor, this isn’t actually pure because a Promise is created as soon as our function is called. The previous code, on the other hand, was lazy. By postponing creation, it stayed pure.</p>
<p>Also, we may be wondering about the map with metricToStatsResult. Is this the right location for that transformation? Isn’t the goal of this module just to get information out of Cloudwatch? This is a valid point. On the other hand, in this way, AWS types remain an implementation detail, invisible to whoever uses the entrypoint functions. Although in that case, to be entirely consistent we should also remove Datapoints from the returned type. Removing Datapoints is a possible improvement.</p>
<p>On to the second entrypoint function.</p>
<pre><code class="language-ts">export const retrieveMetrics = (between: Between, metrics: readonly Metric[]) =&gt; 
    (fun: string): TE.TaskEither&lt;string, StatsResult[]&gt; =&gt; {
        return A.array.sequence(TE.taskEither)
            (metrics.map(getMetricInfo(between, fun)));
};
</code></pre>
<p>First, note the export. This function is exported and is the real entrypoint of our gateway module. Because the code is a bit dense, the body has been split into two lines. The signature should be obvious by this point. The parameters are similar to those we gave to the other function, except we’re now expecting an array of metrics instead of a single one. All metrics we desire can now be passed into this function. Similarly, the return has changed into an array of StatsResult. To get a slightly better result, we could’ve created a StatsResults (note the final s) as an alias for this array.</p>
<h3 id="the-arraysequence-function"><a class="header" href="#the-arraysequence-function">The array.sequence function</a></h3>
<p>What does A.array.sequence from the Array module do? The naming might be a giveaway. That is, it runs one or more functions of the type given as the first argument, in this case TaskEither in parallel. This is similar to running a Promise.all but as a monad, it’s even easier to use. We have abstracted away all the difficulties of parallelism.</p>
<p>The second argument is the array of TaskEithers. We want to run the function for retrieving metrics once for every metric (three times in total). To avoid some typing, we can use partial application and pass in getMetricInfo with two out of three arguments already provided. This means we can use point-free style without passing in the metric name explicitly inside the map. If we prefer to be explicit, though, we can replace that last line with metrics.map(m =&gt; getMetricInfo(between, fun)(m)).</p>
<p>That’s it. We’re all caught up and have finished creating our entrypoint for retrieving all relevant metric information from Cloudwatch. This is more of a real example than that of our previous chapter, but we’re still writing in the same style, using short, understandable functions that combine to form larger functionality. This time, though, we spread them out over more modules.</p>
<p>Moreover, we were able to keep much of our code pure despite the fact that the application’s core functionality involves retrieving information from external services, which is an impure process. Our new Task and TaskEither monads (Transformer) helped us control this potentially dangerous type of code.</p>
<h2 id="the-datapoints-interface"><a class="header" href="#the-datapoints-interface">The DataPoints interface</a></h2>
<p>If everything goes well, we now have a TaskEither returning a StatsResult array, with each element of the array containing information for a different type of metric (one will, for example, contain data for errors). We’re ignoring the error path for now. So, how do we transform our individual StatsResult elements to an output useful to us (a developer keeping an eye on their applications)? Simple: we’ll use small, composable, and pure functions. We already have a folder and file called transformers, so why not add it all in there?</p>
<p>First, we want the total sum of every individual metric. For clarity’s sake, we’ll dissect the AWS Datapoints type we’re currently returning within StatsResult:</p>
<p><code>Note:</code>
If a library has types that it wants to expose to its users, these are typically contained inside a file ending with d.ts. This provides the name of the Cloudwatch types, say cloudwatch.d.ts.</p>
<pre><code class="language-ts">export type Datapoints = Datapoint[];

export interface Datapoint {
    Timestamp?: Timestamp;
    Sum?: DatapointValue;
    Average?: DatapointValue;
    // other values
};

export type DatapointValue = number;
</code></pre>
<p>Our Datapoints value is an array of Datapoint. Each Datapoint contains the Sum information we want to extract, which is a DatapointValue, itself an alias for number. Note that because we set the Period parameter quite high early on, it’s possible that there’s only one number present within the array. This could help us avoid a lot of work. We can’t be sure of this, however, and assuming this status might create bugs if another user changes either the period or timeframe. We’re assuming it to be a few hours, but what if someone changes it to a few days? In that case, the probability of an array with multiple elements is very high. So, we’ll assume that there might be more than one Datapoint and thus more than one Sum.</p>
<p>Now that we know what our type looks like, we add a new type that we want to create out of our current ones:</p>
<pre><code class="language-ts">export type StatsSumResult = {
    readonly functionName: string,
    readonly metric: Metric,
    readonly sum: number,
}
</code></pre>
<p>As we can see, types.ts is the same as before, but now the sum is just one number. We should write a function that consolidates Sum elements into a single number.</p>
<pre><code class="language-ts">import {fold, monoidSum} from &quot;fp-ts/Monoid&quot;;

export const statsResultToStatsSumResult =
    (results: readonly StatsResult[]): StatsSumResult[] =&gt; {
        return results.map(b =&gt; ({
            functionName: b.functionName,
            metric: b.metric,
            sum: fold(monoidSum)(b.data.map(d =&gt; d.Sum)),
        }));
    };
</code></pre>
<p>This is a seemingly simple function, Because it mostly just maps our current array to a new one of type StatsSumResult. We might ask what a fold is, though. What is monoidSum? Is that similar to a monad?</p>
<p>Remember the semigroup from an earlier chapter? As a quick reminder, a semigroup provides a way of combining two values of the same type, resulting in a single value of that type. A product, which combines two numbers using multiplication, is an example. Monoids are semigroups with the addition of an empty value, a starting element. That starting value is neutral, which means that it doesn’t care what other value we combine it with. It will simply give back the other value as a result. The monoid for Product would have 1 as its empty value or starter (7 * 1 = 7), while Sum would have 0 (7 + 0 = 7). The monoidSum function is simply a utility function from fp-ts, providing a monoid sum out of the box.</p>
<blockquote>
<p><code>NOTE:</code> Monoid is not a synonym for Semigroup.
<code>NOTE:</code> What’s one thing monoids and monads have in common? They’re composable.</p>
</blockquote>
<p>The functional world likes monoids because they’re composable. If we create a monoid for combining strings and another for combining numbers, we can use them as components when we want to handle more complex structures that contain those primitives. No additional logic is required. We’ll see an example of this later. As an additional plus, operations on monoids can be made parallel with relative ease. Take sum as an example, with values between one and four. We can add those numbers in one go, or we could sum 1 + 2 (=3) and 3 + 4 (=7) in a first phase, adding the results of those calculations in a second phase, 3 + 7.</p>
<h3 id="whats-fold"><a class="header" href="#whats-fold">What’s fold?</a></h3>
<p>Fold is very similar to reduce, which you might know from JavaScript or other languages. It’s a function that takes a starting element and a function (so it’s another one of those higher-order functions) that knows how to combine the accumulated value with values from a list or array, which are fed in one by one. If we want to get the sum, this function would add the current element of the array to the accumulated value. Fold and reduce are very versatile. We can easily create functions like filter or map with reduce. Try it!</p>
<p><code>Note:</code> Fold and reduce are often used together with an array, which is why we give that as an example. We can also fold monoids and monads! Also, note that we’ll often encounter a fold left and a fold right, differing only in starting element (left side of the array, or the right) and direction.</p>
<p>Now we know what the above code does. It uses a fold to reduce the given array with monoidSum. This means that it will start with 0 and combine elements through addition.</p>
<p>Because we now have a type we can work with, let’s think about what we want to show our application users. We’d like to display the health of the Labda. As mentioned earlier, we’ll do this with a status, which can take three different values, namely OK, WARN, and ERR. This is good for a brief overview of the situation. For more details, we’ll also add a message that can contain further information.</p>
<pre><code class="language-ts">export type Status = 'OK' | 'WARN' | 'ERR';

export type ReducedStats = {
    readonly status: Status,
    readonly message: string,
}
</code></pre>
<p>As usual, we limit our status to the types we specified because that makes the field easier to work with. Messages aren’t as easy to limit in value, so we’ll let the message be a string.</p>
<h4 id="transforming-statssumresult-reducedstats"><a class="header" href="#transforming-statssumresult-reducedstats">Transforming StatsSumResult=&gt; ReducedStats</a></h4>
<p>The next big piece of the puzzle is a function to transform a single StatsSumResult into a ReducedStats.</p>
<pre><code class="language-ts">const statsSumToStatusAndMessage = (invokes: number) =&gt; (s: StatsSumResult) =&gt; {
    let status: Status = 'OK'; //2
    let message = ''; 

    switch (s.metric) {
        case 'Invocations': {
            status = invokes === 0 ? 'WARN' : 'OK'; //7
            message = invokes === 0 ? 'not invoked' : 'invokes ok'; 
        }
            break;
        case 'Errors': {
            const percentage = invokes !== 0 ? s.sum / invokes * 100 : 0; //12
            status = percentage &gt;= 5 ? 'ERR' : 'OK';
            message = percentage &gt;= 5 ? 'throwing errors' : 'no errors';
        }
            break;
        case 'Throttles': {
            const percentage = invokes !== 0 ? s.sum / invokes * 100 : 0; //18
            status = percentage &gt;= 1 ? 'WARN' : 'OK'; (4)
            message = percentage &gt;= 1 ? 'being throttled' : 'no throttles'; 
        }
            break;
        default:
            const _exhaustiveCheck: never = s.metric; //24
            return _exhaustiveCheck; 
    }

    return { //28
        status, message,
    } 
};
</code></pre>
<p>Lines 2–3: We start with an empty message and an OK status, which can be overwritten by the switch that follows. We have to tell TypeScript that status has the Status type, or it will assume that this is a string, which downstream code doesn’t accept. Ideally, the compiler would notice that only three possible values, matching those of our type, appear in this piece of code and would conclude that this is equivalent to Status. TypeScript isn’t there yet. Also, because Status doesn’t have an empty string value, we can’t initialize it as such. So, we start with the reasonable default of ‘OK’.
Lines 7–8: We’re using a switch to check each possible value for Metric, so (to recall from earlier in this chapter) we have three in total. This is the closest we can get to the power of pattern matching in other functional languages. Notice how, when we get an Invocations, we already have the answer ready. This is because we need the number of invocations in the Errors and Throttles cases as well, so we added it as the first parameter to this function.
Line 12: Here, we handle Error and report an error when they exceed five percent of the total invocations of the function. This is why we take the sum, divide by the invokes, multiply by 100, and check the percentage we get. If there are no invocations, there won’t be any errors, either. In that case, we return a 0. Note that the five percent threshold is a magic number and we might want to make this configurable. That’s quite easy to do through Lambda environment variables, which we’ll use later in this chapter for getting the function name. If we don’t think these values will change often, another approach could be to move the values to the constants file.
Lines 18–20: This is similar to the errors, except here we give back a warning when we have one percent (or more) throttles.We only give a warning here, though, not an error status. An occasional throttle is nothing unusual.
Lines 24–25: This is an exhaustiveness check, which we’ve already encountered once before. Say we had a fourth metric, called MagicInvocations, invocations of our Lambda that come out of nowhere. If MagicInvocations was a possible Metric type value, this default would try to assign it to _exhaustiveCheck, which has type never. We can’t assign something to never. So, this check throws a warning at compile time if we add a metric but forget to handle it. Do note that an IDE might not understand this and might advise us to remove or change this default case in a way that will stop it from working.
Lines 28–30: We passed through the switch, so status and message now have the correct values, which we can return.</p>
<p><code>Notice</code> that we’re mutating two variables within this function. Isn’t that a horrible mistake? While a different approach that doesn’t mutate variables might turn out cleaner, the important thing to note is that we’re only mutating local variables. This function creates and manipulates variables, which means that we won’t run into any issues with this mutability. If the golden rule is to avoid mutation, remember to limit the scope of any variable mutation you end up doing. Global variables, as we know, are bad. Unexposed mutation within a function is acceptable.</p>
<p>Now we can produce a bunch of messages and strings. We actually just want to output one status and one message. How do we combine them? Well, how about using fold and a monoid? How would we go about combining two statuses? Clearly, if B says that everything’s OK and B says that there’s a warning, we want there to be a warning! Similarly, we prefer an error to a warning. So, we get the following:</p>
<pre><code class="language-ts">import {fold, monoidSum} from &quot;fp-ts/Monoid&quot;;

const statusMonoid: Monoid&lt;Status&gt; = {
    concat: (x, y) =&gt;
        x === 'ERR' || y === 'ERR' ? 'ERR'
            : (x === 'WARN' || y === 'WARN' ? 'WARN' : 'OK'),
    empty: 'OK'
};
</code></pre>
<p>The monoid has a concat and an empty. Remember that the empty value is always overwritten by any other value. Here, the empty is OK because we always prefer a warning or an error to that value. The concat is written somewhat densely, but it shows what we just said, namely that error &gt; warning &gt; ok.</p>
<p>Now a monoid for the messages:</p>
<pre><code class="language-ts">const messageMonoid: Monoid&lt;string&gt; = {
    concat: (x, y) =&gt; (x + ' ' + y).trim(),
    empty: '',
};
</code></pre>
<p>It’s not perfect, but it’s good enough. The empty string will be overwritten by other values and we can combine two strings by appending. As we said earlier, monoids have a nice quality that they’re composable. We’ll use the fp-ts library to accomplish this.</p>
<pre><code class="language-ts">import { getStructMonoid } from 'fp-ts/lib/Monoid'

const ReducedStatsMonoid: Monoid&lt;ReducedStats&gt; = getStructMonoid({
    status: statusMonoid,
    message: messageMonoid
});
</code></pre>
<p>Using getStructMonoid, we say that the monoid for ReducedStats uses the two primitives above for its fields. The rest happens automatically. Now let’s bring everything together.</p>
<pre><code class="language-ts">export const statsReducer = (results: readonly StatsSumResult[]): ReducedStats =&gt; {
    const invocations = results
        .filter(m =&gt; m.metric === 'Invocations')
        .map(m =&gt; m.sum)
        .shift() || 0; //5
    
    const singleStatsSumMapper = statsSumToStatusAndMessage(invocations); 

    return fold(ReducedStatsMonoid)
        (results.map(singleStatsSumMapper)); //10
};
</code></pre>
<p>Lines 5–7: We saw earlier that our statsSumToStatusAndMessage needs the number of invocations, so we retrieve those. If the value isn’t present in our array, shift returns undefined and we return 0 instead. We could’ve also used the ?? operator from TypeScript, but in this case, both are equally valid.
Line 10: Next, we give the monoid we just wrote to fold and pass in all our StatsSumResult mapped to ReducedStats. The fold function reduces those to a single status and message. It’s another nice example of the way FP allows us to write code at a higher level of abstraction. We merely say that we want the ReducedStats to be reduced into a single value. How this is done is none of our concern.</p>
<p><code>Note:</code>
There are other equally valid ways to reduce the stats to a status plus message. Examples include forEach, map, and reduce. But this was a nice opportunity to show monoids in action.</p>
<h4 id="returning-results"><a class="header" href="#returning-results">Returning results</a></h4>
<p>The last thing we want to do in regards to transforming is to give results back to the outside world. So, just in case someone puts us behind an AWS API Gateway and uses REST calls, we’ll add a status code and related fields.</p>
<pre><code class="language-ts">type StatusCode = 200; 

export type HttpResult = {
    readonly statusCode: StatusCode,
    readonly body: string,
    readonly headers: Record&lt;string, string&gt;,
}; 
</code></pre>
<p>Line 1: For now, we’ll define only one relevant code for the case when everything goes well.
Lines 3–7: We’ll give back an http status code, the results in the body, and headers (which might be needed for protocols such as Cross-Origin Resource Sharing, or CORS).</p>
<p>To go from our reduced stats to httpResultFromStats requires only a little work.</p>
<pre><code class="language-ts">export const httpResultFromStats = (result: ReducedStats): HttpResult =&gt; ({
    statusCode: 200,
    body: JSON.stringify(result),
    headers: {
        'Access-Control-Allow-Origin': '*'
    }
});
</code></pre>
<p>Note that when we return this from a Lambda, AWS knows how to interpret these values. It sees statusCode as a http status code. Similarly, everything inside headers is added as headers to the response. In case we decide to talk with browsers, we’re allowing every origin to call us, which adds security. With that, we’ve come to the end of our happy flow. Apart from error handling, which turns out to be quite easy, a few pieces are still missing. Going way back to our Cloudwatch entrypoint, we see that we need a Between type and a function name. Where do those two come from?</p>
<h2 id="synchronous-behavior-and-io"><a class="header" href="#synchronous-behavior-and-io">Synchronous Behavior and IO</a></h2>
<p>We’ll ignore the function name for now and focus on how to create the Between. It should be clear that there are problems with purity when it comes to getting the start and end times because we want to show a certain range in regard to the current time. Consider the last three hours of metrics, for example. This means that the function for getting our Between returns different values depending on when it was invoked, which is impure behavior. How will we wrap it? In a Task? We could do that, but this is synchronous behavior, for which the IO monad is ideally suited. Similarly, IO is also what we normally use to wrap our logging, which is, after all, another synchronous side effect.</p>
<p>As noted, in a hybrid language like TypeScript (which allows other styles of programming besides FP),we can decide for ourselves which effects are important enough that we want to keep an eye on them. That decision comes down to whether the correct program behavior depends on the effect, in this case, logging. In most cases it won’t, but what if our console output is used by another program as input? In the latter case, our output is an essential part of our application and should be treated with the utmost care. So, if you like debugging with console statements and all that logging is temporary, go ahead and take advantage of the flexibility of JavaScript, which doesn’t force us to wrap logging in a monad. If we’re capturing some important logs but our application doesn’t depend on them, that seems acceptable as well. On the other hand, in some rare cases (like the first one we discussed), avoiding IO might prove to be a mistake.</p>
<h3 id="defining-constants"><a class="header" href="#defining-constants">Defining constants</a></h3>
<p>As with several other potentially configurable values, we’ll keep it simple and only check for the last three hours. We’ll add these values to our constants.</p>
<p>If we were to make a lot of these values (error percentage, function name, times) configurable, how would we go about passing them to so many functions? Won’t that become complicated? Part of the answer will be to gather them in a Config type, meaning that we only need to pass in one clearly defined value. If many functions need them, we’d use the Reader monad, which we’ll discuss later.</p>
<pre><code class="language-ts">const ONE_HOUR_EPOCH_MILLI = 60 * 60 * 1000;
export const THREE_HOURS_EPOCH_MILLI = 3 * ONE_HOUR_EPOCH_MILLI;
</code></pre>
<h3 id="creating-a-function-to-get-between"><a class="header" href="#creating-a-function-to-get-between">Creating a function to get Between</a></h3>
<p>Now, we create our function to get a Between wrapped in an IO. First, create a new file called time.ts in util (the same folder in which the constants are located).</p>
<pre><code class="language-ts">import {Between} from &quot;./types&quot;;
import {THREE_HOURS_EPOCH_MILLI} from &quot;./constants&quot;;

export const dateToBetween = (curr: Date): Between =&gt; ({
    startTime: new Date(Number(curr) - THREE_HOURS_EPOCH_MILLI),
    endTime: curr,
}); 
</code></pre>
<p>Lines 4–7: Creating a Between based on an incoming value is pure. Given a certain date (say, January 1, 2020), it returns the same Between every time! We extract pure from the impure and put the latter in a separate function.</p>
<p>We want to pass on both the function name and this between value. To do that, we add a type for configuration.</p>
<pre><code class="language-ts">export type Config = {
    between: Between,
    functionName: string,
};
</code></pre>
<p>To keep things simple, functionName is just a string. Now we’ll create a config.ts file, again in the util folder:</p>
<pre><code class="language-ts">import {io, IO, map} from &quot;fp-ts/IO&quot;;
import {Between, Config} from &quot;./types&quot;;
import {create} from &quot;fp-ts/Date&quot;;
import {dateToBetween} from &quot;./time&quot;;
import {pipe} from &quot;fp-ts/pipeable&quot;;
import {sequenceT} from &quot;fp-ts/Apply&quot;;

const addToConfig = (between: Between, functionName: string) =&gt; ({ //8
    between,
    functionName,
}); 

export const generateConfig = (): IO&lt;Config&gt; =&gt; {
    return pipe(
        sequenceT(io)(
            map(dateToBetween)(create), //16
            () =&gt; process.env.FUNCTION_NAME,
        ), 
        map(([a, b]) =&gt; addToConfig(a, b)), 
    );
};
</code></pre>
<p>Lines 8–11: A pure function for creating our config.
Line 16: A helper from the fp-ts library, create (according to GitHub sources) “Returns the current Date” wrapped in an IO monad.
Line 17: This means we have to lift it into the config. Similarly, we get the function name from our environment (more on that later), so we create an IO for that too. We could use IO.of() to do that, but because IO is simply a function returning a value, we do that instead.
Line 19: Next, we use map to retrieve the two values and pass them to our pure addToConfig.</p>
<p>To summarize, we used two small pure functions and some glue from fp-ts `to create our functionality.</p>
<h2 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to go from here</a></h2>
<p>If you’ve been skimming this course and it piqued your interest, you might consider going through it again in more detail. See if you understand everything and if you can write the code yourself. Note that fp-ts is still in active development, which might necessitate some changes (for example, StateReaderTaskEither’s evalState method has become deprecated). To learn more about the fundamentals of functional programming, you should probably look into some real FP languages like Haskell or Clojure. If you want to get into the action with TypeScript, try some of the things you learned here in a pet project. You might throw in some AWS services now that you know how to create them out of a simple YAML file. If everything goes well, you could use FP next time a greenfield project comes along at work.</p>
<p>Finally, if any of the other generic subjects briefly mentioned in this course (like DDD or TDD) weren’t familiar to you, go check them out! The great curse and blessing of IT is that there’s always more to discover about any topic. So, to quote Werner Vogels, now go explore!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h1>
<p>If you have a function that takes too many parameters, or parameters of the same type, then you might want to consider changing the function to take an object instead. </p>
<p>Consider the following function:</p>
<pre><code class="language-typescript">function foo(flagA: boolean, flagB: boolean) {
  // your awesome function body 
}
</code></pre>
<p>With such a function definition it’s quite easy to invoke it incorrectly e.g. <code>foo(flagB, flagA)</code> and you would get no help from the compiler. </p>
<p>Instead, convert the function to take an object: </p>
<pre><code class="language-typescript">function foo(config: {flagA: boolean, flagB: boolean}) {
  const {flagA, flagB} = config;
  // your awesome function body 
}
</code></pre>
<p>Now the function calls will look like <code>foo({flagA, flagB})</code> which makes it much easier to spot mistakes and code review.</p>
<blockquote>
<p>Note : If your function is simple enough, and you don’t expect much churn, then feel free to ignore this advice 🌹.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="arrow-functions.html#arrow-functions">Arrow Functions</a></li>
<li><a href="arrow-functions.html#tip-arrow-function-need">Tip: Arrow Function Need</a></li>
<li><a href="arrow-functions.html#tip-arrow-function-danger">Tip: Arrow Function Danger</a></li>
<li><a href="arrow-functions.html#tip-arrow-functions-with-libraries-that-use-this">Tip: Libraries that use <code>this</code></a></li>
<li><a href="arrow-functions.html#tip-arrow-functions-and-inheritance">Tip: Arrow Function inheritance</a></li>
<li><a href="arrow-functions.html#tip-quick-object-return">Tip: Quick object return</a></li>
</ul>
<h3 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h3>
<p>Lovingly called the <em>fat arrow</em> (because <code>-&gt;</code> is a thin arrow and <code>=&gt;</code> is a fat arrow) and also called a <em>lambda function</em> (because of other languages). Another commonly used feature is the fat arrow function <code>()=&gt;something</code>. The motivation for a <em>fat arrow</em> is:</p>
<ol>
<li>You don’t need to keep typing <code>function</code></li>
<li>It lexically captures the meaning of <code>this</code></li>
<li>It lexically captures the meaning of <code>arguments</code></li>
</ol>
<p>For a language that claims to be functional, in JavaScript you tend to be typing <code>function</code> quite a lot. The fat arrow makes it simple for you to create a function</p>
<pre><code class="language-typescript">var inc = (x)=&gt;x+1;
</code></pre>
<p><code>this</code> has traditionally been a pain point in JavaScript. As a wise man once said “I hate JavaScript as it tends to lose the meaning of <code>this</code> all too easily”. Fat arrows fix it by capturing the meaning of <code>this</code> from the surrounding context. Consider this pure JavaScript class:</p>
<pre><code class="language-typescript">function Person(age) {
    this.age = age;
    this.growOld = function() {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 1, should have been 2
</code></pre>
<p>If you run this code in the browser <code>this</code> within the function is going to point to <code>window</code> because <code>window</code> is going to be what executes the <code>growOld</code> function. Fix is to use an arrow function:</p>
<pre><code class="language-typescript">function Person(age) {
    this.age = age;
    this.growOld = () =&gt; {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
</code></pre>
<p>The reason why this works is the reference to <code>this</code> is captured by the arrow function from outside the function body. This is equivalent to the following JavaScript code (which is what you would write yourself if you didn’t have TypeScript):</p>
<pre><code class="language-typescript">function Person(age) {
    this.age = age;
    var _this = this;  // capture this
    this.growOld = function() {
        _this.age++;   // use the captured this
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
</code></pre>
<p>Note that since you are using TypeScript you can be even sweeter in syntax and combine arrows with classes:</p>
<pre><code class="language-typescript">class Person {
    constructor(public age:number) {}
    growOld = () =&gt; {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
</code></pre>
<blockquote>
<p><a href="https://egghead.io/lessons/typescript-make-usages-of-this-safe-in-class-methods">A sweet video about this pattern 🌹</a></p>
</blockquote>
<h4 id="tip-arrow-function-need"><a class="header" href="#tip-arrow-function-need">Tip: Arrow Function Need</a></h4>
<p>Beyond the terse syntax, you only <em>need</em> to use the fat arrow if you are going to give the function to someone else to call. Effectively:</p>
<pre><code class="language-typescript">var growOld = person.growOld;
// Then later someone else calls it:
growOld();
</code></pre>
<p>If you are going to call it yourself, i.e.</p>
<pre><code class="language-typescript">person.growOld();
</code></pre>
<p>then <code>this</code> is going to be the correct calling context (in this example <code>person</code>).</p>
<h4 id="tip-arrow-function-danger"><a class="header" href="#tip-arrow-function-danger">Tip: Arrow Function Danger</a></h4>
<p>In fact if you want <code>this</code> <em>to be the calling context</em> you should <em>not use the arrow function</em>. This is the case with callbacks used by libraries like jquery, underscore, mocha and others. If the documentation mentions functions on <code>this</code> then you should probably just use a <code>function</code> instead of a fat arrow. Similarly if you plan to use <code>arguments</code> don’t use an arrow function.</p>
<h4 id="tip-arrow-functions-with-libraries-that-use-this"><a class="header" href="#tip-arrow-functions-with-libraries-that-use-this">Tip: Arrow functions with libraries that use <code>this</code></a></h4>
<p>Many libraries do this e.g. <code>jQuery</code> iterables (one example https://api.jquery.com/jquery.each/) will use <code>this</code> to pass you the object that it is currently iterating over. In this case if you want to access the library passed <code>this</code> as well as the surrounding context just use a temp variable like <code>_self</code> like you would in the absence of arrow functions.</p>
<pre><code class="language-typescript">let _self = this;
something.each(function() {
    console.log(_self); // the lexically scoped value
    console.log(this); // the library passed value
});
</code></pre>
<h4 id="tip-arrow-functions-and-inheritance"><a class="header" href="#tip-arrow-functions-and-inheritance">Tip: Arrow functions and inheritance</a></h4>
<p>Arrow functions as properties on classes work fine with inheritance: </p>
<pre><code class="language-typescript">class Adder {
    constructor(public a: number) {}
    add = (b: number): number =&gt; {
        return this.a + b;
    }
}
class Child extends Adder {
    callAdd(b: number) {
        return this.add(b);
    }
}
// Demo to show it works
const child = new Child(123);
console.log(child.callAdd(123)); // 246
</code></pre>
<p>However, they do not work with the <code>super</code> keyword when you try to override the function in a child class. Properties go on <code>this</code>. Since there is only one <code>this</code> such functions cannot participate in a call to <code>super</code> (<code>super</code> only works on prototype members). You can easily get around it by creating a copy of the method before overriding it in the child.</p>
<pre><code class="language-typescript">class Adder {
    constructor(public a: number) {}
    // This function is now safe to pass around
    add = (b: number): number =&gt; {
        return this.a + b;
    }
}

class ExtendedAdder extends Adder {
    // Create a copy of parent before creating our own
    private superAdd = this.add;
    // Now create our override
    add = (b: number): number =&gt; {
        return this.superAdd(b);
    }
}
</code></pre>
<h3 id="tip-quick-object-return"><a class="header" href="#tip-quick-object-return">Tip: Quick object return</a></h3>
<p>Sometimes you need a function that just returns a simple object literal. However, something like</p>
<pre><code class="language-typescript">// WRONG WAY TO DO IT
var foo = () =&gt; {
    bar: 123
};
</code></pre>
<p>is parsed as a <em>block</em> containing a <em>JavaScript Label</em> by JavaScript runtimes (cause of the JavaScript specification).</p>
<blockquote>
<p>If that doesn’t make sense, don’t worry, as you get a nice compiler error from TypeScript saying “unused label” anyways. Labels are an old (and mostly unused) JavaScript feature that you can ignore as a modern GOTO (considered bad by experienced developers 🌹)</p>
</blockquote>
<p>You can fix it by surrounding the object literal with <code>()</code>:</p>
<pre><code class="language-typescript">// Correct 🌹
var foo = () =&gt; ({
    bar: 123
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="closure-1"><a class="header" href="#closure-1">Closure</a></h2>
<p>The best thing that JavaScript ever got was closures. A function in JavaScript has access to any variables defined in the outer scope. Closures are best explained with examples:</p>
<pre><code class="language-typescript">function outerFunction(arg:String) {
    var variableInOuterFunction = arg;

    function bar() {
        console.log(variableInOuterFunction); // Access a variable from the outer scope
    }

    // Call the local function to demonstrate that it has access to arg
    bar();
}

outerFunction(&quot;hello closure&quot;); // Result: hello closure
</code></pre>
<p>You can see that the inner function has access to a variable (variableInOuterFunction) from the outer scope. The variables in the outer function have been closed by (or bound in) the inner function. Hence the term <strong>closure</strong>. The concept in itself is simple enough and pretty intuitive.</p>
<p>Now the awesome part: The inner function can access the variables from the outer scope <em>even after the outer function has returned</em>. This is because the variables are still bound in the inner function and not dependent on the outer function. Again let’s look at an example:</p>
<pre><code class="language-typescript">function outerFunction(arg) {
    var variableInOuterFunction = arg;
    return function() {
        console.log(variableInOuterFunction);
    }
}

var innerFunction = outerFunction(&quot;hello closure!&quot;);

// Note the outerFunction has returned
innerFunction(); // logs hello closure!
</code></pre>
<h3 id="reason-why-its-awesome"><a class="header" href="#reason-why-its-awesome">Reason why it’s awesome</a></h3>
<p>It allows you to compose objects easily e.g. the revealing module pattern:</p>
<pre><code class="language-typescript">function createCounter() {
    let val = 0;
    return {
        increment() { val++ },
        getVal() { return val }
    }
}

let counter = createCounter();
counter.increment();
console.log(counter.getVal()); // 1
counter.increment();
console.log(counter.getVal()); // 2
</code></pre>
<p>At a high level it is also what makes something like Node.js possible.</p>
<pre><code class="language-typescript">// Pseudo code to explain the concept
server.on(function handler(req, res) {
    loadData(req.id).then(function(data) {
        // the `res` has been closed over and is available
        res.send(data);
    })
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stateful-functions"><a class="header" href="#stateful-functions">Stateful Functions</a></h2>
<p>A common feature in other programming languages is usage of the <code>static</code> keyword to increase the <em>lifetime</em> (not <em>scope</em>) of a function variable to live beyond function invocations. Here is a <code>C</code> sample that achieves this:</p>
<pre><code class="language-c">void called() {
    static count = 0;
    count++;
    printf(&quot;Called : %d&quot;, count);
}

int main () {
    called(); // Called : 1
    called(); // Called : 2
    return 0;
}
</code></pre>
<p>Since JavaScript (or TypeScript) doesn’t have function statics you can achieve the same thing using various abstractions that wrap over a local variable e.g. using a <code>class</code> :</p>
<pre><code class="language-typescript">const {called} = new class {
    count = 0;
    called = () =&gt; {
        this.count++;
        console.log(`Called : ${this.count}`);
    }
};

called(); // Called : 1
called(); // Called : 2
</code></pre>
<blockquote>
<p>C++ developers also try and achieve this using a pattern they call <code>functor</code> (a class that overrides the operator <code>()</code>).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="currying"><a class="header" href="#currying">Currying</a></h2>
<p>Just use a chain of fat arrow functions:</p>
<pre><code class="language-typescript">// A curried function
let add = (x: number) =&gt; (y: number) =&gt; x + y;

// Simple usage
add(123)(456);

// partially applied
let add123 = add(123);

// fully apply the function
add123(456);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-of-userresponse"><a class="header" href="#project-of-userresponse">Project of UserResponse</a></h1>
<p>We will have three file here. You only need to remove md describtions and then put it in three ts file.</p>
<h2 id="tsconfigjson"><a class="header" href="#tsconfigjson">tsconfig.json</a></h2>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;target&quot;: &quot;es6&quot;,
    &quot;outDir&quot;: &quot;build&quot;
  },
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ],
  &quot;include&quot;: [
    &quot;src/**/*&quot;
  ]
}
</code></pre>
<h2 id="domaints"><a class="header" href="#domaints">domain.ts</a></h2>
<pre><code class="language-ts">import {iso, Newtype} from &quot;newtype-ts&quot;;
import {PositiveInteger} from &quot;newtype-ts/lib/PositiveInteger&quot;;
import * as E from &quot;fp-ts/lib/Either&quot;;
import * as O from &quot;fp-ts/lib/Option&quot;;

</code></pre>
<p>Note: We often use the Event suffix for incoming data with the AWS Lambda computing platform because Lambdas are run in response to events. In that case, the above would be UserRegistrationEvent. 
DTO (Data Transfer Object) is another nice suffix, signifying that this is untrusted, outside information.
We’re still on the edge of our domain/application, and <strong>transformations must happen before this DTO becomes a trusted object within our domain.</strong></p>
<p>We create a User return BasicUser (the TypeScript compiler will already complain about its return) and make addStatus return the real user.
One annoying thing is that we added an optional field that might make using User more difficult. Another approach would be to change the existing type to something like BasicUser or UnvalidatedUser, subsequently reintroducing the User type, but this time with a required customer type as shown below:</p>
<pre><code class="language-ts">export type BasicUser = {
    firstName: FirstName,
    lastName: LastName,
    age: PositiveInteger,
    gender: Gender,
    region: Region,
};
export type UserRegistrationDto = {
    firstName: string,
    lastName: string,
    age: number,
    sex: string,
    country: string,
};
</code></pre>
<p>We should try to change the DTO properties into something more limited and, therefore, easier for the compiler to work with. This is common practice in Domain-Driven Design (DDD). 
We change information from the outside into something suitable for use within the domain. Similarly, anything returned to the outside world is again transformed to be useful to outside parties, in addition to ourselves. 
Let’s take a look at the following example. Although we need to add an extra bit of code, the types we created are powerful.</p>
<p>Before moving on, we should mention that <strong>both Gender and Region are called Sum types in functional programming.</strong> 
<strong>This is a kind of Algebraic Data Type (ADT).</strong> Sum types limit the type option to a list of exclusive choices. We can only pick one choice. We’re either children or adults, employed or unemployed. 
A boolean is an example of a sum type with two choices, true or false.</p>
<p><strong>Product types are another group of ADTs.</strong> Our incoming DTO is an example of a product type, where the possible choices are products of their properties. They’re useful and unavoidable.
The number of possible combinations of values explodes rapidly, though. Also, the more possible values, the less our compiler can help us.
For example, a Purchase that has been paid for (<strong>isPaid is set to true</strong>) will need shipping information. 
We have to make shipping information optional because it isn’t a required part of an unpaid Purchase.
A developer or business expert could now add a shipping address to an unpaid purchase by mistake.
In this instance, the compiler can no longer help us because a shipping address is perfectly acceptable for the Purchase type. This wouldn’t be the case if we use type alias. So, in most situations, <strong>Sum types are superior to (boolean) flags.</strong></p>
<pre><code class="language-ts">// user registration dto from before
// first attempt at modeling the user = identical to incoming event. the below is better. restricting to valid values
export type Gender = 'M' | 'F' | 'X';

export type Europe = {
    readonly _type: 'Europe',
    // optionally: still keep region here as string. not doing that
}
export type NorthAmerica = {
    readonly _type: 'NorthAmerica',
}
export type Other = {
    readonly _type: 'Other',
}
export type Region = Europe | NorthAmerica | Other;
</code></pre>
<p>Here, we pick names and tell the library that these will be newtypes for string.
According to the fp-ts newtype library, performance for its implementation is almost the same as primitive types. So, unless you have a very performance-sensitive application, you should be fine.</p>
<pre><code class="language-ts">export interface FirstName
    extends Newtype&lt;{ readonly FirstName: unique symbol }, string&gt; {}
export interface LastName
    extends Newtype&lt;{ readonly LastName: unique symbol }, string&gt; {}
</code></pre>
<p>These aren’t needed yet, but they’ll allow us to transform our newtypes into strings and vice versa.</p>
<pre><code class="language-ts">export const firstNameIso = iso&lt;FirstName&gt;();
export const lastNameIso = iso&lt;LastName&gt;();
</code></pre>
<p>Now, we start using both the two newtypes we defined and the built-in PositiveInteger. Now, if we try to pass an ordinary string to our User’s name fields, the compiler will reject them. Only newtypes are good enough for our fancy type!</p>
<pre><code class="language-ts">export type CustomerType = 'Normal' | 'VIP'; 
export type User = {
    firstName: FirstName,
    lastName: LastName,
    age: PositiveInteger,
    gender: Gender,
    region: Region,
    customerType?: CustomerType, 
};
</code></pre>
<pre><code class="language-ts">export type FieldsNotEmpty = (e: UserRegistrationDto)
    =&gt; E.Either&lt;string, UserRegistrationDto&gt;;
export type ValidateAge = FieldsNotEmpty;
export type ValidateGender = FieldsNotEmpty;
export type ValidateNotGerman = FieldsNotEmpty;
export type CreateUser = (f: FirstName,
                          l: LastName,
                          a: PositiveInteger,
                          g: Gender,
                          r: Region) =&gt; User;
export type FindRegion = (country: string) =&gt; O.Option&lt;Region&gt;;
export type FindGender = (sex: string) =&gt; O.Option&lt;Gender&gt;;

export type Response = {
    status: number,
    message: string,
};


</code></pre>
<h2 id="maints"><a class="header" href="#maints">main.ts</a></h2>
<p>We could’ve used a lens from monocle-ts to change the field. Lenses are pure getters and setters that make it easy to change or retrieve a property from a structure.</p>
<pre><code class="language-ts"> 
import {Lens} from 'monocle-ts'
import {prismPositiveInteger} from &quot;newtype-ts/lib/PositiveInteger&quot;;
import * as E from 'fp-ts/lib/Either';
import * as O from 'fp-ts/lib/Option';
import {pipe} from &quot;fp-ts/lib/pipeable&quot;;
import {sequenceT} from &quot;fp-ts/lib/Apply&quot;;
import {
    Region, Europe, NorthAmerica, Other, UserRegistrationDto, firstNameIso, lastNameIso,
    FieldsNotEmpty, ValidateAge, ValidateGender, CreateUser, FindRegion, FindGender, Response, ValidateNotGerman, User, CustomerType
} from &quot;./domain&quot;;

const america: NorthAmerica = {
    _type: 'NorthAmerica',
};
const europe: Europe = {
    _type: 'Europe'
};
const other: Other = {
    _type: 'Other'
};
const countryMappings: Record&lt;string, Region&gt; = {
    Belgium: europe,
    USA: america,
    Germany: europe,
    China: other,
};
const addStatus = (u: User): User =&gt; ({
    ...u,
    customerType: u.gender !== 'M' ? 'VIP' : 'Normal',
});
type AlternativeUser = {
    firstName: FirstName,
    lastName: LastName,
    gender: Gender,
    additionalInfo: {
        personalInfo: {
            age: PositiveInteger,
            region: Region,
        },
        otherInfo: {
            customerType?: CustomerType,
        }
    }
}; 
</code></pre>
<p>In our case, left (or error) is a string, so we need a semigroup that can combine two strings. There are multiple options, like creating a new string from the concatenation of the two input strings. That said, we’ll change the signature of our functions and start using a string array as our left, which is why we need a <strong>semigroup that can combine arrays</strong>. Luckily, there is a <strong>built-in method for that, which we just imported from the NonEmptyArray module</strong>. See below:</p>
<pre><code class="language-ts">const fieldsNotEmpty: FieldsNotEmpty = (e) =&gt; {
    return e.firstName &amp;&amp; e.lastName &amp;&amp; e.age &amp;&amp; e.sex &amp;&amp; e.country ?
        E.right(e) : E.left('Not all required fields were filled in.');
};
const validateAge: ValidateAge = (e) =&gt; {
    return e.age &gt;= 18 &amp;&amp; e.age &lt; 150 ?
        E.right(e) : E.left(`Received an invalid age of ${e.age}`);
};
const validateGender: ValidateGender = (e) =&gt; {
    return e.sex === 'M' || e.sex === 'F' || e.sex === 'X' ?
        E.right(e) : E.left(`Received an invalid sex ${e.sex}`);
};

const createUser: CreateUser = (firstName, lastName, age, gender, region) =&gt; ({
    firstName, lastName, age, gender, region
});
const findRegion: FindRegion = (country) =&gt; {
    return countryMappings[country] ? O.some(countryMappings[country]) : O.none;
};
const validateNotGerman: ValidateNotGerman = (e) =&gt; {
    return e.country !== 'Germany' ?
        E.right(e) : E.left(&quot;We don't like your kind around here&quot;);
};
const customerTypeLensAlt = Lens.fromPath&lt;AlternativeUser&gt;()(
    ['additionalInfo', 'otherInfo', 'customerType']); 

const addStatusAlt = (u: AlternativeUser) =&gt; {
    const modified = customerTypeLensAlt
        .modify(c =&gt; c ? c : u.gender !== 'M' ? 'VIP' : 'Normal');
    return modified(u);
};
console.log(addStatusAlt({gender: 'M', additionalInfo: { otherInfo: {} }} as AlternativeUser))
</code></pre>
<p>There are several ways of writing this piece of code. We do another validation that tells TypeScript that the string is indeed of type Gender. If the string doesn’t match one of the Gender values, we return none. Alternatively, we could’ve gone for type assertions (sex as Gender) because, at this point, we’re pretty sure we have the right kind of string.</p>
<pre><code class="language-ts">const findGender: FindGender = (sex) =&gt; {
    return sex === 'M' || sex === 'F' || sex === 'X' ? O.some(sex) : O.none;
};

// examples
const exampleEvent: UserRegistrationDto = {
    firstName: 'Test',
    lastName: 'McTestFace',
    sex: 'M',
    age: 18,
    country: 'Belgium',
}
</code></pre>
<p>Remember, we have to use chain because we’re getting back an Either. Without it, nothing would be flattened and we’d get Either&lt;string, Either<etc>&gt; monstrosities. Note that we’re using point-free style again by only passing in the names of the functions.</p>
<p>The downside of this approach is that we’re creating many variables that only get passed to the next chain. This requires additional typing. We can do a better job with pipe:</p>
<p>We don’t have to pass content into the chains explicitly, and we only need a variable for the result. The more maps and chains, the cleaner this solution becomes compared to the previous approach. Also, with piping, the amount of explicit typing we need is limited compared to other approaches. Note that the checks we defined can be used in many different scenarios and are combined quite elegantly by a pipe.</p>
<p><code>Note:</code> It can be useful to break the above pipe and see what kind of type errors (if any) it starts spewing. What happens if we make a chain return a string or a number? What happens if we return a right with a different kind of value inside?</p>
<pre><code class="language-ts">const result = pipe(
    fieldsNotEmpty(exampleEvent),
    E.chain(validateAge),
    E.chain(validateGender),
);
// console.log(result)

const first = fieldsNotEmpty(exampleEvent);
const second = E.chain(validateAge)(first)
const third = E.chain(validateGender)(second);
// console.log(third);

// note: still only gives back one error
const eitherSequence = sequenceT(E.either);
const res = pipe(
    eitherSequence(fieldsNotEmpty(exampleEvent), validateGender(exampleEvent), validateAge(exampleEvent)),
    E.map(([a, b, c]) =&gt; a)
)
console.log(res)
</code></pre>
<p>The sequenceT runs multiple functions. The T stands for tuple because that is how we are passing them in. Alternatively, we can use sequenceS, where the S stands for struct, that is, an object.
The recommended way of lifting in fp-ts is somewhat different from many other programming languages/frameworks. We’re advised to use the sequence, as we did for validation.</p>
<p>line of <code>e =&gt; sequenceForOption(...)</code> &amp; <code> O.map()</code>
In the case of success, each check returns a result (the UserRegistrationDto). So, if everything goes well, we’ll have the same success value five times! We use map to take only the first value of this array of identical DTOs, but picking the second or fifth elements would’ve worked equally well.
We’re again using a pipe to combine various actions. First, we pass in our example event, which is then passed to our sequenceForOption. In that sequence, we call several functions. The first and last names, on lines 9 and 10, must be transformed into the right newtypes because they don’t return an Option. Therefore, we wrap them in one. The following three functions all return Options, so no wrapping is needed. Finally, we use map to pass the results of these functions to createUser.</p>
<p>When we call this pipe with a valid UserRegistrationDto, we get back a user within an Option. If one or more of the functions failed (and returned none), we get back an empty Option. The overall result is nice because all our functions are kept short, clean, and understandable. We also understand the monad constructors (left, right, some, and many others) are called lifting functions because they lift the given value into the monad. Note that map helps us lift functions that deal with ordinary values into the monadic world as well.</p>
<pre><code class="language-ts">const sequenceForOption = sequenceT(O.option);

const user = pipe(
    exampleEvent,
    e =&gt; sequenceForOption(
        O.some(firstNameIso.wrap(e.firstName)),
        O.some(lastNameIso.wrap(e.lastName)),
        prismPositiveInteger.getOption(e.age),
        findGender(e.sex),
        findRegion(e.country),
    ),
    O.map(([f, l, a, g, c]) =&gt; createUser(f, l, a, g, c))
);
// console.log(user);
</code></pre>
<p>In the type below, the status will be a 2xx, 4xx, or 5xx number signifying success or failure (similar to HTTP response code), and a message will give additional information. Let’s look at them below. We’ll also add some pure helper functions to create responses.</p>
<pre><code class="language-ts">const internalServerError = (): Response =&gt; ({
    status: 500,
    message: 'failed to create',
});
const badRequest = (exception: string): Response =&gt; ({
    status: 400,
    message: exception,
});
const createdResponse = (message: string): Response =&gt; ({
    status: 201,
    message,
});
</code></pre>
<p>We could factor out some duplication here, but this example is good enough for now. Let’s review an example where we use these functions:</p>
<p>The userResponse function builds our user. It logs a message, which is a stand-in for a call to a database, and builds a response. The response is either a 201 in case of success or a 500 in case of a failure (we assume our validation will stop any errors caused by the user, so a 5xx seems appropriate). We use getOrElse for the latter, which we’ll call the internalServerError function if it’s passed a none. This function either assembles a user and logs, or it becomes empty at some point and goes to the fallback function.</p>
<pre><code class="language-ts">function userResponse(u: UserRegistrationDto) {
    // almost everything is the same as before
    return pipe(
        u,
        e =&gt; sequenceForOption(
            O.some(firstNameIso.wrap(e.firstName)),
            O.some(lastNameIso.wrap(e.lastName)),
            prismPositiveInteger.getOption(e.age),
            findGender(e.sex),
            findRegion(e.country),
        ),
        O.map(([f, l, a, g, c]) =&gt; createUser(f, l, a, g, c)),
        O.map(addStatus), 
        O.map(u =&gt; {
            console.log(`Created ${JSON.stringify(u)}. Could now save in db`);
            return createdResponse(`Created ${JSON.stringify(u)}`);
        }),
        O.getOrElse(internalServerError),
    );
}
</code></pre>
<p>This is our entire workflow brought together. First, we conduct our three checks, fieldsNotEmpty, validateAge, and validateGender. Next, we use the function defined in line 1, userResponse, to create the user and get a response. Finally, we either retrieve the answer from that function or return a 400 (‘bad request’) if our validation fails. We use Either’s getOrElse, which is similar to that of Option.</p>
<pre><code class="language-ts">function flow(u: UserRegistrationDto) {
    return pipe(
        fieldsNotEmpty(u),
        E.chain(validateAge),
        E.chain(validateGender),
        E.chain(validateNotGerman),
        E.map(userResponse),
        E.getOrElse(badRequest),
    );
}
console.log(flow(exampleEvent));
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>{
_tag: ‘Right’,
right: {
firstName: ‘Test’,
lastName: ‘McTestFace’,
sex: ‘M’,
age: 18,
country: ‘Belgium’
}
}
Created {“firstName”:“Test”,“lastName”:“McTestFace”,“age”:18,“gender”:“M”,“region”:{“_type”:“Europe”}}. Could now save in db
{
status: 201,
message: ‘Created {“firstName”:“Test”,“lastName”:“McTestFace”,“age”:18,“gender”:“M”,“region”:{“_type”:“Europe”}}’
}</p>
<pre><code>

The functions themselves are pretty neat. Most of them are short and pure. We also avoided exceptions using monads. This makes writing tests easy (few possible paths exist in a one-liner), and combining is a breeze as well. The last two more extensive functions (userResponse() and flow()) are proof of that. With only a little effort, we end with something that reads like a linear story: “Flow is the entry point. We do a few checks first and create a user and an appropriate response. In case of failure, we’ll end up here in the getOrElse and return something fitting.” How’s that for maintainability?

We’re using pipe() a lot, and we already mentioned how this seems to be the default way of handling transformations in fp-ts. We shouldn’t use pipe everywhere, but it might be a good default, and it helps fp-ts with type inference. Piping from one function to the next streamlines our effort (avoiding unnecessary creation of variables, passing of parameters, and so on). It’s readable and easy to reason about. But we might run into situations that don’t fit as well or where another approach would give us more maintainable code. In that case, choose whatever alternative seems more appropriate.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="problem-statement-1"><a class="header" href="#problem-statement-1">Problem Statement 1</a></h3>
<p>Suppose we’re working on the application from the last challenge. We want to extend it with an <code>additional function called checkDecentHour</code>, which takes a number and returns a left with the way too early stringwhen the hour is before8`. In our application function, we now want to check whether it’s way too early after checking whether the hour is valid. Instead of returning a default error message as we did earlier, we want to give back whatever error we had.</p>
<pre><code class="language-ts">// Note that you could also use the fp-ts identity function in getOrElse
 
const checkValidHour = (hour: number): E.Either&lt;string, number&gt; =&gt; {
    return hour &gt; 0 &amp;&amp; hour &lt;= 24 ? E.right(hour) : E.left('invalid hour');
};

const mapToGreeting = (hour: number): string =&gt; {
    return hour &lt; 12 ? 'good morning' : 'good afternoon';
};

const checkDecentHour = (hour: number): E.Either&lt;string, number&gt; =&gt; {
    return hour &gt;= 8 ? E.right(hour) : E.left('way too early');
};

const application = (hour: number) =&gt; {
    return pipe(
        checkValidHour(hour),
        E.chain(checkDecentHour),
        h =&gt; E.map(mapToGreeting)(h),
        E.getOrElse(err =&gt; err),
    );
};
console.log(application(5));
console.log(application(9));
</code></pre>
<h3 id="problem-statement-2"><a class="header" href="#problem-statement-2">Problem Statement 2</a></h3>
<p>Given the two functions below, create a function called application that takes a single parameter, hour, of type number and uses pipe() to: Check whether the hour is valid using the checkValidHour function. Change valid hours to the proper greeting using the mapToGreeting function. Fall back to unknown greeting when the hour is invalid.</p>
<pre><code class="language-ts">
const checkValidHour = (hour: number): E.Either&lt;string, number&gt; =&gt; {
    return hour &gt; 0 &amp;&amp; hour &lt;= 24 ? E.right(hour) : E.left('invalid hour');
};

const mapToGreeting = (hour: number) =&gt; {
    return hour &lt; 12 ? 'good morning' : 'good afternoon';
};


const application = (hour: number) =&gt; {
    return pipe(
        checkValidHour(hour),
        h =&gt; E.map(mapToGreeting)(h),
        E.getOrElse(() =&gt; 'unknown greeting'),
    );
};
console.log(application(8));
console.log(application(13));
console.log(application(25));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In our first project, we consciously limited ourselves to the basics. We created an example event and passed it to our application from our IDE. Furthermore, we simply printed results in the output instead of saving them to a database and taking additional actions.</p>
<p>Now, we’ll expand our scope. We’ll actually deploy and run our application in the cloud, bringing us one step closer to the look of a real project. Instead of starting with our types, we’ll adopt a looser approach, coding as we go. But first, a word about our platform, AWS Lambda.</p>
<h2 id="why-use-lambda-for-our-project"><a class="header" href="#why-use-lambda-for-our-project">Why use Lambda for our project?</a></h2>
<p>There are several reasons to use Lambda. First, it simplifies matters for the reader. There’s no need to set up infrastructure, perhaps through a console and SSH-ing into an instance and ensuring our environment is identical. Simply deploy the project manually or with bash, and everything will work. Secondly, Lambda is cheap for exploring. Users have performed many experiments with it while maintaining several functions running daily in their personal accounts, never paying a cent. Compare that to countless warnings from online courses reminding us to turn off our EC2/ECS/EKS instances lest we receive an unexpected cloud bill.</p>
<p>Finally, in general, AWS Lambda and serverless are a good fit for FP. Both like to abstract away concerns, in the case of FP low-level concepts such as loops, and Lambda, the underlying infrastructure. Both AWS Lambda and serverless prefer to create small components (functions) that can be combined with other managed services, in the case of AWS, to create larger applications. FP tries to keep most of its code/functions pure, whereas AWS Lambda is stateless.
What’s Infrastructure as Code?</p>
<p>The AWS Cloud offers several options for creating applications. We can simply click together what we need in the console for experimenting. Or, we can use the CLI/SDK and create our application through code. But for real applications, Infrastructure as Code (IaC) is recommended. Infrastructure as Code describes our infrastructure at a high level in the form of a text document. We define what we need without going into the how. We leave it up to our cloud provider to bring our description to life.</p>
<p>This has many advantages over clicking together an infrastructure or the imperative commands of a CLI. We know exactly what kind of infrastructure we have because it’s described in the document we created, which serves as our single source of truth. Our information about what our infrastructure looks like won’t turn stale as long as we only change infrastructure by changing that document. It’s also easy to recreate our setup (by deleting the current infrastructure and running the document again) or move it to a different AWS region.</p>
<p>In AWS, IaC is provided by AWS CloudFormation. With CloudFormation, we describe our infrastructure as a JSON or YAML file called a template8. The various pieces of infrastructure we need (such as an S3 bucket, SQS queue, EC2 instance, or Lambda) are called Resources. Once we send our file to AWS and our actual infrastructure is created, the result shown in the CloudFormation console is called a stack. So, instead of describing what elements to click in the console, we’re going to write a template that automatically creates the infrastructure stack.</p>
<p>More specifically, we’ll use the Serverless Application Model (SAM), which is a layer on top of CloudFormation specifically designed to simplify the creation of serverless applications. Several interesting alternatives exist, including the AWS CDK (definitely more appropriate for complicated or non-serverless projects), Troposphere, Terraform, and the powerful Serverless framework. Most of these also created Cloudformation “under the hood.”</p>
<pre><code>Note: If we want to deploy an application in the cloud, we’ll have to perform some setup. First, we’ll need to create an AWS account if we don’t already t have one. We’ll also install the AWS CLI (refer to the official documentation) and set default credentials with either the right permissions for deploying, or Admin—with the latter certainly recommended for AWS newbies. We’ll need an S3 bucket in which to store the zipped code. We can create a bucket manually through the AWS console. If you don’t want to do any of this, that’s fine as well. Just follow along with the code.
</code></pre>
<p>Let’s try to bring our entire program together for the first time. We want our handler to look like this:</p>
<pre><code class="language-ts">// some imports

export const handler = async () =&gt; {
    return pipe(
        generateConfig(),
        T.fromIO,
        T.chain(checkLambda),
        T.map(httpResultFromStats),
    )();
};
</code></pre>
<p>To make inference and usage of fp-ts simple, we again resort to using a pipe. Inside that pipe, we generate the configuration and get back an IO. But our other actions are all asynchronous and therefore Tasks! So, how do we deal with this mismatch? One way to do it is to lift our IO stuff to Task. For that, we can use one of the built-in Task functions, fromIO. From that point on, we’re working with a Task, which is why we use its chain to pass our config to an as-yet-unwritten checkLambda function.</p>
<pre><code>Note: We could also have used tagless final to abstract away the concrete monads we’re using, but that’s a more advanced technique we’ll briefly discuss later on.
</code></pre>
<p>This function runs our metric retrieval and transformations for the Lambda, which is passed in through config. It therefore takes in a config and returns ReducedStats, which then maps to an HTTP result using a function we wrote earlier. Let’s fill in the implementation:</p>
<pre><code class="language-ts">const checkLambda = (config: Config) =&gt; {
    return pipe(
        retrieveMetrics(config.between, METRICS)(config.functionName),
        TE.map(statsResultToStatsSumResult),
        TE.map(statsReducer),
        TE.fold(
            (message) =&gt; T.task.of(reducedStatsForFailure(message)),
            T.task.of),
    );
}
</code></pre>
<p>We’re combining the functions we wrote in the previous pages. We pass our metrics, time, and function name to our retrieveMetrics call. Next, we transform those results twice, using map and two of the pure transformers we defined earlier. Unfortunately, our call could fail because we’re dealing with a TaskEither! How do we go from this monad to a Task? Here we chose to use fold, which in the case of a TaskEither requires two functions, one for handling the left value and one for the right. Right is easy because we simply need to place it inside another Task! On the left side, though, we only have a string containing an error message. Here we take that message and pass it into a new function called reducedStatsForFailure, which is placed in the transformers folder and looks like this:</p>
<pre><code class="language-ts">export const reducedStatsForFailure = (message: string): ReducedStats =&gt; ({
    status: 'ERR',
    message: `Could not retrieve info for this function. Error: ${message}`,
}); 
</code></pre>
<p>Lines 2–3: If we encounter an error, we definitely want to report it, so we set the status to ERR and add a message.</p>
<p>In both cases, we get back a Task containing ReducedStats. In one case, it contains a message with information about the function, and in the other case, we have an error because we couldn’t retrieve information from AWS.</p>
<p>Putting it all together gives us the following index (which we can place directly under the src folder).</p>
<pre><code class="language-ts">import * as TE from 'fp-ts/lib/TaskEither';
import * as T from 'fp-ts/lib/Task';
import {Config} from &quot;./util/types&quot;;
import {METRICS} from &quot;./util/constants&quot;;
import {retrieveMetrics} from &quot;./metric-gateway/entrypoint&quot;;
import {pipe} from &quot;fp-ts/pipeable&quot;;
import {
    httpResultFromStats,
    reducedStatsForFailure,
    statsReducer,
    statsResultToStatsSumResult,
} from &quot;./transformations/transformations&quot;;
import {generateConfig} from &quot;./util/config&quot;;

// the function we just discussed
const checkLambda = (config: Config) =&gt; {
    return pipe(
        retrieveMetrics(config.between, METRICS)(config.functionName),
        TE.map(statsResultToStatsSumResult),
        TE.map(statsReducer),
        TE.fold(
            (message) =&gt; T.task.of(reducedStatsForFailure(message)),
            T.task.of),
    );
}

// our handler, discussed earlier
export const handler = async () =&gt; {
    return pipe(
        generateConfig(),
        T.fromIO,
        T.chain(checkLambda),
        T.map(httpResultFromStats),
    )(); //34
};
</code></pre>
<p>Line 34: Note the additional (). To actually get a result, we need to go back to ordinary JavaScript. Because Task is simply a function that returns a Promise, we simply have to call the result of our piping to get that Promise. This is why we return from the handler.</p>
<p>Our index performs the high-level gluing. It generates config, retrieves the metrics for our Lambda, and returns it as an HTTP result. If a failure occurs, we output an HTTP result with an error message. Finally, we return a Promise, which AWS Lambda knows how to handle.</p>
<p>The only thing left to do is to add the function name as an environment variable. This only requires a minor change in our infrastructure:</p>
<pre><code class="language-ts">AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::Serverless-2016-10-31

Resources:
  MetricsLambda:
    Type: AWS::Serverless::Function
    Properties:
      Handler: main.handler
      Runtime: nodejs12.x
      MemorySize: 512
      Timeout: 20
      CodeUri: dist/cloudwatch.zip
      Policies:
        - AWSLambdaExecute
        - Version: &quot;2012-10-17&quot;
          Statement:
            - Effect: Allow
              Action:
                - &quot;cloudwatch:Get*&quot;
                - &quot;cloudwatch:List*&quot;
              Resource:
                - &quot;*&quot;
      Environment: //34
        Variables:
          FUNCTION_NAME: monitoring-example-MetricsLambda-123456789
</code></pre>
<p>Lines 23–25: Here we inform AWS Lambda that we’d like to add an environment variable called FUNCTION_NAME, with the given value, to our Lambda environment. The value of FUNCTION_NAME will be different in your case. Check your CloudFormation or Lambda console.</p>
<p><code>Note:</code>
Ideally, you wouldn’t refer to a hardcoded value in your YAML file. You could write code to retrieve the correct name. Or, if the Lambda you want to check is in the same template as your MetricsLambda, you could use “Ref” to get the right name injected by CloudFormation. In this case it would fail, though, because we have Lambda, which is observing itself, and it would result in a circular dependency. But in real scenarios, that would be the way to go.</p>
<p>That’s it. We can now deploy the Lambda again and view the results when we trigger it.</p>
<p>A few remarks before we continue. First, there were several valid ways to use the functions defined in the transformations folder. Here we chose to combine them at the very last moment. We could’ve used compose or flow to reduce the number of maps needed in our index. For example:</p>
<pre><code class="language-ts">export const combined = (results: readonly StatsResult[]): ReducedStats =&gt; {
    return flow(
        statsResultToStatsSumResult,
        statsReducer,
    )(results);
};
</code></pre>
<p>The code above shows one less map in checkLambda. But we could’ve gone a step further:</p>
<pre><code class="language-ts">export const combined = (results: readonly StatsResult[]): HttpResult =&gt; {
    return flow(
        statsResultToStatsSumResult,
        statsReducer,
        httpResultFromStats,
    )(results);
};
</code></pre>
<p>In this case, we’d remove the last map in index.ts and transform the failure to HttpResult in checkLambda. Both approaches (composing with maps or with flow) have their advantages and disadvantages. Composing within the transformers file exposes less surface, resulting in a better-defined module. That is, transformers is a module that changes the result into something we can give back, and we have no business knowing how exactly it goes about doing this. That’s an implementation detail.</p>
<p>On the other hand, that approach can be too rigid. What if this code was shared by two Lambdas and the second one wanted to use ReducedStats to generate an email, meaning that it doesn’t need the final HttpResult transformation? We’d have to add another function to transformers, composing the first two and adding a new third function. Or, if we’d exposed more functions, we could leave it up to the Lambdas themselves to use the transforms available to get the right results. So, minimizing the surface area (the number of exposed functions) is a good idea, but we still want to retain a bit of flexibility. In the end, we’ll be combining functions regardless.</p>
<p>It’s also best practice to avoid putting too much logic in the index file when writing Lambda code. This is because it often contains initialization content that might make the unit test difficult. We could extract checkLambda into another file. Also, note that a Lambda container can be reused by subsequent invocations. If we have a request A at time zero and a request B at time one, any logic outside of the handler function will be initialized only once. This means that a Lambda with the following code, when invoked twice, might print the same time more than once, depending on whether we received a new container from AWS, or the old one.</p>
<pre><code class="language-ts">console.log(`current time is ${Date.now()}`);
export const handler = async () =&gt; {
    return pipe(
        // ...
    )();
};
</code></pre>
<p>This means we can optimize our code by performing as much initialization as possible outside our handler function because anything outside the handler is subject to reuse. In our case, though, there’s little to optimize. We could create the config beforehand, but we’d risk continually getting old Between values. Your perspective will determine whether the Lambda container could be reused for hours.</p>
<p>Finally, a minor improvement would be to make a newtype FunctionName to replace the string from Config. That way, we ensure that no one passes a faulty string to the relevant functions by mistake.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="problem-statement"><a class="header" href="#problem-statement">Problem statement</a></h2>
<p>Complete the application function.
Our function should use flow to build a person and enrich it with age and country, using the predefined helper functions.</p>
<pre><code class="language-ts">import {flow} from &quot;fp-ts/function&quot;;
type BasicPerson = {
    name: string,
};

type PersonWithAge = BasicPerson &amp; {
    age: number,
};

type PersonWithAgeAndCountry = PersonWithAge &amp; {
    country: string,
}

const buildBasicPerson = (name: string): BasicPerson =&gt; ({
    name,
});

const enrichWithAge = (person: BasicPerson): PersonWithAge =&gt; ({
    ...person,
    age: person.name.length,
});

const enrichWithCountry = (person: PersonWithAge): PersonWithAgeAndCountry =&gt; ({
    ...person,
    country: 'Frediano',
});
// Complete the below function
// const application = (name: string): PersonWithAgeAndCountry =&gt; {
//    ...
// };
</code></pre>
<h4 id="solution"><a class="header" href="#solution">Solution</a></h4>
<pre><code class="language-ts">const application = (name: string): PersonWithAgeAndCountry =&gt; {
    return flow(
        buildBasicPerson,
        enrichWithAge,
        enrichWithCountry,
    )(name);
};
console.log(application(&quot;Ali&quot;));
</code></pre>
<p><code>Explanation</code></p>
<p>Lines 1–7: Create the application function, which uses flow to build a person and enrich it with an age and country.</p>
<h4 id="output-1"><a class="header" href="#output-1">Output</a></h4>
<pre><code class="language-json">{ name: 'Ali', age: 3, country: 'Frediano' }
</code></pre>
<h2 id="problem-statement-2-1"><a class="header" href="#problem-statement-2-1">Problem statement 2</a></h2>
<p>Complete the application function using the predefined functions.
The function should take the result of the checkInput function.
Call the externalService function, using the errorMapper to handle failures.
Uppercase the result of that call.
Use a getOrElse to prefix We got back an error: to any error we receive.</p>
<pre><code class="language-ts">import * as E from 'fp-ts/Either';
import * as TE from 'fp-ts/TaskEither';
import * as T from 'fp-ts/Task';
import {pipe} from &quot;fp-ts/function&quot;;

const checkInput = (input: string) =&gt; input === 'invalid' ? E.left('Invalid input') : E.right(input);

const externalService = (input: string) =&gt; {
    if (input === 'error') {
        return Promise.reject('Call to external service failed');
    }
    return Promise.resolve('result');
};

const errorMapper = (err: unknown) =&gt; err;

const toUpperCase = (input: string) =&gt; input.toUpperCase();
// Complete the below function
// const application = (input: string) =&gt; {
//     return pipe(
//         checkInput(input),
//         ...
//     )();
// };

</code></pre>
<h3 id="solution-1"><a class="header" href="#solution-1">Solution</a></h3>
<pre><code class="language-ts">const application = (input: string) =&gt; {
    return pipe(
        checkInput(input), //3
        TE.fromEither,
        TE.chain((input: string) =&gt; TE.tryCatch(() =&gt; externalService(input), errorMapper)),
        TE.map(toUpperCase),
        TE.getOrElse((err) =&gt; T.of(`We got back an error: ${err}`)) //7
    )();
};

</code></pre>
<p><code>Explanation</code></p>
<p>Here’s a line-by-line explanation of the solution above:</p>
<p>Line 1: Create the application function.
Line 3: Instruct the functions to take the result of the checkInput function.
Line 5: Call the externalService function, using the errorMapper to handle failures.
Line 6: Uppercase the result of the call above.
Line 7: Use a getOrElse to prefix “We got back an error:” to any error we receive.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tagless-final"><a class="header" href="#tagless-final">Tagless Final</a></h2>
<p>We could summarize tagless final by saying that it raises the level of abstraction of our program, specifically in regard to our use of monads. When we develop our DSL, our domain-specific mini-language, we often base it on monads. An example would be when we have to validate or do any kind of I/O. In previous chapters, we used the existing fp-ts monads like Either or Task directly as return types. In the tagless final, we’d instead declare a new abstract return type by convention called F. This F can’t be just about anything. It should definitely be a monad, and we might limit its type even further. On the other hand, it’s much less specific than using one particular monad.
Advantages of tagless final</p>
<p>The advantages we gain from this abstraction are two-fold. First, by using monads as a basic element in our applications, we can easily chain operations. In many of the other languages where the tagless final is popular (like Scala or Haskell) this is accomplished using do notation. Second, our code doesn’t depend on one specific monad. We can run it with whatever we want, as long as it fits the requirements we specified. In fact, we need a so-called interpreter for F to actually run the program we defined. An obvious advantage of this is that we can pull in a fake interpreter when we want to test our code, replacing IO with mocks, and so on.</p>
<p><code>Note:</code> Do notation is also available within fp-ts, but it’s less fluent, and we might still prefer piping.</p>
<p>Interesting to note is that one of the people who made tagless final popular in the Scala world now seems to be advising against its use. He’s come to believe that it’s overkill for most projects and “premature indirection,” a level of abstraction that might sound good but won’t serve any practical use.</p>
<h2 id="domain-specific-languages"><a class="header" href="#domain-specific-languages">Domain-specific languages</a></h2>
<h3 id="maints-1"><a class="header" href="#maints-1">main.ts</a></h3>
<pre><code class="language-ts">import {count, dollars, euros} from &quot;./bankdsl&quot;

console.log(count(
    dollars(2),
    euros(5),
    dollars(1),
))
</code></pre>
<h3 id="bankdslts"><a class="header" href="#bankdslts">bankdsl.ts</a></h3>
<pre><code class="language-ts">type Dollar = {
    _type: 'dollar'
}
type Euro = {
    _type: 'euro'
}

type Currency = Dollar | Euro;

type Money = {
    amount: number,
    currency: Currency,
}
export const dollars = (amount: number): Money =&gt; ({
    amount,
    currency: {
        _type: 'dollar',
    }
});

export const euros = (amount: number): Money =&gt; ({
    amount,
    currency: {
        _type: 'euro',
    }
});
export function count(...ms: Money[]) {
    return ms.reduce((acc, curr) =&gt; {
        if (curr.currency._type === 'dollar') {
            acc.dollars += curr.amount;
        } else {
            acc.euros += curr.amount;
        }
        return acc;
    }, {dollars: 0, euros: 0});
}
</code></pre>
<p>Note that JavaScript and TypeScript aren’t ideal as languages for a fluent DSL, partly because they lack infix operators. In languages like Haskell, Purescript, or Kotlin, we can do something like this (after creating infix functions count, dollars, euros, and and):</p>
<pre><code class="language-bash">count 2 dollars and 3 euros
</code></pre>
<p>But TypeScript doesn’t support infix because JavaScript doesn’t. So, our DSLs are, unfortunately, less readable. Furthermore, the difference between the above and what we were doing in previous chapters is subtle. We’re thinking even more about naming. What will make our code easy to understand by outsiders and non-technical people? We’re thinking about ease of use as well. That is, how can we make creating Money as simple as possible (using, among other things, our smart constructors)? Do we have to force the users of our language to pass an array to count? No, use the spread operator, and they can pass in anything they like, as long as it’s money. Somewhat less important in our example is what information we expose. We export those functions our users need, like methods for creating amounts in dollars or euros. We don’t see a reason for them to create a currency directly, so we hide that.</p>
<p>A large application written in FP, using DSLs, would consist of code organized in modules with clear responsibilities or a single concern (like handle authentication). Each module offers a DSL that simplifies usage, at the same time hiding implementation details. A developer who has a need for something like authentication doesn’t have to dive into the code. They turn to the DSL. This method is good for keeping the code manageable, organized, and understandable. In FP, the mini-language we create is often called an Algebra. In our above example, count is part of the Algebra of our application.</p>
<p>You can write your DSL with the techniques we saw in previous chapters. Or you can turn to some more advanced techniques discussed in the upcoming lessons. And, like anything advanced that we’ve seen so far, those techniques revolve around the use of monads.</p>
<h2 id="free-monads"><a class="header" href="#free-monads">Free Monads</a></h2>
<p>Free monads are, in some ways, very similar to the tagless final. In essence, they allow us to turn any functor (the part of a monad that has a map) into a monad, thereby gaining of and chain functionality without any additional work.</p>
<p>This is in itself already quite nifty, but free monads can also be used to build our application as an Abstract Syntax Tree (AST). First, create the functor, which consists of the commands that are important in our application (think of this as a DSL). Next, lift it so that it becomes a free monad. Now we can combine the commands we just created in our program. This will, yet again, look nicer in a language like PureScript or Haskell. But it will work just the same in TypeScript, and it might make our application code more readable and usable.
We’re not finished, though. Our code won’t actually do anything yet! For that, we need to again write an interpreter that will give meaning to each of our commands. This gives us an advantage when it comes to mocking. There are drawbacks as well, besides the added complexity. For one, the recursive nature of this solution means that we might trigger a stack overflow. Even if we avoid this by using trampolining, our solution won’t win any performance prizes. So, don’t use this solution unless you think your domain or application (and its complexity) warrants it.</p>
<p>Some applications are based on a previous version of fp-ts, but most changes required to make these examples work are simple enough. For example, instead of calling chain on our monad, we should now use a pipe to combine chains (as we’ve seen countless times in the previous pages), and Free is now located in the fp-ts-contrib library.</p>
<h2 id="executable-and-declarative-encoding-and-algebraic-design"><a class="header" href="#executable-and-declarative-encoding-and-algebraic-design">Executable and Declarative Encoding and Algebraic Design</a></h2>
<h3 id="executable-vs-declarative-encoding"><a class="header" href="#executable-vs-declarative-encoding">Executable vs. declarative encoding</a></h3>
<p>Executable encoding is most similar to what we’ve done in previous chapters, while declarative encoding is similar to the two techniques we just discussed. Our DSL is just data that needs interpretation and can have multiple interpreters, and we have the option to define more of them whenever we desire. While the former is simpler, the latter has more power and flexibility.</p>
<h3 id="algebraic-design"><a class="header" href="#algebraic-design">Algebraic design</a></h3>
<p>Another term worth mentioning is algebraic design. An algebra (mentioned earlier in this chapter) is a group of functions that work with certain types of data, with an accompanying set of laws. We design our application starting with this algebra. Only later do we decide on a representation for it. We create types, which serve as our interface, and later write an implementation for it all. Once again, the idea is to first clearly model our domain. The actual implementation is of no concern yet. In fact, working on it might distract us. This is similar to TDD, where we focus on working on what we want to accomplish through writing tests before we turn to the how.</p>
<p>John A De Goes writes: “Most functional code doesn’t solve problems directly. Instead, it creates models of solutions to problems, which are later executed (or interpreted).”</p>
<h2 id="coding-challenge-create-a-mini-dsl"><a class="header" href="#coding-challenge-create-a-mini-dsl">Coding Challenge: Create a Mini DSL</a></h2>
<h3 id="problem-statement-1"><a class="header" href="#problem-statement-1">Problem statement</a></h3>
<p>Let’s create a mini DSL that makes it easier to create (correct) flights for an airport.</p>
<p>Notice that we’ve already defined a couple of useful types. Flights have different properties, depending on whether they’re arrivals or departures, so we have a separate type for each.
We’ve also written a smart constructor for airplane. This ensures that we can only create a valid airplane, refusing to create one with missing and essential information like the number of seats.</p>
<p>The createFlight function is another smart constructor, but it’s not yet implemented. We must accomplish the following:</p>
<pre><code>Add the signature (parameters and types).
In the body, first check that all parameters are defined.
Return an arrival or departure flight (preferably using a switch with an exhaustive check).
</code></pre>
<p>The application function should help us fill in the signature of createFlight.</p>
<pre><code class="language-ts">import * as O from 'fp-ts/Option';
import {pipe} from &quot;fp-ts/function&quot;;

type Airplane = {
    seats: number,
};

type ArrivalFlight = {
    type: 'Arrival',
    arrivalTime: Date,
    airplane: Airplane,
};

type DepartureFlight = {
    type: 'Departure'
    departureTime: Date,
    airplane: Airplane
}

type Flight = ArrivalFlight | DepartureFlight;

type KindOfFlight = 'ARRIVAL' | 'DEPARTURE';

const createAirplane = (seats: number): O.Option&lt;Airplane&gt; =&gt; {
    return seats &amp;&amp; seats &gt; 0 ? O.some({
        seats
    }) : O.none;
};
// Complete the below function
// const createFlight = ... =&gt; {
//     ...
// };

const application = (): O.Option&lt;Flight&gt; =&gt;
    pipe(
        createAirplane(100),
        O.chain((res: Airplane) =&gt; createFlight('ARRIVAL', new Date())(res))
    );
</code></pre>
<h4 id="solution-2"><a class="header" href="#solution-2">Solution</a></h4>
<pre><code class="language-ts">const createFlight = (typeOfFlight: KindOfFlight, date: Date) =&gt; (airplane: Airplane): O.Option&lt;Flight&gt; =&gt; {
    if (!typeOfFlight || !date || !airplane) {
        return O.none;
    }

    switch (typeOfFlight) {
        case 'ARRIVAL': {
            return O.some({
                type: 'Arrival',
                arrivalTime: date,
                airplane,
            });
        }
        case 'DEPARTURE': {
            return O.some({
                type: 'Departure',
                departureTime: date,
                airplane,
            });
        }
        default:
            const _exhaustiveCheck: never = typeOfFlight;
            return _exhaustiveCheck;
    }
};
console.log(createFlight(&quot;ARRIVAL&quot;,new Date())({seats:100}));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-writer-monad"><a class="header" href="#the-writer-monad">The Writer monad</a></h2>
<p>The Writer monad is another classic monad. Whereas Reader was used to retrieve values at the right time, Writer is used to store them away. The most common example use case for Writer is gathering log messages.</p>
<h2 id="the-these-monad"><a class="header" href="#the-these-monad">The These monad</a></h2>
<p>The These monad has some similarities with the Either monad in that it has a left and a right value. However, while Either doesn’t handle its left value, These processes both its left, its right, or both at the same time.</p>
<pre><code class="language-ts">import {pipe} from &quot;fp-ts/function&quot;;
import * as T from &quot;fp-ts/These&quot;
const result = pipe(
    T.both('left', 0),
    T.bimap(v =&gt; v.toUpperCase(), v =&gt; v + 1),
    T.map(v =&gt; v * 2),
    T.mapLeft(v =&gt; v + ' world'),
    T.swap
);

console.log(T.toTuple(0, 'default')(result));
</code></pre>
<p>This prints [2, ‘LEFT world’]. Note that the bimap is used to transform both the left and right value, the mapLeft only changes the left value, and the swap swaps the two values. The resulting tuple will be in reverse order. The fp-ts library also has a TaskThese, combining the powers of Task and These.</p>
<p>Note: Swap is also available for monads like TaskEither. In something like monitoring, an error, normally a left, might be a good thing that you want to process. In that case, you can put it in a right.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>In this section we discuss how to read and understand TypeScript errors. We follow this with common errors and their solutions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h1>
<p>In this section we explain a number of common error codes that users experience in the real world.</p>
<h1 id="object-and-type"><a class="header" href="#object-and-type">Object and Type</a></h1>
<h2 id="s1"><a class="header" href="#s1">S1</a></h2>
<pre><code class="language-TypeScript">// Declare a variable 'nameIdObject' and initialize it with an object that has a 'name' property, an 'id' property, and a 'print' method
var nameIdObject = { name: &quot;myName&quot;, id: 1, print() {} };
// Assign a new object to 'nameIdObject'. This object has a 'name' property and an 'id' property, but it does not have the 'print' method
// that the original object had.
nameIdObject = { id: 3, name: &quot;thirdName&quot; };
</code></pre>
<blockquote>
<p><code>Output</code></p>
</blockquote>
<pre><code class="language-md">index.ts(5,1): error TS2741: Property 'print' is missing in type '{ id: number; name: string; }' but required in type '{ name: string; id: number; print(): void; }'.
</code></pre>
<blockquote>
<p><code>Solution</code></p>
</blockquote>
<pre><code class="language-TypeScript">// Declare a variable called item1 with a type of any and assign to it an object literal that has properties id and name
var item1: any = { id: 1, name: &quot;item1&quot; }

// Assign a new object literal to item1 with only an id property
item1 = { id: 2 };
</code></pre>
<h2 id="s2"><a class="header" href="#s2">S2</a></h2>
<pre><code class="language-TypeScript">// Declare a variable 'obj1' and initialize it with an object that has an 'id' property and a 'print' method
var obj1 = { id: 1, print() { } };

// Declare a variable 'obj2' and initialize it with an object that has an 'id' property, a 'print' method, and a 'select' method
var obj2 = { id: 2, print() { }, select() { } }

// Attempt to assign 'obj2' to 'obj1'. This won't cause a type error because 'obj2' has all of the methods that are present in the type of 'obj1'
obj1 = obj2;

// Attempt to assign 'obj1' to 'obj2'. This will cause a type error because 'obj1' is missing the 'select' method that is present in the type of 'obj2'
obj2 = obj1;
</code></pre>
<blockquote>
<p><code>Notice</code></p>
</blockquote>
<p>The duck typing examples used here are also using inferred typing, so the type of an object is inferred from when it is first assigned.</p>
<blockquote>
<p><code>Output</code></p>
</blockquote>
<pre><code class="language-md">index.ts(11,1): error TS2741: Property 'select' is missing in type '{ id: number; print(): void; }' but required in type '{ id: number; print(): void; select(): void; }'.
</code></pre>
<h2 id="s3"><a class="header" href="#s3">S3</a></h2>
<pre><code class="language-TypeScript">// Declare a function called addWithUnion that takes in two parameters, arg1 and arg2, with types of string or number
function addWithUnion(
  arg1: string | number,
  arg2: string | number
) {
  // Return the sum of arg1 and arg2
  return arg1 + arg2;
}
</code></pre>
<blockquote>
<p><code>Output</code></p>
</blockquote>
<pre><code class="language-md">index.ts(7,10): error TS2365: Operator '+' cannot be applied to types 'string | number' and 'string | number'.
</code></pre>
<blockquote>
<p><code>Solution</code>
Adding guards</p>
</blockquote>
<pre><code class="language-TypeScript">// Declare a function called addWithTypeGuard that takes in two parameters, arg1 and arg2, with types of string or number
// Declare a function called addWithTypeGuard that takes in two parameters, arg1 and arg2, with types of string or number
function addWithTypeGuard(
  arg1: string | number,
  arg2: string | number
) {
  // Check if arg1 is a string
  if (typeof arg1 === &quot;string&quot;) {
    // If it is, log that it is a string and return the sum of arg1 and arg2 as a string
    console.log(`arg1 is of type string`);
    return arg1 + arg2;
  }
  // Check if both arg1 and arg2 are numbers
  if (typeof arg1 === &quot;number&quot; &amp;&amp; typeof arg2 === &quot;number&quot;) {
    // If they are, log that they are numbers and return the sum of arg1 and arg2 as a number
    console.log(`arg1 and arg2 are numbers`);
    return arg1 + arg2;
  }
  // If arg1 and arg2 are not both numbers, log that they are being treated as strings and return their concatenation as a string
  console.log(`default return treat both as strings`)
  return arg1.toString() + arg2.toString();
}

console.log(` &quot;1&quot;, &quot;2&quot; = ${addWithTypeGuard(&quot;1&quot;, &quot;2&quot;)}`);
console.log(` 1 , 2 = ${addWithTypeGuard(1, 2)}`);
console.log(` 1 , &quot;2&quot; = ${addWithTypeGuard(1, &quot;2&quot;)}`);
</code></pre>
<p><code>Output</code>
:arg1 is of type string
“1”, “2” = 12
arg1 and arg2 are numbers
1 , 2 = 3
default return treat both as strings
1 , “2” = 12</p>
<h2 id="s4"><a class="header" href="#s4">S4</a></h2>
<pre><code class="language-TypeScript">// This line logs the value of the variable &quot;lValue&quot; to the console, before it has been defined
console.log(`lValue = ${lValue}`);
// This line declares the variable &quot;lValue&quot; and assigns it the value of 2
let lValue = 2;
</code></pre>
<p><code>Output</code>
:index.ts(2,25): error TS2448: Block-scoped variable ‘lValue’ used before its declaration.</p>
<p><code>Solution</code><br />
:The compiler is letting us know that we have possibly made a logic error by using the value of a variable before we have declared the variable itself.</p>
<h2 id="s5"><a class="header" href="#s5">S5</a></h2>
<p>Definite assignment or !</p>
<pre><code class="language-TypeScript">// Declare a variable named &quot;globalString&quot; with the type of &quot;string&quot;
var globalString: string;

// Call the function &quot;setGlobalString&quot; and pass in the argument &quot;this string is set&quot;
setGlobalString(&quot;this string is set&quot;);

// Log the current value of the &quot;globalString&quot; variable to the console
console.log(`globalString = ${globalString}`);

// Define a function named &quot;setGlobalString&quot; that takes in a parameter named &quot;value&quot; with the type &quot;string&quot;
function setGlobalString(value: string) {
  // Assign the value of the &quot;value&quot; parameter to the &quot;globalString&quot; variable
  globalString = value;
}
</code></pre>
<p><code>Output</code>
:index.ts(8,31): error TS2454: Variable ‘globalString’ is used before being assigned.</p>
<p><code>Solution</code>
:Using Definite assignment</p>
<h2 id="ts2448"><a class="header" href="#ts2448">TS2448</a></h2>
<pre><code class="language-typescript">// This line logs the value of the variable &quot;lValue&quot; to the console, before it has been defined
console.log(`lValue = ${lValue}`);

// This line declares the variable &quot;lValue&quot; and assigns it the value of 2
let lValue = 2;
</code></pre>
<p><code>&gt; Output:</code></p>
<p><code>index.ts(2,25): error TS2448: Block-scoped variable 'lValue' used before its declaration.</code></p>
<h2 id="ts2304"><a class="header" href="#ts2304">TS2304</a></h2>
<p>Samples:</p>
<blockquote>
<p><code>Cannot find name ga</code>
<code>Cannot find name $</code>
<code>Cannot find module jquery</code></p>
</blockquote>
<p>You are probably using a third party library (e.g. google analytics) and don’t have it <code>declare</code>d. TypeScript tries to save you from <em>spelling mistakes</em> and <em>using variables without declaring them</em> so you need to be explicit on anything that is <em>available at runtime</em> because of you including some external library (<a href="errors/../types/ambient/d.ts.html">more on how to fix it</a>).</p>
<h2 id="ts2307"><a class="header" href="#ts2307">TS2307</a></h2>
<p>Samples:</p>
<blockquote>
<p><code>Cannot find module 'underscore'</code></p>
</blockquote>
<p>You are probably using a third party library (e.g. underscore) as a <em>module</em> (<a href="errors/../project/modules.html">more on modules</a>) and don’t have the ambient declaration file for it (<a href="errors/../types/ambient/d.ts.html">more on ambient declarations</a>).</p>
<h2 id="ts1148"><a class="header" href="#ts1148">TS1148</a></h2>
<p>Sample:</p>
<blockquote>
<p>Cannot compile modules unless the ‘–module’ flag is provided</p>
</blockquote>
<p>Checkout the <a href="errors/../project/modules.html">section on modules</a>.</p>
<h2 id="catch-clause-variable-cannot-have-a-type-annotation"><a class="header" href="#catch-clause-variable-cannot-have-a-type-annotation">Catch clause variable cannot have a type annotation</a></h2>
<p>Sample:</p>
<pre><code class="language-js">try { something(); }
catch (e: Error) { // Catch clause variable cannot have a type annotation
}
</code></pre>
<p>TypeScript is protecting you from JavaScript code in the wild being wrong. Use a type guard instead:</p>
<pre><code class="language-js">try { something(); }
catch (e) {
  if (e instanceof Error){
    // Here you go.
  }
}
</code></pre>
<h2 id="interface-elementclass-cannot-simultaneously-extend-types-component-and-component"><a class="header" href="#interface-elementclass-cannot-simultaneously-extend-types-component-and-component">Interface <code>ElementClass</code> cannot simultaneously extend types <code>Component</code> and <code>Component</code></a></h2>
<p>This happens when you have two <code>react.d.ts</code> (<code>@types/react/index.d.ts</code>) in the compilation context.</p>
<p><strong>Fix</strong>:</p>
<ul>
<li>Delete <code>node_modules</code> and any <code>package-lock</code> (or yarn lock) and <code>npm install</code> again.</li>
<li>If it doesn’t work, find the invalid module (all modules used by your project should have <code>react.d.ts</code> as a <code>peerDependency</code> and not a hard <code>dependency</code>) and report it on their project.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conflict-ts-and-js"><a class="header" href="#conflict-ts-and-js">Conflict TS and JS</a></h1>
<p>TypeScript was designed to detect possible exceptions that can occur at runtime during compilation time by having the developer define the intent with type annotations. In addition, TypeScript can also catch issues if no type annotation is provided. For instance, the following code snippet does not specify any TypeScript types:</p>
<p>[[Error_Redeclare]] [[Error_TS2451]]</p>
<!-- skip -->
<pre><code class="language-typescript">const items = [{ x: 1 }, { x: 2 }];
const result = items.filter(item =&gt; item.y);
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2451: Cannot redeclare block-scoped variable 'result'.
</code></pre>
<p>[[Error_Property]]
In this case, TypeScript detects an error and reports:</p>
<pre><code class="language-text">Property 'y' does not exist on type '{ x: number; }'.
</code></pre>
<p>TypeScript’s type system is largely influenced by the runtime behavior of JavaScript. For example, the addition operator (+), which in JavaScript can either perform string concatenation or numeric addition, is modeled in the same way in TypeScript:</p>
<pre><code class="language-typescript">const result = '1' + 1; // Result is of type string
</code></pre>
<p>The team behind TypeScript has made a deliberate decision to flag unusual usage of JavaScript as errors. For instance, consider the following valid JavaScript code:</p>
<!-- skip -->
<pre><code class="language-typescript">const result = 1 + true; // In JavaScript, the result is equal 2
</code></pre>
<p>[[Error_Operator]]
However, TypeScript throws an error:</p>
<pre><code class="language-text">Operator '+' cannot be applied to types 'number' and 'boolean'.
</code></pre>
<p>This error occurs because TypeScript strictly enforces type compatibility, and in this case, it identifies an invalid operation between a number and a boolean.</p>
<p>The TypeScript compiler has two main responsibilities: checking for type errors and compiling to JavaScript. These two processes are independent of each other. Types do not affect the execution of the code in a JavaScript engine, as they are completely erased during compilation. TypeScript can still output JavaScript even in the presence of type errors.
Here is an example of TypeScript code with a type error:</p>
<p>[[Error_TS2345]]</p>
<!-- skip -->
<pre><code class="language-typescript">const add = (a: number, b: number): number =&gt; a + b;
const result = add('x', 'y'); // Argument of type 'string' is not assignable to parameter of type 'number'.
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
</code></pre>
<p>[[Error_Parameter]] [[Error_TS7006]]
However, it can still produce executable JavaScript output:</p>
<!-- skip -->
<pre><code class="language-typescript">'use strict';
const add = (a, b) =&gt; a + b;
const result = add('x', 'y'); // xy
</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-md">error TS7006: Parameter 'b' implicitly has an 'any' type.
</code></pre>
<h2 id="mapped-type-modifiers-1"><a class="header" href="#mapped-type-modifiers-1">Mapped Type Modifiers</a></h2>
<p><a href="types/../collection/map.html">Related to</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpreting-errors"><a class="header" href="#interpreting-errors">Interpreting Errors</a></h1>
<p>Since TypeScript is a heavily focused <em>Developer Help</em> oriented programming language, its errors messages try to be super helpful when something goes wrong. This can lead to a slight information overload for unsuspecting users of compilers that aren’t so helpful. </p>
<p>Lets look at an example in an IDE to break apart the process of reading an error message. </p>
<pre><code class="language-typescript">type SomethingComplex = {
  foo: number,
  bar: string
}
function takeSomethingComplex(arg: SomethingComplex) {
}
function getBar(): string {
  return 'some bar';
}

//////////////////////////////////
// Example error production
//////////////////////////////////
const fail = {
  foo: 123,
  bar: getBar
};

takeSomethingComplex(fail); // TS ERROR HAPPENS HERE 
</code></pre>
<p>This example demonstrates a common programmer error where they <em>fail</em> to call a function (<code>bar: getBar</code> should be <code>bar: getBar()</code>). Fortunately this mistake is caught by TypeScript as soon as it doesn’t meet the type requirements. </p>
<h2 id="error-categories"><a class="header" href="#error-categories">Error Categories</a></h2>
<p>There are two categories of TypeScript Error messages (succinct and detailed). </p>
<h3 id="succinct"><a class="header" href="#succinct">Succinct</a></h3>
<p>The objective of the succinct error message is to provide an example <em>conventional compiler</em> description of the error number and message. For this example the succinct message looks like: </p>
<pre><code>TS2345: Argument of type '{ foo: number; bar: () =&gt; string; }' is not assignable to parameter of type 'SomethingComplex'.
</code></pre>
<p>It is fairly self explanatory. However, it doesn’t provide a deeper breakdown of <em>why</em> the error is happening. That is what the <em>detailed</em> error message is for.</p>
<h3 id="detailed"><a class="header" href="#detailed">Detailed</a></h3>
<p>For this example the detailed version looks like: </p>
<pre><code>[ts]
Argument of type '{ foo: number; bar: () =&gt; string; }' is not assignable to parameter of type 'SomethingComplex'.
  Types of property 'bar' are incompatible.
    Type '() =&gt; string' is not assignable to type 'string'.
</code></pre>
<p>The objective of the detailed error message is to <em>guide</em> the user to the reason why some error (type incompatibility in this case) is happening. The first line is same as the succinct, followed by a chain. You should read this chain as a series of responses to the developer question <code>WHY?</code> between lines i.e </p>
<pre><code>ERROR: Argument of type '{ foo: number; bar: () =&gt; string; }' is not assignable to parameter of type 'SomethingComplex'.

WHY? 
CAUSE ERROR: Types of property 'bar' are incompatible.

WHY? 
CAUSE ERROR: Type '() =&gt; string' is not assignable to type 'string'.
</code></pre>
<p>So the root cause is,</p>
<ul>
<li>for property <code>bar</code></li>
<li>there is a function <code>() =&gt; string</code> while it was expected as a <code>string</code>. </li>
</ul>
<p>This should help the developer fix the bug for the <code>bar</code> property (they forgot to invoke <code>()</code> the function).</p>
<h2 id="how-it-shows-up-in-an-ide-tooltip"><a class="header" href="#how-it-shows-up-in-an-ide-tooltip">How it shows up in an IDE Tooltip</a></h2>
<p>The IDE normally shows the <code>detailed</code> followed by the <code>succinct</code> version in a tooltip as shown below: </p>
<p><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/errors/interpreting-errors/ide.png" alt="IDE error message example" /></p>
<ul>
<li>You normally just read the <code>detailed</code> version forming the <code>WHY?</code> chain in your head. </li>
<li>You use the succinct version if you want to search for similar errors (using the <code>TSXXXX</code> error code or portions of the error message)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Some of the oldest, and therefore most mature, frameworks include Jasmine, QUnit and Mocha.
There have also been attempts to write unit testing frameworks in TypeScript, including MaxUnit or tsUnit, but these frameworks never really took off.
Jest, which was written by the Facebook team and integrates with Babel, TypeScript, Node, React, Angular, and Vue.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
White-box tests are where the internal logic or structure of the code is <strong>known</strong> to the tester.</li>
<li><input disabled="" type="checkbox" checked=""/>
Black-box tests, on the other hand, are tests where the internal design or <strong>logic is not known</strong> to the tester.</li>
</ul>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h3>
<p>A unit test is typically a <strong>white-box test where all of the external interfaces to a block of code are mocked or stubbed out.</strong> If we are testing some code that does an asynchronous call to load a block of JSON, for example, unit testing of this code would require mocking out the returned JSON. This technique ensures that the object under test is always given a known set of data. When new requirements come along, this known set of data can grow and expand, of course. Objects under test should be designed to interact with interfaces so that those interfaces can be easily mocked or stubbed in a unit test scenario.</p>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h3>
<p>Integration tests are another form of <strong>white-box tests that allow the object under test to run in an environment close to how it would look in a real deployment.</strong> In our earlier example, where some code needs to do an asynchronous call to load a block of JSON data, an integration test would need to actually call the <strong>REST services</strong> that generated the JSON. If this REST service relied upon data from a database, then the integration test would need data in the <strong>database</strong> that matched the integration test scenario. If we were to describe a unit test as having a boundary around the object under test, then an integration test is an expansion of this boundary to include <strong>dependent objects or services.</strong></p>
<p>Building automated integration tests for our applications will improve the quality of our product immensely. Consider the case for the scenario we have been discussing—where a block of code calls a REST service for some JSON data. Someone could easily change the structure of the JSON data that the REST service returns. Our unit tests would still pass, as they are not actually calling the REST service, but our application would be broken because the returned JSON is not what we are expecting.</p>
<p>Without integration tests, these types of errors will only be picked up in the later stages of manual testing, or possibly only in production. The later a failure in our system is identified, the more expensive it is to fix.</p>
<h3 id="acceptance-tests"><a class="header" href="#acceptance-tests">Acceptance tests</a></h3>
<p>Acceptance tests are black-box tests and are generally scenario-based. They may incorporate multiple user screens or user interactions in order to pass. Although these tests are generally carried out by a testing team, they can be automated fairly easily with the wealth of modern testing tools that are readily available. Automating acceptance testing is really the holy grail of the testing tree. Humans can easily make mistakes, and using a testing team to repeatedly run hundreds of <strong>acceptance tests is not always reliable, is expensive, and takes a long time.</strong></p>
<p>Having a full suite of automated acceptance tests also proves that the application works and that new features have not inadvertently broken older ones.</p>
<hr />
<p>TypeScript can be used with any JavaScript testing framework that you want. In the worst case you can always do a simple <code>TypeScript -&gt; JavaScript</code> transform and go your merry way. </p>
<p>That said, in this section look at options that we have enjoyed greatly 🌹</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-jest-with-typescript"><a class="header" href="#using-jest-with-typescript">Using Jest with TypeScript</a></h1>
<p>Jest is a simple-to-configure and powerful JavaScript unit testing framework that is built on top of the popular Jasmine framework.</p>
<blockquote>
<p><a href="https://egghead.io/lessons/typescript-getting-started-with-jest-using-typescript">Pro egghead lesson on Jest / TypeScript</a></p>
</blockquote>
<p>No testing solution out there is perfect. That said, jest is an excellent unit testing option which provides great TypeScript support.</p>
<blockquote>
<p>Note: We assume you start off with a simple node package.json setup. Also all TypeScript files should be in a <code>src</code> folder which is always recommended (even without Jest) for a clean project setup.</p>
</blockquote>
<h2 id="step-1-install"><a class="header" href="#step-1-install">Step 1: Install</a></h2>
<p>Install the following using npm:</p>
<pre><code class="language-bash">npm install jest --save-dev
#npm i jest @types/jest ts-jest typescript -D
pnpm install ts-jest --save-dev
pnpm ts-jest config:init
pnpm install typescript --save-dev
</code></pre>
<p>Explanation:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Install <code>jest</code> framework (<code>jest</code>)</li>
<li><input disabled="" type="checkbox" checked=""/>
Install the types for <code>jest</code> (<code>@types/jest</code>)</li>
<li><input disabled="" type="checkbox" checked=""/>
Install the TypeScript preprocessor for jest (<code>ts-jest</code>) which allows jest to transpile TypeScript on the fly and have source-map support built in.</li>
<li><input disabled="" type="checkbox" checked=""/>
Install the TypeScript compiler (‘typescript’) which is prerequisite for ‘ts-jest’.</li>
<li><input disabled="" type="checkbox" checked=""/>
Save all of these to your dev dependencies (testing is almost always a npm dev-dependency)</li>
</ul>
<h2 id="step-2-configure-jest"><a class="header" href="#step-2-configure-jest">Step 2: Configure Jest</a></h2>
<p>Add the following <code>jest.config.js</code> file to the root of your project:</p>
<pre><code class="language-js">module.exports = {
  &quot;roots&quot;: [
    &quot;&lt;rootDir&gt;/src&quot;
  ],
  &quot;testMatch&quot;: [
    &quot;**/__tests__/**/*.+(ts|tsx|js)&quot;,
    &quot;**/?(*.)+(spec|test).+(ts|tsx|js)&quot;
  ],
  &quot;transform&quot;: {
    &quot;^.+\\.(ts|tsx)$&quot;: &quot;ts-jest&quot;
  },
}
</code></pre>
<p>Note: There are also a number of keyboard shortcuts available to run a subset of tests.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Hitting the “f” key will run only failed tests.</li>
<li><input disabled="" type="checkbox" checked=""/>
Hitting the “o” key will only run tests related to changed files.</li>
<li><input disabled="" type="checkbox" checked=""/>
The “p” and “t” options allow for filtering tests based on regex patterns.</li>
</ul>
<p>(If your <code>package.json</code> file contains <code>&quot;type&quot;: &quot;module&quot;</code>, which causes Node to assume modules are in es6 format, you can convert the above to es6 format by replacing the top line to <code>export default { </code> .)</p>
<p>Explanation:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
We always recommend having <em>all</em> TypeScript files in a <code>src</code> folder in your project. We assume this is true and specify this using the <code>roots</code> option.</li>
<li><input disabled="" type="checkbox" checked=""/>
The <code>testMatch</code> config is a glob pattern matcher for discovering .test / .spec files in ts / tsx / js format.</li>
<li><input disabled="" type="checkbox" checked=""/>
The <code>transform</code> config just tells <code>jest</code> to use <code>ts-jest</code> for ts / tsx files.</li>
</ul>
<h2 id="step-3-run-tests"><a class="header" href="#step-3-run-tests">Step 3: Run tests</a></h2>
<p>Run <code>pnpm jest</code> from your project root and jest will execute any tests you have.</p>
<h3 id="optional-add-script-target-for-npm-scripts"><a class="header" href="#optional-add-script-target-for-npm-scripts">Optional: Add script target for npm scripts</a></h3>
<p>Add <code>package.json</code>:</p>
<pre><code class="language-json">{
  &quot;test&quot;: &quot;jest&quot;
}
</code></pre>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
This allows you to run the tests with a simple <code>npm t</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
And even in watch mode with <code>npm t -- --watch</code>.</li>
</ul>
<h3 id="optional-run-jest-in-watch-mode"><a class="header" href="#optional-run-jest-in-watch-mode">Optional: Run jest in watch mode</a></h3>
<p><code>pnpm jest --watch</code></p>
<h3 id="ts-jest"><a class="header" href="#ts-jest">ts-jest</a></h3>
<p>ts-jest is a TypeScript to Jest bridge and will take care of the compilation step and integration with Jest for us.
In fact, ts-jest will compile and execute our TypeScript tests without even generating JavaScript files. This means that we can write unit tests in TypeScript, and ts-jest will run them within Jest seamlessly.</p>
<pre><code class="language-bash">pnpm install --save-dev jest typescript ts-jest @types/jest
pnpm ts-jest config:init
</code></pre>
<p>add <code>preset: &quot;ts-jest&quot;</code> to jest.config.js file.</p>
<h3 id="grouping-tests"><a class="header" href="#grouping-tests">Grouping tests</a></h3>
<p>Within a test specification file, we may want to group our tests into logical sets. Jest uses the function <strong>describe</strong> for this purpose.
<code>it</code> is a function containing the <strong>set of tests</strong>.</p>
<h3 id="force-test"><a class="header" href="#force-test">Force Test</a></h3>
<p>Using the it function (Jasmine default) instead of the test function (Jest default) for tests means that we only have to prefix an it test with the letter <code>f</code> in order to force it, that is, fit versus it. This is quite a time saver, instead of having to type test.only to force a test instead of the normal test.
<code>fdescribe</code> used to force a group of tests.</p>
<h3 id="skipping-tests"><a class="header" href="#skipping-tests">Skipping tests</a></h3>
<p>The opposite of forcing tests is to skip tests. To skip a test, we can prefix the test with the letter x so it becomes <code>xit</code>.
Skipping tests just because they are failing is the antithesis of test-driven development and should be avoided at all costs.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<ul>
<li>For a file <code>foo.ts</code>:</li>
</ul>
<pre><code class="language-js">export const sum
  = (...a: number[]) =&gt;
    a.reduce((acc, val) =&gt; acc + val, 0);
</code></pre>
<p>A simple <code>foo.test.ts</code>:</p>
<pre><code class="language-js">import { sum } from '../foo';

test('basic', () =&gt; {
  expect(sum()).toBe(0);
});

test('basic again', () =&gt; {
  expect(sum(1, 2)).toBe(3);
});
</code></pre>
<p>Notes:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Jest provides the global <code>test</code> function.</li>
<li><input disabled="" type="checkbox" checked=""/>
Jest comes prebuilt with assertions in the form of the global <code>expect</code>.</li>
</ul>
<h3 id="test-setup-and-teardown"><a class="header" href="#test-setup-and-teardown">Test setup and teardown</a></h3>
<p>The beforeEach function is being called before each of these tests, and it resets the value of the count property back to 0 every time.</p>
<pre><code class="language-ts">/// test setup and teardown
class GlobalCounter {
    count: number = 0;
    increment(): void {
      this.count++;
    }
   }
describe(&quot;test setup and teardown&quot;, () =&gt; {
  
    let globalCounter: GlobalCounter;
    beforeAll(() =&gt; {
      globalCounter = new GlobalCounter();
    });
    
    beforeEach(() =&gt; {
      globalCounter.count = 0;
    });
    
    afterEach(() =&gt; {
      console.log(`globalCounter.count =
      ${globalCounter.count}`);
    });
  
    it(&quot;should increment&quot;, () =&gt; {
        globalCounter.increment();
        expect(globalCounter.count).toEqual(1);
    });

    it(&quot;should increment twice&quot;, () =&gt; {
        globalCounter.increment();
        globalCounter.increment();
        expect(globalCounter.count).toEqual(2);
    });
  });
  
</code></pre>
<h2 id="data-driven-test"><a class="header" href="#data-driven-test">Data-Driven Test</a></h2>
<p>To use data-driven tests in TypeScript to run the same test multiple times with different input values. Data-driven tests are a convenient way of writing unit tests where the only real change to a series of tests is either an input or a resulting value, but the body of the test itself remains the same.
Data-driven tests dosen’t check the database integration of an application.</p>
<pre><code class="language-ts">function testUsing&lt;T&gt;
    (values: T[], func: Function) {
    for (let value of values) {
        func.apply(Object, [value]);
    }
}
//....
</code></pre>
<h3 id="jest-mocks-and-spies"><a class="header" href="#jest-mocks-and-spies">Jest Mocks and Spies</a></h3>
<p>To use Jest mocks and spies to test that functions are called with the <strong>correct arguments.</strong>
When writing a test for our initialize function, we would want to ensure that all of the calls to REST services were called. <strong>To ensure that functions are called, we use Jest mocks or Jest spies.</strong></p>
<pre><code class="language-ts">//...
it(&quot;should call testFunction with argument using mock&quot;, () =&gt; {
  let mock = jest.fn();
  
  let myCallbackClass = new MyCallbackClass();
  myCallbackClass.executeCallback(&quot;argument_1&quot;, mock);
  expect(mock).toHaveBeenCalledWith(&quot;argument_1&quot;);
});
</code></pre>
<p>Spy:</p>
<pre><code class="language-ts">//...
it(&quot;should call testSpiedFunction&quot;, () =&gt; {
  let mySpiedClass = new MySpiedClass();
  const testFunctionSpy = jest.spyOn(mySpiedClass, &quot;testSpiedFunction&quot;);
  mySpiedClass.testFunction();
  expect(testFunctionSpy).toHaveBeenCalled();
});
</code></pre>
<p>Spy Sample two:</p>
<p>Here, we have used the mockImplementation function on our spy to provide an implementation of the function that will be called during the test. This mock implementation will log a message to the console showing that it will be called instead of the class method.</p>
<p>When we run the test, we can see that the mock implementation of the testFunction method was invoked instead of the actual implementation of the testFunction method.
If we want to override the body of the method and not allow the body of the method to be invoked, then we need to provide a mock implementation.</p>
<p>This distinction of whether or not the body of the method is invoked is extremely important when writing tests. As an example, let’s assume that a method will connect to a database, run a query, and return results. In this instance, we do not want the body of the method to be run, as we do not have a database instance to connect to. We want to mock out any interactions with a database completely. In these cases, we will need to provide a mock implementation.</p>
<pre><code class="language-ts">it(&quot;should call mock of testFunction&quot;, () =&gt; {
    let mySpiedClass = new MySpiedClass();
    const testFunctionSpy = jest.spyOn(
    mySpiedClass, 'testFunction')
    .mockImplementation(() =&gt; {
    console.log(`mockImplementation called`);
    });
    mySpiedClass.testFunction();
    expect(testFunctionSpy).toHaveBeenCalled();
   });
</code></pre>
<p>Returning values(Ref.To example test_ex15.spec.ts) from mock implementations means that we can simulate any sort of external interaction with other systems within our tests. We can mock out calls to a database or calls to a REST endpoint and inject standard values that we can test against.</p>
<h4 id="jest-writing-a-parameterized-test"><a class="header" href="#jest-writing-a-parameterized-test">Jest Writing a parameterized test</a></h4>
<pre><code class="language-ts">function squared(input: number): number {
    return input * input;
}

describe('this is our test suite', () =&gt; {
    [1, 5, 10, 100].forEach(num =&gt;
        it(`should multiply ${num}`, () =&gt; {
            const result = squared(num);

            expect(result).toEqual(num * num);
        }));
});
</code></pre>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-based testing</a></h3>
<pre><code class="language-ts">import * as fc from 'fast-check'
function product(first: number, second: number) {
    return first * second;
}

describe('product tests', () =&gt; {
    it('should multiply the given numbers', () =&gt; {
        const randomFirst: fc.Arbitrary&lt;number&gt; = fc.integer(); 
        const randomSecond: fc.Arbitrary&lt;number&gt; = fc.integer(); 

        fc.assert(
            fc.property(randomFirst, randomSecond, (first, second) =&gt; {
                const result = product(first, second);
                
                expect(result).toBe(first * second);
            })
        ); 
    });
});

</code></pre>
<h3 id="example-async"><a class="header" href="#example-async">Example async</a></h3>
<p>This often presents problems in our unit testing, where we need to wait for an asynchronous event to complete before we can continue with our test.</p>
<pre><code class="language-ts">class MockAsync {
  executeSlowFunction(complete: (value: string) =&gt; void) {
    setTimeout(() =&gt; {
      complete(`completed`);
    }, 1000);
  }
}
describe(&quot;failing async tests&quot;, () =&gt; {
  it(&quot;should wait for callback to complete&quot;, () =&gt; {
    let mockAsync = new MockAsync();
    console.log(`1. calling executeSlowFunction`);
    let returnedValue!: string;
    mockAsync.executeSlowFunction((value: string) =&gt; {
      console.log(`2. complete called`);
      returnedValue = value;
    });
    console.log(`3. checking return value`);
    expect(returnedValue).toBe(&quot;completed&quot;);
  });
});

</code></pre>
<p><code>&gt; Output:</code></p>
<pre><code class="language-ts">failing async tests › should wait for callback to complete
</code></pre>
<p>Our test is also failing, as the expected value of the returnedValue variable should be “completed”, but is, in fact, undefined.</p>
<p>What is causing this test to fail is the fact that the test itself is not waiting for 1 second for the executeSlowFunction function to call the complete callback. What we really need is a way to signal to our test that it should only execute the test expectation once the asynchronous call has completed.</p>
<p>The <strong>done function</strong> can be passed in as an argument in any beforeAll, beforeEach, or it function and will allow our <em>asynchronous test to wait for the done function to be called before continuing.</em></p>
<p>Next Example:
Jest has built-in async/await support. e.g.</p>
<pre><code class="language-js">test('basic',async () =&gt; {
  expect(sum()).toBe(0);
});

test('basic again', async () =&gt; {
  expect(sum(1, 2)).toBe(3);
}, 1000 /* optional timeout */);
</code></pre>
<p>Next Example:</p>
<pre><code class="language-ts">class AsyncWithPromise {
  delayedPromise(): Promise&lt;string&gt; {
    return new Promise&lt;string&gt;(
      (resolve: (str: string) =&gt; void, reject: (str: string) =&gt; void) =&gt; {
        setTimeout(() =&gt; {
          console.log(`2. returning success`);
          resolve(&quot;success&quot;);
        }, 1000);
      }
    );
  }
}
describe(&quot;async test&quot;, () =&gt; {
  it(&quot;should wait 1 second for promise to resolve&quot;, async () =&gt; {
    let asyncWithPromise = new AsyncWithPromise();
    console.log(`1. calling delayedPromise`);
    let returnValue = await asyncWithPromise.delayedPromise();
    console.log(`3. after await`);
    expect(returnValue).toEqual(&quot;success&quot;);
  });
});

</code></pre>
<h3 id="example-enzyme"><a class="header" href="#example-enzyme">Example enzyme</a></h3>
<blockquote>
<p><a href="https://egghead.io/lessons/react-test-react-components-and-dom-using-enzyme">Pro egghead lesson on Enzyme / Jest / TypeScript</a></p>
</blockquote>
<p>Enzyme allows you to test react components with dom support. There are three steps to setting up enzyme:</p>
<ol>
<li>Install enzyme, types for enzyme, a better snapshot serializer for enzyme, enzyme-adapter-react for your react version <code>npm i enzyme @types/enzyme enzyme-to-json enzyme-adapter-react-16 -D</code></li>
<li>Add <code>&quot;snapshotSerializers&quot;</code> and <code>&quot;setupTestFrameworkScriptFile&quot;</code> to your <code>jest.config.js</code>:</li>
</ol>
<pre><code class="language-js">module.exports = {
  // OTHER PORTIONS AS MENTIONED BEFORE

  // Setup Enzyme
  &quot;snapshotSerializers&quot;: [&quot;enzyme-to-json/serializer&quot;],
  &quot;setupFilesAfterEnv&quot;: [&quot;&lt;rootDir&gt;/src/setupEnzyme.ts&quot;],
}
</code></pre>
<ol start="3">
<li>Create <code>src/setupEnzyme.ts</code> file.</li>
</ol>
<pre><code class="language-js">import { configure } from 'enzyme';
import EnzymeAdapter from 'enzyme-adapter-react-16';
configure({ adapter: new EnzymeAdapter() });
</code></pre>
<p>Now here is an example react component and test:</p>
<ul>
<li><code>checkboxWithLabel.tsx</code>:</li>
</ul>
<pre><code class="language-typescript">import * as React from 'react';

export class CheckboxWithLabel extends React.Component&lt;{
  labelOn: string,
  labelOff: string
}, {
    isChecked: boolean
  }&gt; {
  constructor(props) {
    super(props);
    this.state = { isChecked: false };
  }

  onChange = () =&gt; {
    this.setState({ isChecked: !this.state.isChecked });
  }

  render() {
    return (
      &lt;label&gt;
        &lt;input
          type=&quot;checkbox&quot;
          checked={this.state.isChecked}
          onChange={this.onChange}
        /&gt;
        {this.state.isChecked ? this.props.labelOn : this.props.labelOff}
      &lt;/label&gt;
    );
  }
}

</code></pre>
<ul>
<li><code>checkboxWithLabel.test.tsx</code>:</li>
</ul>
<pre><code class="language-typescript">import * as React from 'react';
import { shallow } from 'enzyme';
import { CheckboxWithLabel } from './checkboxWithLabel';

test('CheckboxWithLabel changes the text after click', () =&gt; {
  const checkbox = shallow(&lt;CheckboxWithLabel labelOn=&quot;On&quot; labelOff=&quot;Off&quot; /&gt;);

  // Interaction demo
  expect(checkbox.text()).toEqual('Off');
  checkbox.find('input').simulate('change');
  expect(checkbox.text()).toEqual('On');

  // Snapshot demo
  expect(checkbox).toMatchSnapshot();
});
</code></pre>
<h2 id="jsdom-library"><a class="header" href="#jsdom-library">jsdom Library</a></h2>
<p>Jest uses a library named jsdom to allow for testing HTML elements and interactions. The jsdom is not an actual browser; it is a library that implements the JavaScript DOM API, and can, therefore, simulate a full-blown browser experience. The benefit of using jsdom is in the speed at which we can run our tests and the fact that we do not have to provide an environment that can run a full browser.</p>
<pre><code class="language-bash">pnpm install jsdom --save-dev
pnpm install @types/jsdom --save-dev
pnpm install jquery
pnpm install @types/jquery --save-dev
</code></pre>
<h3 id="checking-dom-updates"><a class="header" href="#checking-dom-updates">Checking DOM updates</a></h3>
<p>With jsdom and jquery installed, we can write a test that checks whether the DOM has been updated. Consider the following code:</p>
<pre><code class="language-ts">function setTestDiv(text: string) {
  $(&quot;#test_div&quot;).html(`&lt;p&gt;${text}&lt;/p&gt;`);
}
</code></pre>
<p>Test function with jsdom and jQuery</p>
<pre><code class="language-ts">it(&quot;should set text on div&quot;, () =&gt; {
  document.body.innerHTML = `&lt;div id=&quot;test_div&quot;&gt;&lt;/div&gt;`;
  let htmlElement = $(&quot;#test_div&quot;);
  expect(htmlElement.length).toBeGreaterThan(0);
  setTestDiv(&quot;Hello World&quot;);
  expect(htmlElement.html()).toContain(&quot;Hello World&quot;);
});
</code></pre>
<p>We can use this sort of technique for other DOM events, including onchange, onfocus, ondrag, or anything else. Having the ability to construct snippets of HTML and test them is a very powerful feature of Jest and jsdom. We can fill in forms, click on the “submit”, “cancel”, or “OK” buttons, and generally simulate user interaction with our application.</p>
<h2 id="reasons-why-we-like-jest"><a class="header" href="#reasons-why-we-like-jest">Reasons why we like jest</a></h2>
<blockquote>
<p><a href="http://facebook.github.io/jest/">For details on these features see jest website</a></p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Built-in assertion library.</li>
<li><input disabled="" type="checkbox" checked=""/>
Great TypeScript support.</li>
<li><input disabled="" type="checkbox" checked=""/>
Very reliable test watcher.</li>
<li><input disabled="" type="checkbox" checked=""/>
Snapshot testing.</li>
<li><input disabled="" type="checkbox" checked=""/>
Built-in coverage reports.</li>
<li><input disabled="" type="checkbox" checked=""/>
Built-in async/await support.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-cypress"><a class="header" href="#why-cypress">Why Cypress</a></h1>
<p>Cypress is a great E2E testing tool. Here are a few great reasons to consider it:</p>
<ul>
<li>Isolated installation possible.</li>
<li>Ships with TypeScript support out of the box.</li>
<li>Provides a nice interactive google chrome debug experience. This is very similar to how UI devs mostly work manually.</li>
<li>Has command - execution separation which allows for more powerful debugging and test stability (more on this below).</li>
<li>Has implicit assertions to provide more meaningful debug experience with less brittle tests (more on this in the tips below).</li>
<li>Provides the ability to mock out and observe backend XHRs easily without changing your application code (more on this in the tips below).</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>The steps provided in this installation process will give you a nice <code>e2e</code> folder that you can copy/paste or as boiler plate for your organization.</p>
<blockquote>
<p>Same steps presented in a video format over at my <a href="https://www.youtube.com/watch?v=n3SvvZSWwfM">youtube channel</a>.</p>
</blockquote>
<p>Create an e2e directory, install cypress, TypeScript and setup the typescript and cypress config files:</p>
<pre><code class="language-sh">mkdir e2e
cd e2e
npm init -y
npm install cypress typescript
npx tsc --init --types cypress --lib dom,es6
echo {} &gt; cypress.json 
</code></pre>
<blockquote>
<p>Here are a few reasons for creating a separate <code>e2e</code> folder especially for cypress:</p>
</blockquote>
<ul>
<li>Creating a separate directory or <code>e2e</code> makes it easier to isolate its <code>package.json</code> dependencies from the rest of your project. This results in less dependency conflicts.</li>
<li>Testing frameworks have a habit of polluting the global namespace with stuff like <code>describe</code> <code>it</code> <code>expect</code>. It is best to keep the e2e <code>tsconfig.json</code> and <code>node_modules</code> in this special <code>e2e</code> folder to prevent global type definition conflicts.</li>
</ul>
<p>Add a few scripts to the <code>e2e/package.json</code> file:</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    &quot;cypress:open&quot;: &quot;cypress open&quot;,
    &quot;cypress:run&quot;: &quot;cypress run&quot;
  },
</code></pre>
<p>Write your first test under <code>cypress/integration/basic.ts</code>: </p>
<pre><code class="language-typescript">it('should perform basic google search', () =&gt; {
  cy.visit('https://google.com');
  cy.get('[name=&quot;q&quot;]')
    .type('subscribe')
    .type('{enter}');
});
</code></pre>
<p>Now run <code>npm run cypress:open</code> during development and <code>npm run cypress:run</code> on your build server 🌹</p>
<h2 id="more-description-of-key-files"><a class="header" href="#more-description-of-key-files">More description of key Files</a></h2>
<p>Under the <code>e2e</code> folder you now have these files:</p>
<ul>
<li><code>/cypress.json</code>: Configure cypress. The default is empty and that is all you need.</li>
<li><code>/cypress</code> Subfolders:
<ul>
<li><code>/integration</code>: All your tests.
<ul>
<li>Feel free to create tests under subfolders for better organization e.g. <code>/someFeatureFolder/something.spec.ts</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="first-test"><a class="header" href="#first-test">First test</a></h2>
<ul>
<li>create a file <code>/cypress/integration/first.ts</code> with the following contents:</li>
</ul>
<pre><code class="language-typescript">describe('google search', () =&gt; {
  it('should work', () =&gt; {
    cy.visit('http://www.google.com');
    cy.get('#lst-ib').type('Hello world{enter}')
  });
});
</code></pre>
<h2 id="running-in-development"><a class="header" href="#running-in-development">Running in development</a></h2>
<p>Open the cypress IDE using the following command.</p>
<pre><code class="language-sh">npm run cypress:open
</code></pre>
<p>And select a test to run.</p>
<h2 id="running-on-a-build-server"><a class="header" href="#running-on-a-build-server">Running on a build server</a></h2>
<p>You can run cypress tests in ci mode using the following command.</p>
<pre><code class="language-sh">npm run cypress:run
</code></pre>
<h2 id="tip-sharing-code-between-ui-and-test"><a class="header" href="#tip-sharing-code-between-ui-and-test">Tip: Sharing code between UI and test</a></h2>
<p>Cypress tests are compiled / packed and run in the browser. So feel free to import any project code into your test.</p>
<p>For example you can share Id values between UI and Tests to make sure the CSS selectors don’t break:</p>
<pre><code class="language-js">import { Ids } from '../../../src/app/constants';

// Later
cy.get(`#${Ids.username}`)
  .type('john')
</code></pre>
<h2 id="tip-creating-page-objects"><a class="header" href="#tip-creating-page-objects">Tip: Creating Page Objects</a></h2>
<p>Creating objects that provide a convenient handle for all the interactions that various tests need to do with a page is a common testing convention. You can create page objects using TypeScript classes with getters and methods e.g.</p>
<pre><code class="language-js">import { Ids } from '../../../src/app/constants';

class LoginPage {
  visit() {
    cy.visit('/login');
  }

  get username() {
    return cy.get(`#${Ids.username}`);
  }
}
const page = new LoginPage();

// Later
page.visit();

page.username.type('john');

</code></pre>
<h2 id="tip-explicit-assertion"><a class="header" href="#tip-explicit-assertion">Tip: Explicit assertion</a></h2>
<p>Cypress ships with (built in) chai and chai-query assertion libraries to help testing webpages. You use them with <code>.should</code> command passing in the chainer as a string, replacing <code>.to.foo</code> with <code>should('foo')</code> e.g. with chai-jquery you would <code>expect($(#foo)).to.have.text('something')</code>, with cypress you would <code>cy.get('#foo').should('have.text', 'something')</code>:</p>
<pre><code>cy.get('#foo')
  .should('have.text', 'something')
</code></pre>
<blockquote>
<p>You get intellisense for <code>should</code> chainers as cypress ships with correct TypeScript definitions 👍🏻</p>
</blockquote>
<p>The complete list of chainers is available here : https://docs.cypress.io/guides/references/assertions.html</p>
<p>If you want something complex you can even use <code>should(callback)</code> and e.g.</p>
<pre><code>cy.get('div')
  .should(($div) =&gt; {
    expect($div).to.have.length(1);
    expect($div[0].className).to.contain('heading');
  })
// This is just an example. Normally you would `.should('have.class', 'heading')
</code></pre>
<blockquote>
<p>TIP: cypress with do automatic retries on the callback as well, so they are just as flake free as standard string chainers.</p>
</blockquote>
<h2 id="tip-commands-and-chaining"><a class="header" href="#tip-commands-and-chaining">Tip: Commands and Chaining</a></h2>
<p>Every function call in a cypress chain is a <code>command</code>. The <code>should</code> command is an assertion. It is conventional to start distinct <em>category</em> of chains and actions separately e.g.</p>
<pre><code class="language-typescript">// Don't do this
cy.get(/**something*/)
  .should(/**something*/)
  .click()
  .should(/**something*/)
  .get(/**something else*/)
  .should(/**something*/)

// Prefer separating the two gets
cy.get(/**something*/)
  .should(/**something*/)
  .click()
  .should(/**something*/)

cy.get(/**something else*/)
  .should(/**something*/)
</code></pre>
<p>Some other libraries <em>evaluate and run</em> the code at the same time. Those libraries force you to have a single chain which can be nightmare to debug with selectors and assertions mingled in.</p>
<p>Cypress commands are essentially <em>declarations</em> to the cypress runtime to execute the commands later. Simple words: Cypress makes it easier.</p>
<h2 id="tip-using-contains-for-easier-querying"><a class="header" href="#tip-using-contains-for-easier-querying">Tip: Using <code>contains</code> for easier querying</a></h2>
<p>The following shows an example:</p>
<pre><code>cy.get('#foo')
  // Once #foo is found the following:
  .contains('Submit')
  .click()
  // ^ will continue to search for something that has text `Submit` and fail if it times out.
  // ^ After it is found trigger a click on the HTML Node that contained the text `Submit`.
</code></pre>
<h2 id="tip-smart-delays-and-retries"><a class="header" href="#tip-smart-delays-and-retries">Tip: Smart delays and retries</a></h2>
<p>Cypress will automatically wait (and retry) for many async things e.g.</p>
<pre><code>// If there is no request against the `foo` alias cypress will wait for 4 seconds automatically
cy.wait('@foo')
// If there is no element with id #foo cypress will wait for 4 seconds automatically and keep retrying
cy.get('#foo')
</code></pre>
<p>This keeps you from having to constantly add arbitrary timeout (and retry) logic in your test code flow.</p>
<h2 id="tip-implicit-assertion"><a class="header" href="#tip-implicit-assertion">Tip: Implicit assertion</a></h2>
<p>Cypress has a concept of implicit assertion. These kick in if a future command is erroring because of a previous command. E.g. the following will error at <code>contains</code> (after automatic retries of course) as nothing found can get <code>click</code>ed:</p>
<pre><code class="language-typescript">cy.get('#foo')
  // Once #foo is found the following:
  .contains('Submit')
  .click()
  // ^ Error: #foo does not have anything that `contains` `'Submit'`
</code></pre>
<p>In traditional frameworks you would get a horrible error like <code>click</code> doesn’t exist on <code>null</code>. In Cypress you get a nice error <code>#foo</code> does not contain <code>Submit</code>. This error is a form of an implicit assertion.</p>
<h2 id="tip-waiting-for-an-http-request"><a class="header" href="#tip-waiting-for-an-http-request">Tip: Waiting for an HTTP request</a></h2>
<p>A lot of tests have been traditionally brittle due to all the arbitrary timeouts needed for XHRs that an application makes. <code>cy.server</code> makes it easy to</p>
<ul>
<li>create an alias for backend calls</li>
<li>wait for them to occur</li>
</ul>
<p>e.g.</p>
<pre><code class="language-typescript">cy.server()
  .route('POST', 'https://example.com/api/application/load')
  .as('load') // create an alias

// Start test
cy.visit('/')

// wait for the call
cy.wait('@load')

// Now the data is loaded
</code></pre>
<h2 id="tip-mocking-an-http-request-response"><a class="header" href="#tip-mocking-an-http-request-response">Tip: Mocking an HTTP request response</a></h2>
<p>You can also easily mock out a request response using <code>route</code>:</p>
<pre><code class="language-typescript">cy.server()
  .route('POST', 'https://example.com/api/application/load', /* Example payload response */{success:true});
</code></pre>
<h3 id="tip-asserting-an-http-request-response"><a class="header" href="#tip-asserting-an-http-request-response">Tip: Asserting an Http request response</a></h3>
<p>You can assert requests without mocking using <code>route</code> <code>onRequest</code> / <code>onResponse</code> e.g.</p>
<pre><code class="language-typescript">cy.route({
  method: 'POST',
  url: 'https://example.com/api/application/load',
  onRequest: (xhr) =&gt; {
    // Example assertion
    expect(xhr.request.body.data).to.deep.equal({success:true});
  }
})
</code></pre>
<h2 id="tip-mocking-time"><a class="header" href="#tip-mocking-time">Tip: Mocking time</a></h2>
<p>You can use <code>wait</code> to pause a test for some time e.g. to test an automatic “you are about to be logged out” notification screen:</p>
<pre><code class="language-typescript">cy.visit('/');
cy.wait(waitMilliseconds);
cy.get('#logoutNotification').should('be.visible');
</code></pre>
<p>However, it is recommended to mock time using <code>cy.clock</code> and forwarding time using <code>cy.tick</code> e.g.</p>
<pre><code class="language-typescript">cy.clock();

cy.visit('/');
cy.tick(waitMilliseconds);
cy.get('#logoutNotification').should('be.visible');
</code></pre>
<h2 id="tip-unit-testing-application-code"><a class="header" href="#tip-unit-testing-application-code">Tip: Unit testing application code</a></h2>
<p>You can also use cypress to unit test your application code in isolation e.g.</p>
<pre><code class="language-js">import { once } from '../../../src/app/utils';

// Later
it('should only call function once', () =&gt; {
  let called = 0;
  const callMe = once(()=&gt;called++);
  callMe();
  callMe();
  expect(called).to.equal(1);
});
</code></pre>
<h2 id="tip-mocking-in-unit-testing"><a class="header" href="#tip-mocking-in-unit-testing">Tip: Mocking in unit testing</a></h2>
<p>If you are unit testing modules in your application you can provide mocks using <code>cy.stub</code> e.g. if you want to ensure that <code>navigate</code> is called in a function <code>foo</code>:</p>
<ul>
<li><code>foo.ts</code></li>
</ul>
<pre><code class="language-typescript">import { navigate } from 'takeme';

export function foo() {
  navigate('/foo');
}
</code></pre>
<ul>
<li>You can do this as in <code>some.spec.ts</code>:</li>
</ul>
<pre><code class="language-typescript">/// &lt;reference types=&quot;cypress&quot;/&gt;

import { foo } from '../../../src/app/foo';
import * as takeme from 'takeme';

describe('should work', () =&gt; {
  it('should stub it', () =&gt; {
    cy.stub(takeme, 'navigate');
    foo();
    expect(takeme.navigate).to.have.been.calledWith('/foo');
  });
});
</code></pre>
<h2 id="tip-command---execution-separation"><a class="header" href="#tip-command---execution-separation">Tip: Command - execution separation</a></h2>
<p>When you invoke a cypress command (or assertion) e.g. <code>cy.get('#something')</code>, the function immediately returns without actually carrying out the action. What it does do, is informs the cypress test runner that you will need to carry out (execute) an action (in this case a <code>get</code>) at some point.</p>
<p>You are basically building a command list that the runner will then go ahead and execute. You can verify this command - execution separation with a simple test, observe that you will see the <code>start / between / end</code> <code>console.log</code> statements execute immediately before the runner starts <em>executing</em> the commands:</p>
<pre><code class="language-typescript">/// &lt;reference types=&quot;cypress&quot;/&gt;

describe('Hello world', () =&gt; {
  it('demonstrate command - execution separation', () =&gt; {
    console.log('start');
    cy.visit('http://www.google.com');
    console.log('between');
    cy.get('.gLFyf').type('Hello world');
    console.log('end');
  });
});
</code></pre>
<p>This command execution separation has two big benefits:</p>
<ul>
<li>The runner can execute the commands in a <em>flake resistant</em> manner with automatic retries and implicit assertions.</li>
<li>Allows you to write asynchronous code in a synchronous fashion without having to do a constant <em>chaining</em> which results in difficult to maintain code.</li>
</ul>
<h2 id="tip-breakpoint"><a class="header" href="#tip-breakpoint">Tip: Breakpoint</a></h2>
<p>The automatic snapshots + command log generated by the cypress test are great for debugging. That said you can pause test execution if you want.</p>
<p>First make sure you have chrome developer tools (lovingly called dev tools) open in the test runner (<code>CMD + ALT + i</code> on mac / <code>F12</code> on windows). Once the dev tools are open you can re-run the test and the dev tools will stay open. If you have the dev tools open, you can pause test execution in two ways:</p>
<ul>
<li>Application code breakpoints: Use a <code>debugger</code> statement in your application code and the test runner will stop on that just like standard web development.</li>
<li>Test code breakpoints: You can use the <code>.debug()</code> command and cypress test execution will stop at it. Alternatively you can use a <code>debugger</code> statement in a <code>.then</code> command callback to cause a pause. e.g <code>.then(() =&gt; { debugger })</code>. You can even use it to grab some element <code>cy.get('#foo').then(($ /* a reference to the dom element */) =&gt; { debugger; })</code> or a network call e.g. <code>cy.request('https://someurl').then((res /* network response */) =&gt; { debugger });</code>. However idiomatic way is <code>cy.get('#foo').debug()</code> and then when the test runner is paused on <code>debug</code> you can click on the <code>get</code> in the command log to automatically <code>console.log</code> any information you might need about the <code>.get('#foo')</code> command (and similarly for any other commands you want to debug).</li>
</ul>
<h2 id="tip-start-server-and-test"><a class="header" href="#tip-start-server-and-test">Tip: Start server and test</a></h2>
<p>If you need to start a local server before your tests can run you can add <code>start-server-and-test</code> https://github.com/bahmutov/start-server-and-test as a dependency. It takes the following arguments</p>
<ul>
<li>an npm script to <em>run</em> the server (aka server)</li>
<li>an endpoint to check if the server has booted up (aka start)</li>
<li>an npm script to initiate the testing (aka test)</li>
</ul>
<p>Example package.json:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;start-server&quot;: &quot;npm start&quot;,
        &quot;run-tests&quot;: &quot;mocha e2e-spec.js&quot;,
        &quot;ci&quot;: &quot;start-server-and-test start-server http://localhost:8080 run-tests&quot;
    }
}
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li>Website: https://www.cypress.io/</li>
<li>Write your first cypress test (gives a nice tour of the cypress IDE) : https://docs.cypress.io/guides/getting-started/writing-your-first-test.html</li>
<li>Setting up a CI environment (e.g. the provided docker image that works out of the box with <code>cypress run</code>): https://docs.cypress.io/guides/guides/continuous-integration.html</li>
<li>Recipes (Lists recipes with descriptions. Click on headings to navigate to the source code for the recipe): https://docs.cypress.io/examples/examples/recipes.html</li>
<li>Visual Testing : https://docs.cypress.io/guides/tooling/visual-testing.html</li>
<li>Optionally set a <code>baseUrl</code> in cypress.json to <a href="https://github.com/cypress-io/cypress/issues/2542">prevent an initial reload that happens after first <code>visit</code>.</a></li>
<li>Code coverage with cypress: <a href="https://www.youtube.com/watch?v=C8g5X4vCZJA">Webcast</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsx-support"><a class="header" href="#jsx-support">JSX Support</a></h1>
<p><a href="https://designtsx.com"><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/designtsx-banner.png" alt="DesignTSX" /></a></p>
<p>TypeScript supports JSX transpilation and code analysis. If you are unfamiliar with JSX here is an excerpt from the <a href="https://facebook.github.io/jsx/">official website</a>:</p>
<p>TypeScript extends the capabilities of JSX by providing type checking and static analysis. This decreases the chances of errors and increases the maintainability of your user interfaces.</p>
<p>To use JSX you need to set the <strong><code>jsx</code> compiler option</strong> in your <code>tsconfig.json</code> file. Two common configuration options:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
“preserve”: emit .jsx files with the JSX unchanged. This option tells TypeScript to <strong>keep the JSX syntax</strong> as-is and not transform it during the compilation process. You can use this option if you have a separate tool, like Babel, that handles the transformation.</li>
<li><input disabled="" type="checkbox" checked=""/>
“react”: <strong>enables TypeScript’s built-in JSX transformation</strong>. React.createElement will be used.</li>
</ul>
<p>All options are available here:
<a href="https://www.typescriptlang.org/tsconfig#jsx">https://www.typescriptlang.org/tsconfig#jsx</a></p>
<blockquote>
<p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers. It’s NOT a proposal to incorporate JSX into the ECMAScript spec itself. It’s intended to be used by various <strong>preprocessors (transpilers)</strong> to transform these tokens into standard ECMAScript.</p>
</blockquote>
<p>The motivation behind JSX is to allow users to write <strong>HTML like views in JavaScript</strong> so that you can, It is commonly used in React to define the HTML structure.
:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Have the view Type Checked by the same code that is going to check your JavaScript</li>
<li><input disabled="" type="checkbox" checked=""/>
Have the view be aware of the context it is going to operate under (i.e. strengthen the <em>controller-view</em> connection in traditional MVC).</li>
<li><input disabled="" type="checkbox" checked=""/>
Reuse JavaScript patterns for HTML maintenance e.g. <code>Array.prototype.map</code>, <code>?:</code>, <code>switch</code> etc instead of creating new (and probably poorly typed) alternatives.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-jsx"><a class="header" href="#react-jsx">React JSX</a></h1>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=7EW67MqgJvs&amp;list=PLYvdvJlnTOjHNayH7MukKbSJ6PueUNkkG">Free series of youtube videos on React / TypeScript best practices</a></p>
</blockquote>
<blockquote>
<p><a href="https://egghead.io/courses/use-typescript-to-develop-react-applications">PRO Egghead course on TypeScript and React</a></p>
</blockquote>
<p><a href="https://designtsx.com"><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/designtsx-banner.png" alt="DesignTSX" /></a></p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Our <a href="jsx/../quick/browser.html">browser quickstart already sets you up to develop react applications</a>. Here are the key highlights.</p>
<ul>
<li>Use files with the extension <code>.tsx</code> (instead of <code>.ts</code>).</li>
<li>Use <code>&quot;jsx&quot; : &quot;react&quot;</code> in your <code>tsconfig.json</code>’s <code>compilerOptions</code>.</li>
<li>Install the definitions for JSX and React into your project : (<code>npm i -D @types/react @types/react-dom</code>).</li>
<li>Import react into your <code>.tsx</code> files (<code>import * as React from &quot;react&quot;</code>).</li>
</ul>
<h2 id="html-tags-vs-components"><a class="header" href="#html-tags-vs-components">HTML Tags vs. Components</a></h2>
<p>React can either render HTML tags (strings) or React components. The JavaScript emit for these elements is different (<code>React.createElement('div')</code> vs. <code>React.createElement(MyComponent)</code>). The way this is determined is by the <em>case</em> of the <em>first</em> letter. <code>foo</code> is treated as an HTML tag and <code>Foo</code> is treated as a component.</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h2>
<h3 id="html-tags"><a class="header" href="#html-tags">HTML Tags</a></h3>
<p>An HTML Tag <code>foo</code> is to be of the type <code>JSX.IntrinsicElements.foo</code>. These types are already defined for all the major tags in a file <code>react-jsx.d.ts</code> which we had you install as a part of the setup. Here is a sample of the  the contents of the file:</p>
<pre><code class="language-typescript">declare module JSX {
    interface IntrinsicElements {
        a: React.HTMLAttributes;
        abbr: React.HTMLAttributes;
        div: React.HTMLAttributes;
        span: React.HTMLAttributes;

        /// so on ...
    }
}
</code></pre>
<h3 id="function-components"><a class="header" href="#function-components">Function Components</a></h3>
<p>You can define function components simply with the <code>React.FunctionComponent</code> interface e.g.</p>
<pre><code class="language-typescript">type Props = {
  foo: string;
}
const MyComponent: React.FunctionComponent&lt;Props&gt; = (props) =&gt; {
    return &lt;span&gt;{props.foo}&lt;/span&gt;
}

&lt;MyComponent foo=&quot;bar&quot; /&gt;
</code></pre>
<h3 id="void-function-components"><a class="header" href="#void-function-components">Void Function Components</a></h3>
<p>As of <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46643">@types/react PR #46643</a>, you can use a new <code>React.VoidFunctionComponent</code> or <code>React.VFC</code> type if you wish to declare that a component does not take <code>children</code>. This is an interim solution until the next major version of the type defs (where VoidFunctionComponent will be deprecated and FunctionComponent will by default accept no children).</p>
<pre><code class="language-typescript">type Props = { 
  foo: string 
}
// OK now, in future, error
const FunctionComponent: React.FunctionComponent&lt;Props&gt; = ({ foo, children }: Props) =&gt; {
    return &lt;div&gt;{foo} {children}&lt;/div&gt;; // OK
};
// Error now (children not support), in future, deprecated
const VoidFunctionComponent: React.VoidFunctionComponent&lt;Props&gt; = ({ foo, children }) =&gt; {
    return &lt;div&gt;{foo}{children}&lt;/div&gt;; 
};
</code></pre>
<h3 id="class-components"><a class="header" href="#class-components">Class Components</a></h3>
<p>Components are type checked based on the <code>props</code> property of the component. This is modeled after how JSX is transformed i.e. the attributes become the <code>props</code> of the component.</p>
<p>The <code>react.d.ts</code> file defines the <code>React.Component&lt;Props,State&gt;</code> class which you should extend in your own class providing your own <code>Props</code> and <code>State</code> interfaces. This is demonstrated below:</p>
<pre><code class="language-typescript">type Props = {
  foo: string;
}
class MyComponent extends React.Component&lt;Props, {}&gt; {
    render() {
        return &lt;span&gt;{this.props.foo}&lt;/span&gt;
    }
}

&lt;MyComponent foo=&quot;bar&quot; /&gt;
</code></pre>
<h3 id="react-jsx-tip-interface-for-renderable"><a class="header" href="#react-jsx-tip-interface-for-renderable">React JSX Tip: Interface for renderable</a></h3>
<p>React can render a few things like <code>JSX</code> or <code>string</code>. These are all consolidated into the type <code>React.ReactNode</code> so use it for when you want to accept renderables e.g.</p>
<pre><code class="language-typescript">type Props = {
  header: React.ReactNode;
  body: React.ReactNode;
}
class MyComponent extends React.Component&lt;Props, {}&gt; {
    render() {
        return &lt;div&gt;
            {this.props.header}
            {this.props.body}
        &lt;/div&gt;;
    }
}

&lt;MyComponent header={&lt;h1&gt;Header&lt;/h1&gt;} body={&lt;i&gt;body&lt;/i&gt;} /&gt;
</code></pre>
<h3 id="react-jsx-tip-accept-an-instance-of-a-component"><a class="header" href="#react-jsx-tip-accept-an-instance-of-a-component">React JSX Tip: Accept an instance of a Component</a></h3>
<p>The react type definitions provide <code>React.ReactElement&lt;T&gt;</code> to allow you to annotate the result of a <code>&lt;T/&gt;</code> class component instantiation. e.g.</p>
<pre><code class="language-js">class MyAwesomeComponent extends React.Component {
  render() {
    return &lt;div&gt;Hello&lt;/div&gt;;
  }
}

const foo: React.ReactElement&lt;MyAwesomeComponent&gt; = &lt;MyAwesomeComponent /&gt;; // Okay
const bar: React.ReactElement&lt;MyAwesomeComponent&gt; = &lt;NotMyAwesomeComponent /&gt;; // Error!
</code></pre>
<blockquote>
<p>Of course you can use this as a function argument annotation and even React component prop member.</p>
</blockquote>
<h3 id="react-jsx-tip-accept-a-component-that-can-act-on-props-and-be-rendered-using-jsx"><a class="header" href="#react-jsx-tip-accept-a-component-that-can-act-on-props-and-be-rendered-using-jsx">React JSX Tip: Accept a <em>component</em> that can act on props and be rendered using JSX</a></h3>
<p>The type <code>React.Component&lt;Props&gt;</code> consolidates <code>React.ComponentClass&lt;P&gt; | React.StatelessComponent&lt;P&gt;</code> so you can accept <em>something</em> that takes type <code>Props</code> and renders it using JSX e.g.</p>
<pre><code class="language-typescript">const X: React.Component&lt;Props&gt; = foo; // from somewhere

// Render X with some props:
&lt;X {...props}/&gt;;
</code></pre>
<h3 id="react-jsx-tip-generic-components"><a class="header" href="#react-jsx-tip-generic-components">React JSX Tip: Generic components</a></h3>
<p>It works exactly as expected. Here is an example:</p>
<pre><code class="language-typescript">/** A generic component */
type SelectProps&lt;T&gt; = { items: T[] }
class Select&lt;T&gt; extends React.Component&lt;SelectProps&lt;T&gt;, any&gt; { }

/** Usage */
const Form = () =&gt; &lt;Select&lt;string&gt; items={['a','b']} /&gt;;
</code></pre>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic functions</a></h3>
<p>Something like the following works fine:</p>
<pre><code class="language-typescript">function foo&lt;T&gt;(x: T): T { return x; }
</code></pre>
<p>However, using an arrow generic function will not:</p>
<pre><code class="language-typescript">const foo = &lt;T&gt;(x: T) =&gt; x; // ERROR : unclosed `T` tag
</code></pre>
<p><strong>Workaround</strong>: Use <code>extends</code> on the generic parameter to hint the compiler that it’s a generic, e.g.:</p>
<pre><code class="language-typescript">const foo = &lt;T extends unknown&gt;(x: T) =&gt; x;
</code></pre>
<h3 id="react-tip-strongly-typed-refs"><a class="header" href="#react-tip-strongly-typed-refs">React Tip: Strongly Typed Refs</a></h3>
<p>You basically initialize a variable as a union of the ref and <code>null</code> and then initialize it as as callback  e.g. </p>
<pre><code class="language-typescript">class Example extends React.Component {
  example() {
    // ... something
  }
  
  render() { return &lt;div&gt;Foo&lt;/div&gt; }
}


class Use {
  exampleRef: Example | null = null; 
  
  render() {
    return &lt;Example ref={exampleRef =&gt; this.exampleRef = exampleRef } /&gt;
  }
}
</code></pre>
<p>And the same with ref’s for native elements e.g. </p>
<pre><code class="language-typescript">class FocusingInput extends React.Component&lt;{ value: string, onChange: (value: string) =&gt; any }, {}&gt;{
  input: HTMLInputElement | null = null;
    
  render() {
    return (
      &lt;input
        ref={(input) =&gt; this.input = input}
        value={this.props.value}
        onChange={(e) =&gt; { this.props.onChange(e.target.value) } }
        /&gt;
      );
    }
    focus() {
      if (this.input != null) { this.input.focus() }
    }
}
</code></pre>
<h3 id="type-assertions"><a class="header" href="#type-assertions">Type Assertions</a></h3>
<p>Use <code>as Foo</code> syntax for type assertions as we <a href="jsx/../types/type-assertion.html#as-foo-vs-foo">mentioned before</a>.</p>
<h2 id="default-props"><a class="header" href="#default-props">Default Props</a></h2>
<ul>
<li>Stateful components with default props: You can tell TypeScript that a property will be provided externally (by React) by using a <em>null assertion</em> operator (this isn’t ideal but is the simplest minimum <em>extra code</em> solution I could think of).</li>
</ul>
<pre><code class="language-tsx">class Hello extends React.Component&lt;{
  /**
   * @default 'TypeScript'
   */
  compiler?: string,
  framework: string
}&gt; {
  static defaultProps = {
    compiler: 'TypeScript'
  }
  render() {
    const compiler = this.props.compiler!;
    return (
      &lt;div&gt;
        &lt;div&gt;{compiler}&lt;/div&gt;
        &lt;div&gt;{this.props.framework}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Hello framework=&quot;React&quot; /&gt;, // TypeScript React
  document.getElementById(&quot;root&quot;)
);
</code></pre>
<ul>
<li>SFC with default props: Recommend leveraging simple JavaScript patterns as they work well with TypeScript’s type system e.g.</li>
</ul>
<pre><code class="language-tsx">const Hello: React.SFC&lt;{
  /**
   * @default 'TypeScript'
   */
  compiler?: string,
  framework: string
}&gt; = ({
  compiler = 'TypeScript', // Default prop
  framework
}) =&gt; {
    return (
      &lt;div&gt;
        &lt;div&gt;{compiler}&lt;/div&gt;
        &lt;div&gt;{framework}&lt;/div&gt;
      &lt;/div&gt;
    );
  };


ReactDOM.render(
  &lt;Hello framework=&quot;React&quot; /&gt;, // TypeScript React
  document.getElementById(&quot;root&quot;)
);
</code></pre>
<h2 id="declaring-a-webcomponent"><a class="header" href="#declaring-a-webcomponent">Declaring a webcomponent</a></h2>
<p>If you are using a web component the default React type definitions (<code>@types/react</code>) will not know about it. But you can declare it easily e.g. to declare a webcomponent called <code>my-awesome-slider</code> that takes Props <code>MyAwesomeSliderProps</code> you would: </p>
<pre><code class="language-tsx">declare global {
  namespace JSX {
    interface IntrinsicElements {
      'my-awesome-slider': MyAwesomeSliderProps;
    }

    interface MyAwesomeSliderProps extends React.Attributes {
      name: string;
    }
  }
}
</code></pre>
<p>Now you can use it in TSX:</p>
<pre><code class="language-tsx">&lt;my-awesome-slider name='amazing'/&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="redux"><a class="header" href="#redux">Redux</a></h3>
<p>A popular library that makes use of this is redux.</p>
<p>Here is the <a href="https://github.com/reactjs/redux#the-gist"><em>gist of redux</em></a> with TypeScript type annotations added:</p>
<pre><code class="language-typescript">import { createStore } from 'redux'

type Action
  = {
    type: 'INCREMENT'
  }
  | {
    type: 'DECREMENT'
  }

/**
 * This is a reducer, a pure function with (state, action) =&gt; state signature.
 * It describes how an action transforms the state into the next state.
 *
 * The shape of the state is up to you: it can be a primitive, an array, an object,
 * or even an Immutable.js data structure. The only important part is that you should
 * not mutate the state object, but return a new object if the state changes.
 *
 * In this example, we use a `switch` statement and strings, but you can use a helper that
 * follows a different convention (such as function maps) if it makes sense for your
 * project.
 */
function counter(state = 0, action: Action) {
  switch (action.type) {
  case 'INCREMENT':
    return state + 1
  case 'DECREMENT':
    return state - 1
  default:
    return state
  }
}

// Create a Redux store holding the state of your app.
// Its API is { subscribe, dispatch, getState }.
let store = createStore(counter)

// You can use subscribe() to update the UI in response to state changes.
// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
// However, it can also be handy to persist the current state in the localStorage.

store.subscribe(() =&gt;
  console.log(store.getState())
)

// The only way to mutate the internal state is to dispatch an action.
// The actions can be serialized, logged or stored and later replayed.
store.dispatch({ type: 'INCREMENT' })
// 1
store.dispatch({ type: 'INCREMENT' })
// 2
store.dispatch({ type: 'DECREMENT' })
// 1
</code></pre>
<p>Using it with TypeScript gives you safety against typo errors, increased refactor-ability and self documenting code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-react-jsx"><a class="header" href="#non-react-jsx">Non React JSX</a></h1>
<p><a href="https://designtsx.com"><img src="https://raw.githubusercontent.com/armanriazi/typescript-all-in-one/master/images/designtsx-banner.png" alt="DesignTSX" /></a></p>
<p>TypeScript provides you with the ability to use something other than React with JSX in a type safe manner. The following lists the customizability points, but note that this is for advanced UI framework authors:</p>
<ul>
<li>You can disable <code>react</code> style emit by using <code>&quot;jsx&quot; : &quot;preserve&quot;</code> option. This means that JSX is emitted <em>as is</em> and then you can use your own custom transpiler to transpile the JSX portions.</li>
<li>Using the <code>JSX</code> global module:
<ul>
<li>You can control what HTML tags are available and how they are type checked by customizing the <code>JSX.IntrinsicElements</code> interface members.</li>
<li>When using components:
<ul>
<li>You can control which <code>class</code> must be inherited by components by customizing the default <code>interface ElementClass extends React.Component&lt;any, any&gt; { }</code> declaration.</li>
<li>You can control which property is used to type check the attributes (the default is <code>props</code>) by customizing the <code>declare module JSX { interface ElementAttributesProperty { props: {}; } }</code> declaration.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="jsxfactory"><a class="header" href="#jsxfactory"><code>jsxFactory</code></a></h2>
<p>Passing <code>--jsxFactory &lt;JSX factory Name&gt;</code> along with <code>--jsx react</code> allows for using a different JSX factory from the default <code>React</code>.</p>
<p>The new factory name will be used to call <code>createElement</code> functions.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-typescript">import {jsxFactory} from &quot;jsxFactory&quot;;

var div = &lt;div&gt;Hello JSX!&lt;/div&gt;
</code></pre>
<p>Compiled with:</p>
<pre><code class="language-shell">tsc --jsx react --reactNamespace jsxFactory --m commonJS
</code></pre>
<p>Results in:</p>
<pre><code class="language-js">&quot;use strict&quot;;
var jsxFactory_1 = require(&quot;jsxFactory&quot;);
var div = jsxFactory_1.jsxFactory.createElement(&quot;div&quot;, null, &quot;Hello JSX!&quot;);
</code></pre>
<h2 id="jsx-pragma"><a class="header" href="#jsx-pragma"><code>jsx</code> pragma</a></h2>
<p>You can even specify a different <code>jsxFactory</code> per file using <code>jsxPragma</code> e.g. </p>
<pre><code class="language-js">/** @jsx jsxFactory */
import {jsxFactory} from &quot;jsxFactory&quot;;

var div = &lt;div&gt;Hello JSX!&lt;/div&gt;
</code></pre>
<p>With <code>--jsx react</code> this file will emit to use the factory specfied in the jsx pragma: </p>
<pre><code class="language-js">&quot;use strict&quot;;
var jsxFactory_1 = require(&quot;jsxFactory&quot;);
var div = jsxFactory_1.jsxFactory.createElement(&quot;div&quot;, null, &quot;Hello JSX!&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Here are some great tools that I recommend you use or at least try in your TypeScript projects. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prettier"><a class="header" href="#prettier">Prettier</a></h1>
<p>Prettier is a great tool by facebook that makes code formatting so much easier that it’s worth mentioning. Setting up with TypeScript using our recommended project setup (aka everything in <code>src</code> folder) is super easy: </p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<ul>
<li><code>npm install prettier -D</code> </li>
<li>Add <code>scripts</code> to <code>package.json</code>: </li>
</ul>
<pre><code>    &quot;prettier:base&quot;: &quot;prettier --parser typescript --single-quote&quot;,
    &quot;prettier:check&quot;: &quot;npm run prettier:base -- --list-different \&quot;src/**/*.{ts,tsx}\&quot;&quot;,
    &quot;prettier:write&quot;: &quot;npm run prettier:base -- --write \&quot;src/**/*.{ts,tsx}\&quot;&quot;
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>On your build server: </p>
<ul>
<li><code>npm run prettier:check</code> </li>
</ul>
<p>During dev (or pre commit hook): </p>
<ul>
<li><code>npm run prettier:write</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="husky"><a class="header" href="#husky">Husky</a></h1>
<blockquote>
<p>Husky can prevent bad commits, pushes and more 🐶!</p>
</blockquote>
<p>If you want to run some JavaScript / TypeScript code before a commit takes place, husky is the tool for that. </p>
<p>For example, you can use husky to make sure files are formatted by prettier automatically so you don’t have to worry about manually formatting files ever again and focus on the objective of the code instead. Here is the setup: </p>
<ul>
<li><code>npm install husky -D</code></li>
<li>Add <code>scripts</code> to <code>package.json</code>: </li>
</ul>
<pre><code>    &quot;precommit&quot;: &quot;npm run prettier:write&quot;,
</code></pre>
<p>Now whenever you commit code and there are any formatting changes that need to be made, you’d get them as a <em>modified</em> file in your git log. You can now </p>
<ul>
<li>If you have pushed your code already, simply commit them with a comment <code>pretty</code>.</li>
<li>If you haven’t pushed your code, amend your last commit and look like a superhero.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eslint"><a class="header" href="#eslint">ESLint</a></h1>
<p>ESLint existed to lint JavaScript, but now it is also becoming the defacto linter for <a href="https://github.com/Microsoft/TypeScript/issues/29288">TypeScript</a>, thanks to the <a href="https://eslint.org/blog/2019/01/future-typescript-eslint">collaboration</a> between the two teams.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>To setup ESLint for TypeScript you need the following packages:</p>
<pre><code class="language-sh">npm i eslint eslint-plugin-react @typescript-eslint/parser @typescript-eslint/eslint-plugin
</code></pre>
<blockquote>
<p>TIP: eslint calls packages that contain lint rules as “plugin”</p>
</blockquote>
<ul>
<li>eslint : Core eslint </li>
<li>eslint-plugin-react : For react rules provided by eslint. <a href="https://github.com/yannickcr/eslint-plugin-react#list-of-supported-rules">Supported rules list</a></li>
<li>@typescript-eslint/parse : To allow eslint to understand ts / tsx files </li>
<li>@typescript-eslint/eslint-plugin : For TypeScript rules. <a href="https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin#supported-rules">Supported rules list</a></li>
</ul>
<blockquote>
<p>As you can see there are two eslint packages (for use with js or ts) and two @typescript-eslint packages (for use with ts). So the overhead for TypeScript is not <em>that much</em>.</p>
</blockquote>
<h2 id="configure"><a class="header" href="#configure">Configure</a></h2>
<p>Create <code>.eslintrc.js</code>: </p>
<pre><code class="language-js">module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.json',
  },
  plugins: ['@typescript-eslint'],
  extends: [
    'plugin:react/recommended',
    'plugin:@typescript-eslint/recommended',
  ],
  rules:  {
    // Overwrite rules specified from the extended configs e.g. 
    // &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;,
  }
}
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>In your <code>package.json</code> add to <code>scripts</code>: </p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;eslint \&quot;src/**\&quot;&quot;
  }
}
</code></pre>
<p>Now you can <code>npm run lint</code> to validate.</p>
<h2 id="configure-vscode"><a class="header" href="#configure-vscode">Configure VSCode</a></h2>
<ul>
<li>Install extension https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint</li>
<li>Add to <code>settings.json</code>:</li>
</ul>
<pre><code class="language-js">&quot;eslint.validate&quot;:  [
  &quot;javascript&quot;,
  &quot;javascriptreact&quot;,
  {&quot;language&quot;:  &quot;typescript&quot;,  &quot;autoFix&quot;:  true  },
  {&quot;language&quot;:  &quot;typescriptreact&quot;,  &quot;autoFix&quot;:  true  }
],
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="changelog"><a class="header" href="#changelog">Changelog</a></h2>
<blockquote>
<p>Reading a markdown file with the progress in the project is easier than reading a commit log.</p>
</blockquote>
<p>Automatic changelog generation from commit messages is a fairly common pattern nowadays. There is a project called <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a> that generates a changelog from commit messages that follow a <em>convention</em>. </p>
<h3 id="commit-message-convention"><a class="header" href="#commit-message-convention">Commit message convention</a></h3>
<p>The most common convention is the <em>angular</em> commit messages convention which is <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">detailed here</a>.</p>
<h3 id="setup-3"><a class="header" href="#setup-3">Setup</a></h3>
<ul>
<li>Install: </li>
</ul>
<pre><code class="language-bash">npm install standard-version -D
</code></pre>
<ul>
<li>Add a <code>script</code> target to your <code>package.json</code>: </li>
</ul>
<pre><code class="language-js">{
  &quot;scripts&quot;: {
    &quot;release&quot;: &quot;standard-version&quot;
  }
}
</code></pre>
<ul>
<li>Optionally : To automatically push the new <em>git commit and tag</em> plus publish to npm add a <code>postrelease</code> script: </li>
</ul>
<pre><code class="language-js">{
  &quot;scripts&quot;: {
    &quot;release&quot;: &quot;standard-version&quot;,
    &quot;postrelease&quot;: &quot;git push --follow-tags origin master &amp;&amp; npm publish&quot;
  }
}
</code></pre>
<h3 id="releasing"><a class="header" href="#releasing">Releasing</a></h3>
<p>Simply run: </p>
<pre><code class="language-bash">npm run release
</code></pre>
<p>Based on the commit messages <code>major</code> | <code>minor</code> | <code>patch</code> is automatically determined. To <em>explicitly</em> specify a version you can specify <code>--release-as</code> e.g.: </p>
<pre><code class="language-bash">npm run release -- --release-as minor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-1"><a class="header" href="#tips-1">TIPs</a></h1>
<p>In this section we present a number of tips that we have collected over the course of using TypeScript in the real world.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-instantiation-for-generics"><a class="header" href="#type-instantiation-for-generics">Type Instantiation for Generics</a></h2>
<p>Say you have something that has a generic parameter e.g. a class <code>Foo</code>:</p>
<pre><code class="language-typescript">class Foo&lt;T&gt;{
	foo: T;
}
</code></pre>
<p>You want to create a specialized version for it for a particular type. The pattern is to copy the item into a new variable and give it the type annotation with the generics replaced with concrete types. E.g. if you want a class <code>Foo&lt;number&gt;</code>:</p>
<pre><code class="language-typescript">class Foo&lt;T&gt;{
	foo: T;
}
let FooNumber = Foo as { new ():Foo&lt;number&gt; }; // ref 1
</code></pre>
<p>In <code>ref 1</code> you are saying that <code>FooNumber</code> is the same as <code>Foo</code> but just treat it as something that when called with the <code>new</code> operator gives an instance of <code>Foo&lt;Number&gt;</code>.</p>
<h3 id="inheritance-2"><a class="header" href="#inheritance-2">Inheritance</a></h3>
<p>The Type assertion pattern is unsafe in that it trusts you to do the right thing. A common pattern in other languages <em>for classes</em> is to just use inheritance :</p>
<pre><code class="language-typescript">class FooNumber extends Foo&lt;number&gt;{}
</code></pre>
<p>One word of caution here: if you use decorators on the base class then the inherited class might not have the same behavior as the base class (it is no longer wrapped by the decorator).</p>
<p>Of course if you are not specializing classes you still have to come up with a coercion / assertion pattern that works and hence we showed the general assertion pattern first, e.g.:</p>
<pre><code class="language-typescript">function id&lt;T&gt;(x: T) { return x; }
const idNum = id as {(x:number):number};
</code></pre>
<blockquote>
<p>Inspired by this <a href="http://stackoverflow.com/a/34864705/390330">stackoverflow question</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="string-enums-1"><a class="header" href="#string-enums-1">String enums</a></h2>
<p>Sometimes you need a collection of strings collected under a common key. Prior to TypeScript 2.4, TypeScript only supported number-based enums. If using versions prior to 2.4, a work-around is to use <a href="tips/../types/literal-types.html">string literal types to create string based enums by combining with union types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nominal-typing"><a class="header" href="#nominal-typing">Nominal Typing</a></h2>
<p>The TypeScript type system is structural <a href="tips/../why-typescript.html">and this is one of the main motivating benefits</a>. However, there are real-world use cases for a system where you want two variables to be differentiated because they have a different <em>type name</em> even if they have the same structure. A very common use case is <em>identity</em> structures (which are generally just strings with semantics associated with their <em>name</em> in languages like C#/Java).</p>
<p>There are a few patterns that have emerged in the community. I cover them in decreasing order of personal preference:</p>
<h2 id="using-literal-types"><a class="header" href="#using-literal-types">Using literal types</a></h2>
<p>This pattern uses generics and literal types: </p>
<pre><code class="language-typescript">/** Generic Id type */
type Id&lt;T extends string&gt; = {
  type: T,
  value: string,
}

/** Specific Id types */
type FooId = Id&lt;'foo'&gt;;
type BarId = Id&lt;'bar'&gt;;

/** Optional: constructors functions */
const createFoo = (value: string): FooId =&gt; ({ type: 'foo', value });
const createBar = (value: string): BarId =&gt; ({ type: 'bar', value });

let foo = createFoo('sample')
let bar = createBar('sample');

foo = bar; // Error
foo = foo; // Okay
</code></pre>
<ul>
<li>Advantages
<ul>
<li>No need for any type assertions </li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>The structure <code>{type,value}</code> might not be desireable and need server serialization support</li>
</ul>
</li>
</ul>
<h2 id="using-enums"><a class="header" href="#using-enums">Using Enums</a></h2>
<p><a href="tips/../enums.html">Enums in TypeScript</a> offer a certain level of nominal typing. Two enum types aren’t equal if they differ by name. We can use this fact to provide nominal typing for types that are otherwise structurally compatible.</p>
<p>The workaround involves:</p>
<ul>
<li>Creating a <em>brand</em> enum.</li>
<li>Creating the type as an <em>intersection</em> (<code>&amp;</code>) of the brand enum + the actual structure.</li>
</ul>
<p>This is demonstrated below where the structure of the types is just a string:</p>
<pre><code class="language-typescript">// FOO
enum FooIdBrand { _ = &quot;&quot; };
type FooId = FooIdBrand &amp; string;

// BAR
enum BarIdBrand  { _ = &quot;&quot; };
type BarId = BarIdBrand &amp; string;

/**
 * Usage Demo
 */
var fooId: FooId;
var barId: BarId;

// Safety!
fooId = barId; // error
barId = fooId; // error

// Newing up
fooId = 'foo' as FooId;
barId = 'bar' as BarId;

// Both types are compatible with the base
var str: string;
str = fooId;
str = barId;
</code></pre>
<p>Note how the brand enums,  <code>FooIdBrand</code> and <code>BarIdBrand</code> above, each have single member (<code>_</code>) that maps to the empty string, as specified by <code>{ _ = &quot;&quot; }</code>. This forces TypeScript to infer that these are string-based enums, with values of type <code>string</code>, and not enums with values of type <code>number</code>.  This is necessary because TypeScript infers an empty enum (<code>{}</code>) to be a numeric enum, and as of TypeScript 3.6.2 the intersection of a numeric <code>enum</code> and <code>string</code> is <code>never</code>.</p>
<h2 id="using-interfaces"><a class="header" href="#using-interfaces">Using Interfaces</a></h2>
<p>Because <code>numbers</code> are type compatible with <code>enum</code>s the previous technique cannot be used for them. Instead we can use interfaces to break the structural compatibility. This method is still used by the TypeScript compiler team, so worth mentioning. Using <code>_</code> prefix and a <code>Brand</code> suffix is a convention I strongly recommend (and <a href="https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698">the one followed by the TypeScript team</a>).</p>
<p>The workaround involves the following:</p>
<ul>
<li>adding an unused property on a type to break structural compatibility.</li>
<li>using a type assertion when needing to new up or cast down.</li>
</ul>
<p>This is demonstrated below:</p>
<pre><code class="language-typescript">// FOO
interface FooId extends String {
    _fooIdBrand: string; // To prevent type errors
}

// BAR
interface BarId extends String {
    _barIdBrand: string; // To prevent type errors
}

/**
 * Usage Demo
 */
var fooId: FooId;
var barId: BarId;

// Safety!
fooId = barId; // error
barId = fooId; // error
fooId = &lt;FooId&gt;barId; // error
barId = &lt;BarId&gt;fooId; // error

// Newing up
fooId = 'foo' as any;
barId = 'bar' as any;

// If you need the base string
var str: string;
str = fooId as any;
str = barId as any;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lazy-object-literal-initialization"><a class="header" href="#lazy-object-literal-initialization">Lazy Object Literal Initialization</a></h2>
<p>Quite commonly in JavaScript code bases you would initialize object literals in the following manner:</p>
<pre><code class="language-typescript">let foo = {};
foo.bar = 123;
foo.bas = &quot;Hello World&quot;;
</code></pre>
<p>As soon as you move the code to TypeScript you will start to get Errors like the following:</p>
<pre><code class="language-typescript">let foo = {};
foo.bar = 123; // Error: Property 'bar' does not exist on type '{}'
foo.bas = &quot;Hello World&quot;; // Error: Property 'bas' does not exist on type '{}'
</code></pre>
<p>This is because from the state <code>let foo = {}</code>, TypeScript <em>infers</em> the type of <code>foo</code> (left hand side of initializing assignment) to be the type of the right hand side <code>{}</code> (i.e. an object with no properties). So, it error if you try to assign to a property it doesn’t know about.</p>
<h3 id="ideal-fix"><a class="header" href="#ideal-fix">Ideal Fix</a></h3>
<p>The <em>proper</em> way to initialize an object in TypeScript is to do it in the assignment:</p>
<pre><code class="language-typescript">let foo = {
    bar: 123,
    bas: &quot;Hello World&quot;,
};
</code></pre>
<p>This is also great for code review and code maintainability purposes.</p>
<blockquote>
<p>The quick fix and middle ground <em>lazy</em> initialization patterns described below suffer from <em>mistakenly forgetting to initialize a property</em>. </p>
</blockquote>
<h3 id="quick-fix"><a class="header" href="#quick-fix">Quick Fix</a></h3>
<p>If you have a large JavaScript code base that you are migrating to TypeScript the ideal fix might not be a viable solution for you. In that case you can carefully use a <em>type assertion</em> to silence the compiler:</p>
<pre><code class="language-typescript">let foo = {} as any;
foo.bar = 123;
foo.bas = &quot;Hello World&quot;;
</code></pre>
<h3 id="middle-ground"><a class="header" href="#middle-ground">Middle Ground</a></h3>
<p>Of course using the <code>any</code> assertion can be very bad as it sort of defeats the safety of TypeScript. The middle ground fix is to create an <code>interface</code> to ensure</p>
<ul>
<li>Good Docs</li>
<li>Safe assignment</li>
</ul>
<p>This is shown below:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number
    bas: string
}

let foo = {} as Foo;
foo.bar = 123;
foo.bas = &quot;Hello World&quot;;
</code></pre>
<p>Here is a quick example that shows the fact that using the interface can save you:</p>
<pre><code class="language-typescript">interface Foo {
    bar: number
    bas: string
}

let foo = {} as Foo;
foo.bar = 123;
foo.bas = &quot;Hello World&quot;;

// later in the codebase:
foo.bar = 'Hello Stranger'; // Error: You probably misspelled `bas` as `bar`, cannot assign string to number
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="classes-are-useful"><a class="header" href="#classes-are-useful">Classes Are Useful</a></h2>
<p>It is very common to have the following structure:</p>
<pre><code class="language-typescript">function foo() {
    let someProperty;

    // Some other initialization code

    function someMethod() {
        // Do some stuff with `someProperty`
        // And potentially other things
    }
    // Maybe some other methods

    return {
        someMethod,
        // Maybe some other methods
    };
}
</code></pre>
<p>This is known as the <em>revealing module pattern</em> and quite common in JavaScript (taking advantage of JavaScript closure).</p>
<p>If you use <a href="tips/../project/modules.html"><em>file modules</em> (which you really should as global scope is bad)</a> then <em>your file is effectively the same</em>. However, there are too many cases where people will write code like the following:</p>
<pre><code class="language-typescript">let someProperty;

function foo() {
   // Some initialization code
}
foo(); // some initialization code

someProperty = 123; // some more initialization

// Some utility function not exported

// later
export function someMethod() {

}
</code></pre>
<p>Even though I am not a big fan of inheritance <em>I do find that letting people use classes helps them organize their code better</em>. The same developer would intuitively write the following:</p>
<pre><code class="language-typescript">class Foo {
    public someProperty;

    constructor() {
        // some initialization
    }

    public someMethod() {
        // some code
    }

    private someUtility() {
        // some code
    }
}

export = new Foo();
</code></pre>
<p>And its not just developers, creating dev tools that provide great visualizations over classes are much more common, and there is one less pattern your team needs to understand and maintain.</p>
<blockquote>
<p>PS: There is nothing wrong in my opinion with <em>shallow</em> class hierarchies if they provide significant reuse and reduction in boiler plate.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="export-default-concerns"><a class="header" href="#export-default-concerns"><code>export default</code> concerns</a></h2>
<p>Consider you have a file <code>foo.ts</code> with the following contents:</p>
<pre><code class="language-typescript">class Foo {
}
export default Foo;
</code></pre>
<p>You would import it (in <code>bar.ts</code>) using ES6 syntax as follows:</p>
<pre><code class="language-typescript">import Foo from &quot;./foo&quot;;
</code></pre>
<p>There are a few maintainability concerns here:</p>
<ul>
<li>If you refactor <code>Foo</code> in <code>foo.ts</code> it will not rename it in <code>bar.ts</code>.</li>
<li>If you end up needing to export more stuff from <code>foo.ts</code> (which is what many of your files will have) then you have to juggle the import syntax.</li>
</ul>
<p>For this reason I recommend simple exports + destructured import. E.g. <code>foo.ts</code>:</p>
<pre><code class="language-typescript">export class Foo {
}
</code></pre>
<p>And then:</p>
<pre><code class="language-typescript">import { Foo } from &quot;./foo&quot;;
</code></pre>
<p>Below I also present a few more reasons.</p>
<h3 id="poor-discoverability"><a class="header" href="#poor-discoverability">Poor Discoverability</a></h3>
<p>Discoverability is very poor for default exports. You cannot explore a module with intellisense to see if it has a default export or not.</p>
<p>With export default you get nothing here (maybe it does export default / maybe it doesn’t <code>¯\_(ツ)_/¯</code>):</p>
<pre><code>import /* here */ from 'something';
</code></pre>
<p>Without export default you get a nice intellisense here: </p>
<pre><code>import { /* here */ } from 'something';
</code></pre>
<h3 id="autocomplete"><a class="header" href="#autocomplete">Autocomplete</a></h3>
<p>Irrespective of if you know about the exports, you even autocomplete at this <code>import {/*here*/} from &quot;./foo&quot;;</code> cursor location. Gives your developers a bit of wrist relief.</p>
<h3 id="commonjs-interop"><a class="header" href="#commonjs-interop">CommonJS interop</a></h3>
<p>With <code>default</code> there is horrible experience for commonJS users who have to <code>const {default} = require('module/foo');</code> instead of <code>const {Foo} = require('module/foo')</code>. You will most likely want to rename the <code>default</code> export to something else when you import it.</p>
<h3 id="typo-protection"><a class="header" href="#typo-protection">Typo Protection</a></h3>
<p>You don’t get typos like one dev doing <code>import Foo from &quot;./foo&quot;;</code> and another doing <code>import foo from &quot;./foo&quot;;</code></p>
<h3 id="typescript-auto-import"><a class="header" href="#typescript-auto-import">TypeScript auto-import</a></h3>
<p>Auto import quickfix works better. You use <code>Foo</code> and auto import will write down <code>import { Foo } from &quot;./foo&quot;;</code> cause its a well defined name exported from a module. Some tools out there will try to magic read and <em>infer</em> a name for a default export but magic is flaky.</p>
<h3 id="re-exporting"><a class="header" href="#re-exporting">Re-exporting</a></h3>
<p>Re-exporting is common for the root <code>index</code> file in npm packages, and forces you to name the default export manually e.g. <code>export { default as Foo } from &quot;./foo&quot;;</code> (with default) vs. <code>export * from &quot;./foo&quot;</code> (with named exports).</p>
<h3 id="dynamic-imports"><a class="header" href="#dynamic-imports">Dynamic Imports</a></h3>
<p>Default exports expose themselves badly named as <code>default</code> in dynamic <code>import</code>s e.g. </p>
<pre><code class="language-typescript">const HighCharts = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');
HighCharts.default.chart('container', { ... }); // Notice `.default`
</code></pre>
<p>Much nicer with named exports: </p>
<pre><code class="language-typescript">const {HighCharts} = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');
HighCharts.chart('container', { ... }); // Notice `.default`
</code></pre>
<h3 id="needs-two-lines-for-non-class--non-function"><a class="header" href="#needs-two-lines-for-non-class--non-function">Needs two lines for non-class / non-function</a></h3>
<p>Can be one statement for function / class e.g. </p>
<pre><code class="language-typescript">export default function foo() {
}
</code></pre>
<p>Can be one statement for <em>non named / type annotated</em> objects e.g.: </p>
<pre><code class="language-typescript">export default {
  notAFunction: 'Yeah, I am not a function or a class',
  soWhat: 'The export is now *removed* from the declaration'
};
</code></pre>
<p>But needs two statements otherwise:</p>
<pre><code class="language-typescript">// If you need to name it (here `foo`) for local use OR need to annotate type (here `Foo`)
const foo: Foo = {
  notAFunction: 'Yeah, I am not a function or a class',
  soWhat: 'The export is now *removed* from the declaration'
};
export default foo;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="limit-usage-of-property-setters"><a class="header" href="#limit-usage-of-property-setters">Limit usage of property setters</a></h2>
<p>Prefer explicit set/get functions (e.g. <code>setBar</code> and <code>getBar</code> functions) over setters/getters.</p>
<p>Consider the following code:</p>
<pre><code class="language-typescript">foo.bar = {
    a: 123,
    b: 456
};
</code></pre>
<p>In the presence of setter/getters:</p>
<pre><code class="language-typescript">class Foo {
    a: number;
    b: number;
    set bar(value:{a:number,b:number}) {
        this.a = value.a;
        this.b = value.b;
    }
}
let foo = new Foo();
</code></pre>
<p>This is not a <em>good</em> use of property setters. The person reading the first code sample has no context about all the things that will change. Whereas someone calling <code>foo.setBar(value)</code> might have an idea that something might change on <code>foo</code>.</p>
<blockquote>
<p>Bonus points: Find references works better if you have different functions. In TypeScript tools if you find references for a getter or a setter you get <em>both</em> whereas with explicit function calls you only get references to the relevant function.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="--outfile-is-bad-outfile"><a class="header" href="#--outfile-is-bad-outfile"><code>--outFile</code> is BAD {#outFile}</a></h1>
<p>Its a bad idea for you to use because of the following reasons:</p>
<ul>
<li>Runtime Errors</li>
<li>Fast compile</li>
<li>Global scope</li>
<li>Hard to analyze</li>
<li>Hard to scale</li>
<li><code>_references</code></li>
<li>Code reuse</li>
<li>Multiple Targets</li>
<li>Isolated Compile</li>
</ul>
<h2 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h2>
<p>If your code depends on any form of js ordering you will get random errors at runtime.</p>
<ul>
<li><strong>class inheritance can break at runtime.</strong></li>
</ul>
<p>Consider <code>foo.ts</code>: </p>
<pre><code class="language-typescript">class Foo {
    
}
</code></pre>
<p>and a <code>bar.ts</code>:</p>
<pre><code class="language-typescript">class Bar extends Foo {
    
}
</code></pre>
<p>If you fail to compile it in correct order e.g. perhaps alphabetically <code>tsc bar.ts foo.ts</code> the code will compile fine but error at runtime with <code>ReferenceError</code>. </p>
<ul>
<li><strong>module splitting can fail at runtime.</strong></li>
</ul>
<p>Consider <code>foo.ts</code>: </p>
<pre><code class="language-typescript">module App {
    export var foo = 123;
}
</code></pre>
<p>And <code>bar.ts</code>: </p>
<pre><code class="language-typescript">module App {
    export var bar = foo + 456;
}
</code></pre>
<p>If you fail to compile it in correct order e.g. perhaps alphabetically <code>tsc bar.ts foo.ts</code> the code will compile fine but  <em>silently</em> fail at runtime with <code>bar</code> set to <code>NaN</code>. </p>
<h2 id="fast-compile"><a class="header" href="#fast-compile">Fast compile</a></h2>
<p>If you use <code>--out</code> then single <code>.ts</code> files cannot be codegened into single <code>.js</code> files in isolation without unnecessary hacks. <code>--out</code> essentially forces a slower incremental build.</p>
<p>Also source maps are positionally sensitive and run-length encoded so most of the map has to be rebuilt on a recompile if you use source maps (which you should!). At high-10s to 100s kloc combined it’s going to get slow.</p>
<h2 id="global-scope"><a class="header" href="#global-scope">Global Scope</a></h2>
<p>Sure you can use name spaces but its still on <code>window</code> if you run it in the browser. Namespaces are just an unnecessary workaround. Also <code>/// &lt;reference</code> comments introduce a global context in <em>your code</em> that can get hard to maintain.</p>
<p>Also if your company has several teams working independently and then someone decides to try integrating two independently written apps there is a high likelihood of a name conflict.</p>
<h2 id="hard-to-analyze"><a class="header" href="#hard-to-analyze">Hard to analyze</a></h2>
<p>We wish to provide more code analysis tools. These will be easier if you provide us with the dependency chain (implicitly there on a silver platter using external modules). </p>
<p>Also its not just the <em>dev tools</em> that have a hard time making sense of the code. The next human needs to understand a lot of the code base before they start to understand where stuff is actually imported from. Using internal modules also makes code difficult to review in isolation e.g. on github.</p>
<h2 id="hard-to-scale"><a class="header" href="#hard-to-scale">Hard to scale</a></h2>
<p>Really just a result of random runtime errors + slower and slower compile times + difficulty in understanding someone else’s code.</p>
<h2 id="_referencests"><a class="header" href="#_referencests"><code>_references.ts</code></a></h2>
<p>Isn’t supported by <code>tsconfig.json</code> : https://github.com/Microsoft/TypeScript/issues/2472#issuecomment-85330803 You’ll have to manually sort the  <code>files</code> array. </p>
<h2 id="code-reuse"><a class="header" href="#code-reuse">Code reuse</a></h2>
<p>If you want to reuse a portion of your code in another project, with all that <em>implicit</em> dependency management, it will be difficult to port it over without potential runtime errors. </p>
<h2 id="multiple-targets"><a class="header" href="#multiple-targets">Multiple Targets</a></h2>
<p>Also if you decide to reuse your browser code in something like nodejs (e.g. for <em>testing</em> APIs) you are going to need to port it over to a module system or come up with ugly hacks to make the nodejs <code>global</code> your new global scope (i.e. <code>window</code>).</p>
<h2 id="isolated-compile"><a class="header" href="#isolated-compile">Isolated Compile</a></h2>
<p>Files cannot be compiled in isolation. E.g. consider <code>a.ts</code>: </p>
<pre><code class="language-typescript">module M {
  var s = t;
}
</code></pre>
<p>Will have different output depending upon whether there is a <code>b.ts</code> of the form: </p>
<pre><code class="language-typescript">module M {
  export var t = 5;
}
</code></pre>
<p>or </p>
<pre><code class="language-typescript">var t = 5;
</code></pre>
<p>So <code>a.ts</code> <a href="https://github.com/Microsoft/TypeScript/issues/2715">cannot be compiled in isolation</a>.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p><code>--out</code> is really the job of some build tool. And even such a build tool can benefit from the dependency mentions provided by external modules. So we recommend you use external modules and then let the build tool create a single <code>.js</code> for you if you so desire.</p>
<p>https://twitter.com/nycdotnet/status/613705850574778368 </p>
<p><img src="https://pbs.twimg.com/media/CIRSOBmWsAQdzvP.jpg" alt="The Bas Signal" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jquery-tips"><a class="header" href="#jquery-tips">JQuery Tips</a></h2>
<p>Note: you need to install the <code>jquery.d.ts</code> file for these tips</p>
<h3 id="quickly-define-a-new-plugin"><a class="header" href="#quickly-define-a-new-plugin">Quickly define a new plugin</a></h3>
<p>Just create <code>jquery-foo.d.ts</code> with: </p>
<pre><code class="language-typescript">interface JQuery {
  foo: any;
}
</code></pre>
<p>And now you can use <code>$('something').foo({whateverYouWant:'hello jquery plugin'})</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-constructors-in-typescript"><a class="header" href="#static-constructors-in-typescript">Static Constructors in TypeScript</a></h1>
<p>TypeScript <code>class</code> (like JavaScript <code>class</code>) cannot have a static constructor. However, you can get the same effect quite easily by just calling it yourself: </p>
<pre><code class="language-typescript">class MyClass {
    static initialize() {
        // Initialization
    }
}
MyClass.initialize();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-toggles"><a class="header" href="#build-toggles">Build Toggles</a></h2>
<p>It is common to switch in JavaScript projects based on where they are being run. You can do this quite easily with webpack as it supports <em>dead code elimination</em> based on environment variables.</p>
<p>Add different targets in your <code>package.json</code> <code>scripts</code>:</p>
<pre><code class="language-json">&quot;build:test&quot;: &quot;webpack -p --config ./src/webpack.config.js&quot;,
&quot;build:prod&quot;: &quot;webpack -p --define process.env.NODE_ENV='\&quot;production\&quot;' --config ./src/webpack.config.js&quot;,
</code></pre>
<p>Of course I am assuming you have <code>npm install webpack --save-dev</code>. Now you can run <code>npm run build:test</code> etc.</p>
<p>Using this variable is super easy as well:</p>
<pre><code class="language-typescript">/**
 * This interface makes sure we don't miss adding a property to both `prod` and `test`
 */
interface Config {
  someItem: string;
}

/**
 * We only export a single thing. The config.
 */
export let config: Config;

/**
 * `process.env.NODE_ENV` definition is driven from webpack
 *
 * The whole `else` block will be removed in the emitted JavaScript
 *  for a production build
 */
if (process.env.NODE_ENV === 'production') {
  config = {
    someItem: 'prod'
  }
  console.log('Running in prod');
} else {
  config = {
    someItem: 'test'
  }
  console.log('Running in test');
}
</code></pre>
<blockquote>
<p>We use <code>process.env.NODE_ENV</code> just because it is conventional in a lot of JavaScript libraries themselves e.g. <code>React</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="barrel"><a class="header" href="#barrel">Barrel</a></h2>
<p>A barrel is a way to rollup exports from several modules into a single convenient module. The barrel itself is a module file that re-exports selected exports of other modules.</p>
<p>Imagine the following class structure in a library: </p>
<pre><code class="language-typescript">// demo/foo.ts
export class Foo {}

// demo/bar.ts
export class Bar {}

// demo/baz.ts
export class Baz {}
</code></pre>
<p>Without a barrel, a consumer would need three import statements:</p>
<pre><code class="language-typescript">import { Foo } from '../demo/foo';
import { Bar } from '../demo/bar';
import { Baz } from '../demo/baz';
</code></pre>
<p>You can instead add a barrel <code>demo/index.ts</code> containing the following: </p>
<pre><code class="language-typescript">// demo/index.ts
export * from './foo'; // re-export all of its exports
export * from './bar'; // re-export all of its exports
export * from './baz'; // re-export all of its exports
</code></pre>
<p>Now the consumer can import what it needs from the barrel:</p>
<pre><code class="language-typescript">import { Foo, Bar, Baz } from '../demo'; // demo/index.ts is implied
</code></pre>
<h3 id="named-exports"><a class="header" href="#named-exports">Named exports</a></h3>
<p>Instead of exporting <code>*</code>, you can choose to export the module in a name. E.g., assume that <code>baz.ts</code> has functions:</p>
<pre><code class="language-typescript">// demo/foo.ts
export class Foo {}

// demo/bar.ts
export class Bar {}

// demo/baz.ts
export function getBaz() {}
export function setBaz() {}
</code></pre>
<p>If you would rather not export <code>getBaz</code> / <code>setBaz</code> from demo you can instead put them in a variable by importing them in a name and exporting that name as shown below: </p>
<pre><code class="language-typescript">// demo/index.ts
export * from './foo'; // re-export all of its exports
export * from './bar'; // re-export all of its exports

import * as baz from './baz'; // import as a name
export { baz }; // export the name
</code></pre>
<p>And now the consumer would look like: </p>
<pre><code class="language-typescript">import { Foo, Bar, baz } from '../demo'; // demo/index.ts is implied

// usage
baz.getBaz();
baz.setBaz();
// etc. ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="typesafe-event-emitter"><a class="header" href="#typesafe-event-emitter">Typesafe Event Emitter</a></h2>
<p>Conventionally in Node.js and traditional JavaScript you have a single event emitter. This event emitter internally tracks listener for different event types e.g. </p>
<pre><code class="language-typescript">const emitter = new EventEmitter();
// Emit: 
emitter.emit('foo', foo);
emitter.emit('bar', bar);
// Listen: 
emitter.on('foo', (foo)=&gt;console.log(foo));
emitter.on('bar', (bar)=&gt;console.log(bar));
</code></pre>
<p>Essentially <code>EventEmitter</code> internally stores data in the form of mapped arrays: </p>
<pre><code class="language-typescript">{foo: [fooListeners], bar: [barListeners]}
</code></pre>
<p>Instead, for the sake of <em>event</em> type safety, you can create an emitter <em>per</em> event type:</p>
<pre><code class="language-typescript">const onFoo = new TypedEvent&lt;Foo&gt;();
const onBar = new TypedEvent&lt;Bar&gt;();

// Emit: 
onFoo.emit(foo);
onBar.emit(bar);
// Listen: 
onFoo.on((foo)=&gt;console.log(foo));
onBar.on((bar)=&gt;console.log(bar));
</code></pre>
<p>This has the following advantages: </p>
<ul>
<li>The types of events are easily discoverable as variables.</li>
<li>The event emitter variables are easily refactored independently.</li>
<li>Type safety for event data structures.</li>
</ul>
<h3 id="reference-typedevent"><a class="header" href="#reference-typedevent">Reference TypedEvent</a></h3>
<pre><code class="language-typescript">export interface Listener&lt;T&gt; {
  (event: T): any;
}

export interface Disposable {
  dispose();
}

/** passes through events as they happen. You will not get events from before you start listening */
export class TypedEvent&lt;T&gt; {
  private listeners: Listener&lt;T&gt;[] = [];
  private listenersOncer: Listener&lt;T&gt;[] = [];

  on = (listener: Listener&lt;T&gt;): Disposable =&gt; {
    this.listeners.push(listener);
    return {
      dispose: () =&gt; this.off(listener)
    };
  }

  once = (listener: Listener&lt;T&gt;): void =&gt; {
    this.listenersOncer.push(listener);
  }

  off = (listener: Listener&lt;T&gt;) =&gt; {
    var callbackIndex = this.listeners.indexOf(listener);
    if (callbackIndex &gt; -1) this.listeners.splice(callbackIndex, 1);
  }

  emit = (event: T) =&gt; {
    /** Update any general listeners */
    this.listeners.forEach((listener) =&gt; listener(event));

    /** Clear the `once` queue */
    if (this.listenersOncer.length &gt; 0) {
      const toCall = this.listenersOncer;
      this.listenersOncer = [];
      toCall.forEach((listener) =&gt; listener(event));
    }
  }

  pipe = (te: TypedEvent&lt;T&gt;): Disposable =&gt; {
    return this.on((e) =&gt; te.emit(e));
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler"><a class="header" href="#compiler">Compiler</a></h1>
<p>The TypeScript compiler source is located under the <a href="https://github.com/Microsoft/TypeScript/tree/master/src/compiler"><code>src/compiler</code></a> folder.</p>
<p>It is split into the follow key parts:</p>
<ul>
<li>Scanner (<code>scanner.ts</code>)</li>
<li>Parser (<code>parser.ts</code>)</li>
<li>Binder (<code>binder.ts</code>)</li>
<li>Checker (<code>checker.ts</code>)</li>
<li>Emitter (<code>emitter.ts</code>)</li>
</ul>
<p>Each of these get their own unique files in the source. These parts will be explained later on in this chapter. </p>
<h2 id="syntax-vs-semantics"><a class="header" href="#syntax-vs-semantics">Syntax vs. Semantics</a></h2>
<p>Just because something is <em>syntactically</em> correct doesn’t mean it is <em>semantically</em> correct. Consider the following piece of TypeScript code which although <em>syntactically</em> valid is <em>semantically</em> wrong</p>
<pre><code class="language-typescript">var foo: number = &quot;not a number&quot;;
</code></pre>
<p><code>Semantic</code> means “meaning” in English. This concept is useful to have in your head.</p>
<h2 id="processing-overview"><a class="header" href="#processing-overview">Processing Overview</a></h2>
<p>The following is a quick review of how these key parts of the TypeScript compiler compose:</p>
<pre><code class="language-code">SourceCode ~~ scanner ~~&gt; Token Stream
</code></pre>
<pre><code class="language-code">Token Stream ~~ parser ~~&gt; AST
</code></pre>
<pre><code class="language-code">AST ~~ binder ~~&gt; Symbols
</code></pre>
<p><code>Symbol</code> is the primary building block of the TypeScript <em>semantic</em> system. As shown the symbols are created as a result of binding. Symbols connect declaration nodes in the AST to other declarations contributing to the same entity.</p>
<p>Symbols + AST are what is used by the checker to <em>semantically</em> validate the source code</p>
<pre><code class="language-code">AST + Symbols ~~ checker ~~&gt; Type Validation
</code></pre>
<p>Finally When a JS output is requested:</p>
<pre><code class="language-code">AST + Checker ~~ emitter ~~&gt; JS
</code></pre>
<p>There are a few additional files in the TypeScript compiler that provide utilities to many of these key portions which we cover next.</p>
<h2 id="file-utilities"><a class="header" href="#file-utilities">File: Utilities</a></h2>
<p><code>core.ts</code> : core utilities used by the TypeScript compiler. A few important ones:</p>
<ul>
<li><code>let objectAllocator: ObjectAllocator</code> : is a variable defined as a singleton global. It provides the definitions for <code>getNodeConstructor</code> (Nodes are covered when we look at <code>parser</code> / <code>AST</code>), <code>getSymbolConstructor</code> (Symbols are covered in <code>binder</code>), <code>getTypeConstructor</code> (Types are covered in <code>checker</code>), <code>getSignatureConstructor</code> (Signatures are the index, call and construct signatures).</li>
</ul>
<h2 id="file-key-data-structures"><a class="header" href="#file-key-data-structures">File: Key Data Structures</a></h2>
<p><code>types.ts</code> contains key data structures and interfaces uses throughout the compiler. Here is a sampling of a few key ones:</p>
<ul>
<li><code>SyntaxKind</code>
The AST node type is identified by the <code>SyntaxKind</code> enum.</li>
<li><code>TypeChecker</code>
This is the interface provided by the TypeChecker.</li>
<li><code>CompilerHost</code>
This is used by the <code>Program</code> to interact with the <code>System</code>.</li>
<li><code>Node</code>
An AST node.</li>
</ul>
<h2 id="file-system"><a class="header" href="#file-system">File: System</a></h2>
<p><code>system.ts</code>. All interaction of the TypeScript compiler with the operating system goes through a <code>System</code> interface. Both the interface and its implementations (<code>WScript</code> and <code>Node</code>) are defined in <code>system.ts</code>. You can think of it as the <em>Operating Environment</em> (OE).</p>
<p>Now that you have an overview of the major files, we can look at the concept of <code>Program</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="program"><a class="header" href="#program">Program</a></h2>
<p>Defined in <code>program.ts</code>. The compilation context (<a href="compiler/../project/compilation-context.html">a concept we covered previously</a>) is represented within the TypeScript compiler as a <code>Program</code>. It consists of <code>SourceFile</code>s and compiler options.</p>
<h3 id="usage-of-compilerhost"><a class="header" href="#usage-of-compilerhost">Usage of <code>CompilerHost</code></a></h3>
<p>Its interaction mechanism with the OE:</p>
<p><code>Program</code> <em>-uses-&gt;</em> <code>CompilerHost</code> <em>-uses-&gt;</em> <code>System</code></p>
<p>The reason for having a <code>CompilerHost</code> as a point of indirection is that it allows its interface to be more finely tuned for <code>Program</code> needs and not bother with OE needs (e.g. the <code>Program</code> doesn’t care about <code>fileExists</code> a function provided by <code>System</code>).</p>
<p>There are other users of <code>System</code> as well (e.g. tests).</p>
<h3 id="sourcefile"><a class="header" href="#sourcefile">SourceFile</a></h3>
<p>The program provides an API to get the Source Files <code>getSourceFiles(): SourceFile[];</code>. Each is represented as a root-level node for an AST (called <code>SourceFile</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="node"><a class="header" href="#node">Node</a></h2>
<p>The basic building block of the Abstract Syntax Tree (AST). In general a <code>Node</code> represents non-terminals in the language grammar; however, some terminals are kept in the tree such as identifiers and literals.</p>
<p>Two key things make up an AST node’s documentation. The node’s <code>SyntaxKind</code> which identifies its type within the AST, and its <code>interface</code>, the API the node provides when instantiated into the AST.</p>
<p>Here are a few key <code>interface Node</code> members:</p>
<ul>
<li><code>TextRange</code> members that identify the node’s <code>start</code> and <code>end</code> in the source file.</li>
<li><code>parent?: Node</code> the parent of the node in the AST.</li>
</ul>
<p>There are other additional members for <code>Node</code> flags and modifiers etc. that you can lookup by searching <code>interface Node</code> in the source code but the ones we mentioned are vital for node traversal.</p>
<h2 id="sourcefile-1"><a class="header" href="#sourcefile-1">SourceFile</a></h2>
<ul>
<li><code>SyntaxKind.SourceFile</code></li>
<li><code>interface SourceFile</code>.</li>
</ul>
<p>Each <code>SourceFile</code> is a top-level AST node that is contained in the <code>Program</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ast-tip-visit-children"><a class="header" href="#ast-tip-visit-children">AST Tip: Visit Children</a></h3>
<p>There is a utility function <code>ts.forEachChild</code> that allows you to visit all the child nodes of any Node in the AST.</p>
<p>Here is simplified snippet of the source code to demonstrate how it functions:</p>
<pre><code class="language-typescript">
export function forEachChild&lt;T&gt;(node: Node, cbNode: (node: Node) =&gt; T, cbNodeArray?: (nodes: Node[]) =&gt; T): T {
        if (!node) {
            return;
        }
        switch (node.kind) {
            case SyntaxKind.BinaryExpression:
                return visitNode(cbNode, (&lt;BinaryExpression&gt;node).left) ||
                    visitNode(cbNode, (&lt;BinaryExpression&gt;node).operatorToken) ||
                    visitNode(cbNode, (&lt;BinaryExpression&gt;node).right);
            case SyntaxKind.IfStatement:
                return visitNode(cbNode, (&lt;IfStatement&gt;node).expression) ||
                    visitNode(cbNode, (&lt;IfStatement&gt;node).thenStatement) ||
                    visitNode(cbNode, (&lt;IfStatement&gt;node).elseStatement);

            // .... lots more
</code></pre>
<p>Basically, it checks <code>node.kind</code> and based on that assumes an interface offered by the <code>node</code> and calls the <code>cbNode</code> on the children. However, note that this function doesn’t call <code>visitNode</code> for <em>all</em> children (e.g. SyntaxKind.SemicolonToken). If you want <em>all</em> the children of a node in the AST just call <code>.getChildren</code> member function of the <code>Node</code>.</p>
<p>E.g. here is a function that prints the verbose <code>AST</code> of a node:</p>
<pre><code class="language-typescript">function printAllChildren(node: ts.Node, depth = 0) {
    console.log(new Array(depth+1).join('----'), ts.syntaxKindToName(node.kind), node.pos, node.end);
    depth++;
    node.getChildren().forEach(c=&gt; printAllChildren(c, depth));
}
</code></pre>
<p>We will see a sample usage of this function when we discuss the parser further.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ast-tip-syntaxkind"><a class="header" href="#ast-tip-syntaxkind">AST Tip: SyntaxKind</a></h3>
<p><code>SyntaxKind</code> is defined as a <code>const enum</code>, here is a sample:</p>
<pre><code class="language-typescript">export const enum SyntaxKind {
    Unknown,
    EndOfFileToken,
    SingleLineCommentTrivia,
    // ... LOTS more
</code></pre>
<p>It’s a <code>const enum</code> (a concept <a href="compiler/../enums.html">we covered previously</a>) so that it gets <em>inlined</em> (e.g. <code>ts.SyntaxKind.EndOfFileToken</code> becomes <code>1</code>) and we don’t get a dereferencing cost when working with the AST. However, the compiler is compiled with <code>--preserveConstEnums</code> compiler flag so that the enum <em>is still available at runtime</em>. So in JavaScript you can use <code>ts.SyntaxKind.EndOfFileToken</code> if you want. Additionally you can convert these enum members to display strings using the following function:</p>
<pre><code class="language-typescript">export function syntaxKindToName(kind: ts.SyntaxKind) {
    return (&lt;any&gt;ts).SyntaxKind[kind];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="trivia"><a class="header" href="#trivia">Trivia</a></h3>
<p>Trivia (called that because it’s <code>trivial</code>) represent the parts of the source text that are largely insignificant for normal understanding of the code. For example; whitespace, comments, and even conflict markers. Trivia is <em>not stored</em> in the AST (to keep it lightweight). However, it can be fetched <em>on demand</em> using a few <code>ts.*</code> APIs. </p>
<p>Before we show them you need to understand the following:</p>
<h4 id="trivia-ownership"><a class="header" href="#trivia-ownership">Trivia Ownership</a></h4>
<p>In General:</p>
<ul>
<li>A token owns any trivia after it on the <em>same</em> line <em>upto</em> the next token.</li>
<li>Any comment <em>after that line</em> is associated with the following token.</li>
</ul>
<p>For leading and ending comments in a file:</p>
<ul>
<li>The first token in the source file gets all the initial trivia.</li>
<li>The last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</li>
</ul>
<h4 id="trivia-apis"><a class="header" href="#trivia-apis">Trivia APIs</a></h4>
<p>For most basic uses, comments are the “interesting” trivia. The comments that belong to a Node can be fetched through the following functions:</p>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ts.getLeadingCommentRanges</code></td><td>Given the source text and position within that text, returns ranges of comments between the first line break following the given position and the token itself (probably most useful with <code>ts.Node.getFullStart</code>).</td></tr>
<tr><td><code>ts.getTrailingCommentRanges</code></td><td>Given the source text and position within that text, returns ranges of comments until the first line break following the given position (probably most useful with <code>ts.Node.getEnd</code>).</td></tr>
</tbody></table>
<p>As an example, imagine this portion of a source file:</p>
<pre><code class="language-typescript">debugger;/*hello*/
    //bye
  /*hi*/    function
</code></pre>
<p><code>getLeadingCommentRanges</code> for the <code>function</code> will only return the last 2 comments <code>//bye</code> and <code>/*hi*/</code>.</p>
<p>Appropriately, calling <code>getTrailingCommentRanges</code> on the end of the debugger statement will extract the <code>/*hello*/</code> comment.</p>
<h4 id="token-startfull-start"><a class="header" href="#token-startfull-start">Token Start/Full Start</a></h4>
<p>Nodes have what is called a “token start” and a “full start”.</p>
<ul>
<li>Token Start: the more natural version, which is the position in file where the text of a token begins</li>
<li>Full Start: the point at which the scanner began scanning since the last significant token</li>
</ul>
<p>AST nodes have an API for <code>getStart</code> and <code>getFullStart</code>. In the following example:</p>
<pre><code class="language-typescript">debugger;/*hello*/
    //bye
  /*hi*/    function
</code></pre>
<p>for <code>function</code> the token start is at <code>function</code> whereas <em>full</em> start is at <code>/*hello*/</code>. Note that full start even includes the trivia that would otherwise be owned by the previous node.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scanner"><a class="header" href="#scanner">Scanner</a></h2>
<p>The source code for the TypeScript scanner is located entirely in <code>scanner.ts</code>. Scanner is <em>controlled</em> internally by the <code>Parser</code> to convert the source code to an AST. Here is what the desired outcome is.</p>
<pre><code>SourceCode ~~ scanner ~~&gt; Token Stream ~~ parser ~~&gt; AST
</code></pre>
<h3 id="usage-by-parser"><a class="header" href="#usage-by-parser">Usage by Parser</a></h3>
<p>There is a <em>singleton</em> <code>scanner</code> created in <code>parser.ts</code> to avoid the cost of creating scanners over and over again. This scanner is then <em>primed</em> by the parser on demand using the <code>initializeState</code> function.</p>
<p>Here is a <em>simplied</em> version of the actual code in the parser that you can run demonstrating this concept:</p>
<p><code>code/compiler/scanner/runScanner.ts</code></p>
<pre><code class="language-typescript">import * as ts from &quot;ntypescript&quot;;

// TypeScript has a singleton scanner
const scanner = ts.createScanner(ts.ScriptTarget.Latest, /*skipTrivia*/ true);

// That is initialized using a function `initializeState` similar to
function initializeState(text: string) {
    scanner.setText(text);
    scanner.setOnError((message: ts.DiagnosticMessage, length: number) =&gt; {
        console.error(message);
    });
    scanner.setScriptTarget(ts.ScriptTarget.ES5);
    scanner.setLanguageVariant(ts.LanguageVariant.Standard);
}

// Sample usage
initializeState(`
var foo = 123;
`.trim());

// Start the scanning
var token = scanner.scan();
while (token != ts.SyntaxKind.EndOfFileToken) {
    console.log(ts.formatSyntaxKind(token));
    token = scanner.scan();
}
</code></pre>
<p>This will print out the following :</p>
<pre><code>VarKeyword
Identifier
FirstAssignment
FirstLiteralToken
SemicolonToken
</code></pre>
<h3 id="scanner-state"><a class="header" href="#scanner-state">Scanner State</a></h3>
<p>After you call <code>scan</code> the scanner updates its local state (position in the scan, current token details etc). The scanner provides a bunch of utility functions to get the current scanner state. In the below sample we create a scanner and then use it to identify the tokens as well as their positions in the code.</p>
<p><code>code/compiler/scanner/runScannerWithPosition.ts</code></p>
<pre><code class="language-typescript">// Sample usage
initializeState(`
var foo = 123;
`.trim());

// Start the scanning
var token = scanner.scan();
while (token != ts.SyntaxKind.EndOfFileToken) {
    let currentToken = ts.formatSyntaxKind(token);
    let tokenStart = scanner.getStartPos();
    token = scanner.scan();
    let tokenEnd = scanner.getStartPos();
    console.log(currentToken, tokenStart, tokenEnd);
}
</code></pre>
<p>This will print out the following:</p>
<pre><code>VarKeyword 0 3
Identifier 3 7
FirstAssignment 7 9
FirstLiteralToken 9 13
SemicolonToken 13 14
</code></pre>
<h3 id="standalone-scanner"><a class="header" href="#standalone-scanner">Standalone scanner</a></h3>
<p>Even though the TypeScript parser has a singleton scanner you can create a standalone scanner using <code>createScanner</code> and use its <code>setText</code>/<code>setTextPos</code> to scan at different points in a file for your amusement.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parser"><a class="header" href="#parser">Parser</a></h2>
<p>The sourcecode for the TypeScript parser is located entirely in <code>parser.ts</code>. Scanner is <em>controlled</em> internally by the <code>Parser</code> to convert the source code to an AST. Here is a review of what the desired outcome is.</p>
<pre><code>SourceCode ~~ scanner ~~&gt; Token Stream ~~ parser ~~&gt; AST
</code></pre>
<p>The parser is implemented as a singleton (similar reasons to <code>scanner</code>, don’t want to recreate it if we can reinit it). It is actually implemented as <code>namespace Parser</code> which contains <em>state</em> variables for the Parser as well as a singleton <code>scanner</code>. As mentioned before it contains a <code>const scanner</code>. The parser functions manage this scanner.</p>
<h3 id="usage-by-program"><a class="header" href="#usage-by-program">Usage by program</a></h3>
<p>Parser is driven indirectly by Program (indirectly as its actually by <code>CompilerHost</code> which we mentioned previously). Basically this is the simplified call stack:</p>
<pre><code>Program -&gt;
    CompilerHost.getSourceFile -&gt;
        (global function parser.ts).createSourceFile -&gt;
            Parser.parseSourceFile
</code></pre>
<p>The <code>parseSourceFile</code> not only primes the state for the Parser but also primes the state for the <code>scanner</code> by calling <code>initializeState</code>. It then goes on to parse the source file using <code>parseSourceFileWorker</code>.</p>
<h3 id="sample-usage"><a class="header" href="#sample-usage">Sample Usage</a></h3>
<p>Before we dig too deep into the parser internals, here is a sample code that uses the TypeScript’s parser to get the AST of a source file (using <code>ts.createSourceFile</code>), and then print it.</p>
<p><code>code/compiler/parser/runParser.ts</code></p>
<pre><code class="language-typescript">import * as ts from &quot;ntypescript&quot;;

function printAllChildren(node: ts.Node, depth = 0) {
    console.log(new Array(depth + 1).join('----'), ts.formatSyntaxKind(node.kind), node.pos, node.end);
    depth++;
    node.getChildren().forEach(c=&gt; printAllChildren(c, depth));
}

var sourceCode = `
var foo = 123;
`.trim();

var sourceFile = ts.createSourceFile('foo.ts', sourceCode, ts.ScriptTarget.ES5, true);
printAllChildren(sourceFile);
</code></pre>
<p>This will print out the following:</p>
<pre><code class="language-typescript">SourceFile 0 14
---- SyntaxList 0 14
-------- VariableStatement 0 14
------------ VariableDeclarationList 0 13
---------------- VarKeyword 0 3
---------------- SyntaxList 3 13
-------------------- VariableDeclaration 3 13
------------------------ Identifier 3 7
------------------------ FirstAssignment 7 9
------------------------ FirstLiteralToken 9 13
------------ SemicolonToken 13 14
---- EndOfFileToken 14 14
</code></pre>
<p>This looks like a (very right sided) tree if you tilt your head to the left.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="parser-functions"><a class="header" href="#parser-functions">Parser Functions</a></h3>
<p>As mentioned <code>parseSourceFile</code> sets up the initial state and passes the work onto <code>parseSourceFileWorker</code> function.</p>
<h4 id="parsesourcefileworker"><a class="header" href="#parsesourcefileworker"><code>parseSourceFileWorker</code></a></h4>
<p>Starts by creating a <code>SourceFile</code> AST node. Then it goes into parsing source code starting from the <code>parseStatements</code> function. Once that returns, it then completes the <code>SourceFile</code> node with additional information such as its <code>nodeCount</code>, <code>identifierCount</code> and such.</p>
<h4 id="parsestatements"><a class="header" href="#parsestatements"><code>parseStatements</code></a></h4>
<p>One of the most significant <code>parseFoo</code> style functions (a concept we cover next). It switches by the current <code>token</code> returned from the scanner. E.g. if the current token is a <code>SemicolonToken</code> it will call out to <code>parseEmptyStatement</code> to create an AST node for an empty statement.</p>
<h3 id="node-creation"><a class="header" href="#node-creation">Node creation</a></h3>
<p>The parser has a bunch of <code>parserFoo</code> functions with bodies that create <code>Foo</code> nodes. These are generally called (from other parser functions) at a time where a <code>Foo</code> node is expected. A typical sample of this process is the <code>parseEmptyStatement()</code> function which is used to parse out empty statements like <code>;;;;;;</code>. Here is the function in its entirety</p>
<pre><code class="language-typescript">function parseEmptyStatement(): Statement {
    let node = &lt;Statement&gt;createNode(SyntaxKind.EmptyStatement);
    parseExpected(SyntaxKind.SemicolonToken);
    return finishNode(node);
}
</code></pre>
<p>It shows three critical functions <code>createNode</code>, <code>parseExpected</code> and <code>finishNode</code>.</p>
<h4 id="createnode"><a class="header" href="#createnode"><code>createNode</code></a></h4>
<p>The parser’s <code>createNode</code> function <code>function createNode(kind: SyntaxKind, pos?: number): Node</code> is responsible for creating a Node, setting up its <code>SyntaxKind</code> as passed in, and set the initial position if passed in (or use the position from the current scanner state).</p>
<h4 id="parseexpected"><a class="header" href="#parseexpected"><code>parseExpected</code></a></h4>
<p>The parser’s <code>parseExpected</code> function <code>function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage): boolean</code> will check that the current token in the parser state matches the desired <code>SyntaxKind</code>. If not it will either report the <code>diagnosticMessage</code> sent in or create a generic one of the form <code>foo expected</code>. It internally uses the <code>parseErrorAtPosition</code> function (which uses the scanning positions) to give good error reporting.</p>
<h3 id="finishnode"><a class="header" href="#finishnode"><code>finishNode</code></a></h3>
<p>The parser’s <code>finishNode</code> function <code>function finishNode&lt;T extends Node&gt;(node: T, end?: number): T</code> sets up the <code>end</code> position for the node and additional useful stuff like the <code>parserContextFlags</code> it was parsed under as well as if there were any errors before parsing this node (if there were then we cannot reuse this AST node in incremental parsing).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="binder"><a class="header" href="#binder">Binder</a></h2>
<p>Most JavaScript transpilers out there are simpler than TypeScript because they provide little in the way of code analysis. The typical JavaScript transpilers only have the following flow:</p>
<pre><code class="language-typescript">SourceCode ~~Scanner~~&gt; Tokens ~~Parser~~&gt; AST ~~Emitter~~&gt; JavaScript
</code></pre>
<p>While the above architecture is true as a simplified understanding of TypeScript js generation, a key feature of TypeScript is its <em>Semantic</em> system. In order to assist type checking (performed by the <code>checker</code>), the <code>binder</code> (in <code>binder.ts</code>) is used to connect the various parts of the source code into a coherent type system that can then be used by the <code>checker</code>. The main responsibility of the binder is to create <em>Symbols</em>.</p>
<h3 id="symbol"><a class="header" href="#symbol">Symbol</a></h3>
<p>Symbols connect declaration nodes in the AST to other declarations contributing to the same entity. Symbols are the basic building blocks of the Semantic system. The symbol constructor is defined in <code>core.ts</code> (and <code>binder</code> actually uses the <code>objectAllocator.getSymbolConstructor</code> to get its hands on it). Here is the symbol constructor:</p>
<pre><code class="language-typescript">function Symbol(flags: SymbolFlags, name: string) {
    this.flags = flags;
    this.name = name;
    this.declarations = undefined;
}
</code></pre>
<p><code>SymbolFlags</code> is a flag enum and is really used to identify additional classifications of the symbol (e.g. variable scope flags <code>FunctionScopedVariable</code> or <code>BlockScopedVariable</code> among others)</p>
<h3 id="usage-by-checker"><a class="header" href="#usage-by-checker">Usage by Checker</a></h3>
<p>The <code>binder</code> is actually used internally by the type <code>checker</code> which in turn is used by the <code>program</code>. The simplified call stack looks like:</p>
<pre><code>program.getTypeChecker -&gt;
    ts.createTypeChecker (in checker)-&gt;
        initializeTypeChecker (in checker) -&gt;
            for each SourceFile `ts.bindSourceFile` (in binder)
            // followed by
            for each SourceFile `ts.mergeSymbolTable` (in checker)
</code></pre>
<p>The unit of work for the binder is a SourceFile. The <code>binder.ts</code> is driven by <code>checker.ts</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="binder-function"><a class="header" href="#binder-function">Binder function</a></h3>
<p>Two critical binder functions are <code>bindSourceFile</code> and <code>mergeSymbolTable</code>. We will take a look at these next.</p>
<h4 id="bindsourcefile"><a class="header" href="#bindsourcefile"><code>bindSourceFile</code></a></h4>
<p>Basically checks if <code>file.locals</code> is defined, if not it hands over to (a local function) <code>bind</code>.</p>
<p>Note: <code>locals</code> is defined on <code>Node</code> and is of type <code>SymbolTable</code>. Note that <code>SourceFile</code> is also a <code>Node</code> (in fact a root node in the AST).</p>
<p>TIP: local functions are used heavily within the TypeScript compiler. A local function very likely uses variables from the parent function (captured by closure). In the case of <code>bind</code> (a local function within <code>bindSourceFile</code>) it (or a function it calls) will setup the <code>symbolCount</code> and <code>classifiableNames</code> among others, that are then stored on the returned <code>SourceFile</code>.</p>
<h4 id="bind"><a class="header" href="#bind"><code>bind</code></a></h4>
<p>Bind takes any <code>Node</code> (not just <code>SourceFile</code>). First thing it does is assign the <code>node.parent</code> (if <code>parent</code> variable has been setup … which again is something the binder does during its processing within the <code>bindChildren</code> function), then hands off to <code>bindWorker</code> which does the <em>heavy</em> lifting. Finally it calls <code>bindChildren</code> (a function that simply stores the binder state e.g. current <code>parent</code> within its function local vars, then calls <code>bind</code> on each child, and then restores the binder state). Now let’s look at <code>bindWorker</code> which is the more interesting function.</p>
<h4 id="bindworker"><a class="header" href="#bindworker"><code>bindWorker</code></a></h4>
<p>This function switches on <code>node.kind</code> (of type <code>SyntaxKind</code>) and delegates work to the appropriate <code>bindFoo</code> function (also defined within <code>binder.ts</code>). For example if the <code>node</code> is a <code>SourceFile</code> it calls (eventually and only if its an external file module) <code>bindAnonymousDeclaration</code></p>
<h4 id="bindfoo-functions"><a class="header" href="#bindfoo-functions"><code>bindFoo</code> functions</a></h4>
<p>There are a few patterns common to <code>bindFoo</code> functions as well as some utility functions that these use. One function that is almost always used is the <code>createSymbol</code> function. It is presented in its entirety below:</p>
<pre><code class="language-typescript">function createSymbol(flags: SymbolFlags, name: string): Symbol {
    symbolCount++;
    return new Symbol(flags, name);
}
</code></pre>
<p>As you can see it is simply keeping the <code>symbolCount</code> (a local to <code>bindSourceFile</code>) up to date and creating the symbol with the specified parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="symbols-and-declarations"><a class="header" href="#symbols-and-declarations">Symbols and Declarations</a></h3>
<p>Linking between a <code>node</code> and a <code>symbol</code> is performed by a few functions. One function that is used to bind the <code>SourceFile</code> node to the source file Symbol (in case of an external module) is the <code>addDeclarationToSymbol</code> function</p>
<p>Note : the <code>Symbol</code> for an external module source file is setup as <code>flags : SymbolFlags.ValueModule</code> and <code>name: '&quot;' + removeFileExtension(file.fileName) + '&quot;'</code>).</p>
<pre><code class="language-typescript">function addDeclarationToSymbol(symbol: Symbol, node: Declaration, symbolFlags: SymbolFlags) {
    symbol.flags |= symbolFlags;

    node.symbol = symbol;

    if (!symbol.declarations) {
        symbol.declarations = [];
    }
    symbol.declarations.push(node);

    if (symbolFlags &amp; SymbolFlags.HasExports &amp;&amp; !symbol.exports) {
        symbol.exports = {};
    }

    if (symbolFlags &amp; SymbolFlags.HasMembers &amp;&amp; !symbol.members) {
        symbol.members = {};
    }

    if (symbolFlags &amp; SymbolFlags.Value &amp;&amp; !symbol.valueDeclaration) {
        symbol.valueDeclaration = node;
    }
}
</code></pre>
<p>The important linking portions:</p>
<ul>
<li>Creates a link to the Symbol from the AST node (<code>node.symbol</code>).</li>
<li>Adds the node as <em>one of</em> the declarations of the Symbol (<code>symbol.declarations</code>).</li>
</ul>
<h4 id="declaration"><a class="header" href="#declaration">Declaration</a></h4>
<p>Declaration is just a <code>node</code> with an optional name. In <code>types.ts</code></p>
<pre><code class="language-typescript">interface Declaration extends Node {
    _declarationBrand: any;
    name?: DeclarationName;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="container"><a class="header" href="#container">Container</a></h3>
<p>An AST node can be a container. This determines the kinds of <code>SymbolTables</code> the Node and associated Symbol will have. Container is an abstract concept (i.e. has no associated data structure). The concept is driven by a few things, one being the <code>ContainerFlags</code> enum. The function <code>getContainerFlags</code> (in <code>binder.ts</code>) drives this flag and is presented below:</p>
<pre><code class="language-typescript">function getContainerFlags(node: Node): ContainerFlags {
    switch (node.kind) {
        case SyntaxKind.ClassExpression:
        case SyntaxKind.ClassDeclaration:
        case SyntaxKind.InterfaceDeclaration:
        case SyntaxKind.EnumDeclaration:
        case SyntaxKind.TypeLiteral:
        case SyntaxKind.ObjectLiteralExpression:
            return ContainerFlags.IsContainer;

        case SyntaxKind.CallSignature:
        case SyntaxKind.ConstructSignature:
        case SyntaxKind.IndexSignature:
        case SyntaxKind.MethodDeclaration:
        case SyntaxKind.MethodSignature:
        case SyntaxKind.FunctionDeclaration:
        case SyntaxKind.Constructor:
        case SyntaxKind.GetAccessor:
        case SyntaxKind.SetAccessor:
        case SyntaxKind.FunctionType:
        case SyntaxKind.ConstructorType:
        case SyntaxKind.FunctionExpression:
        case SyntaxKind.ArrowFunction:
        case SyntaxKind.ModuleDeclaration:
        case SyntaxKind.SourceFile:
        case SyntaxKind.TypeAliasDeclaration:
            return ContainerFlags.IsContainerWithLocals;

        case SyntaxKind.CatchClause:
        case SyntaxKind.ForStatement:
        case SyntaxKind.ForInStatement:
        case SyntaxKind.ForOfStatement:
        case SyntaxKind.CaseBlock:
            return ContainerFlags.IsBlockScopedContainer;

        case SyntaxKind.Block:
            // do not treat blocks directly inside a function as a block-scoped-container.
            // Locals that reside in this block should go to the function locals. Otherwise 'x'
            // would not appear to be a redeclaration of a block scoped local in the following
            // example:
            //
            //      function foo() {
            //          var x;
            //          let x;
            //      }
            //
            // If we placed 'var x' into the function locals and 'let x' into the locals of
            // the block, then there would be no collision.
            //
            // By not creating a new block-scoped-container here, we ensure that both 'var x'
            // and 'let x' go into the Function-container's locals, and we do get a collision
            // conflict.
            return isFunctionLike(node.parent) ? ContainerFlags.None : ContainerFlags.IsBlockScopedContainer;
    }

    return ContainerFlags.None;
}
</code></pre>
<p>It is <em>only</em> invoked from the binder’s <code>bindChildren</code> function which sets up a node as a <code>container</code> and/or a <code>blockScopedContainer</code> depending upon the evaluation of the <code>getContainerFlags</code> function. The function <code>bindChildren</code> is presented below:</p>
<pre><code class="language-typescript">// All container nodes are kept on a linked list in declaration order. This list is used by
// the getLocalNameOfContainer function in the type checker to validate that the local name
// used for a container is unique.
function bindChildren(node: Node) {
    // Before we recurse into a node's children, we first save the existing parent, container
    // and block-container.  Then after we pop out of processing the children, we restore
    // these saved values.
    let saveParent = parent;
    let saveContainer = container;
    let savedBlockScopeContainer = blockScopeContainer;

    // This node will now be set as the parent of all of its children as we recurse into them.
    parent = node;

    // Depending on what kind of node this is, we may have to adjust the current container
    // and block-container.   If the current node is a container, then it is automatically
    // considered the current block-container as well.  Also, for containers that we know
    // may contain locals, we proactively initialize the .locals field. We do this because
    // it's highly likely that the .locals will be needed to place some child in (for example,
    // a parameter, or variable declaration).
    //
    // However, we do not proactively create the .locals for block-containers because it's
    // totally normal and common for block-containers to never actually have a block-scoped
    // variable in them.  We don't want to end up allocating an object for every 'block' we
    // run into when most of them won't be necessary.
    //
    // Finally, if this is a block-container, then we clear out any existing .locals object
    // it may contain within it.  This happens in incremental scenarios.  Because we can be
    // reusing a node from a previous compilation, that node may have had 'locals' created
    // for it.  We must clear this so we don't accidentally move any stale data forward from
    // a previous compilation.
    let containerFlags = getContainerFlags(node);
    if (containerFlags &amp; ContainerFlags.IsContainer) {
        container = blockScopeContainer = node;

        if (containerFlags &amp; ContainerFlags.HasLocals) {
            container.locals = {};
        }

        addToContainerChain(container);
    }

    else if (containerFlags &amp; ContainerFlags.IsBlockScopedContainer) {
        blockScopeContainer = node;
        blockScopeContainer.locals = undefined;
    }

    forEachChild(node, bind);

    container = saveContainer;
    parent = saveParent;
    blockScopeContainer = savedBlockScopeContainer;
}
</code></pre>
<p>As you might recall from the section on binder functions : <code>bindChildren</code> is called from the <code>bind</code> function. So we have the recursive binding setup : <code>bind</code> calls <code>bindChildren</code> calls <code>bind</code> for each child.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="symboltable"><a class="header" href="#symboltable">SymbolTable</a></h3>
<p>SymbolTable is implemented as a simple HashMap. Here is the interface (<code>types.ts</code>):</p>
<pre><code class="language-typescript">interface SymbolTable {
    [index: string]: Symbol;
}
</code></pre>
<p>SymbolTables are initialized by binding. There are a few SymbolTables used by the compiler:</p>
<p>On <code>Node</code>:</p>
<pre><code class="language-typescript">locals?: SymbolTable;                   // Locals associated with node
</code></pre>
<p>On <code>Symbol</code>:</p>
<pre><code class="language-typescript">members?: SymbolTable;                  // Class, interface or literal instance members
exports?: SymbolTable;                  // Module exports
</code></pre>
<p>Note: We saw <code>locals</code> getting initialized (to <code>{}</code>) by <code>bindChildren</code> based on <code>ContainerFlags</code>.</p>
<h4 id="symboltable-population"><a class="header" href="#symboltable-population">SymbolTable population</a></h4>
<p>SymbolTables are populated with <code>Symbols</code> primarily by a call to <code>declareSymbol</code>. This function is presented below in entirety:</p>
<pre><code class="language-typescript">/**
 * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.
 * @param symbolTable - The symbol table which node will be added to.
 * @param parent - node's parent declaration.
 * @param node - The declaration to be added to the symbol table
 * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)
 * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.
 */
function declareSymbol(symbolTable: SymbolTable, parent: Symbol, node: Declaration, includes: SymbolFlags, excludes: SymbolFlags): Symbol {
    Debug.assert(!hasDynamicName(node));

    // The exported symbol for an export default function/class node is always named &quot;default&quot;
    let name = node.flags &amp; NodeFlags.Default &amp;&amp; parent ? &quot;default&quot; : getDeclarationName(node);

    let symbol: Symbol;
    if (name !== undefined) {

        // Check and see if the symbol table already has a symbol with this name.  If not,
        // create a new symbol with this name and add it to the table.  Note that we don't
        // give the new symbol any flags *yet*.  This ensures that it will not conflict
        // with the 'excludes' flags we pass in.
        //
        // If we do get an existing symbol, see if it conflicts with the new symbol we're
        // creating.  For example, a 'var' symbol and a 'class' symbol will conflict within
        // the same symbol table.  If we have a conflict, report the issue on each
        // declaration we have for this symbol, and then create a new symbol for this
        // declaration.
        //
        // If we created a new symbol, either because we didn't have a symbol with this name
        // in the symbol table, or we conflicted with an existing symbol, then just add this
        // node as the sole declaration of the new symbol.
        //
        // Otherwise, we'll be merging into a compatible existing symbol (for example when
        // you have multiple 'vars' with the same name in the same container).  In this case
        // just add this node into the declarations list of the symbol.
        symbol = hasProperty(symbolTable, name)
            ? symbolTable[name]
            : (symbolTable[name] = createSymbol(SymbolFlags.None, name));

        if (name &amp;&amp; (includes &amp; SymbolFlags.Classifiable)) {
            classifiableNames[name] = name;
        }

        if (symbol.flags &amp; excludes) {
            if (node.name) {
                node.name.parent = node;
            }

            // Report errors every position with duplicate declaration
            // Report errors on previous encountered declarations
            let message = symbol.flags &amp; SymbolFlags.BlockScopedVariable
                ? Diagnostics.Cannot_redeclare_block_scoped_variable_0
                : Diagnostics.Duplicate_identifier_0;
            forEach(symbol.declarations, declaration =&gt; {
                file.bindDiagnostics.push(createDiagnosticForNode(declaration.name || declaration, message, getDisplayName(declaration)));
            });
            file.bindDiagnostics.push(createDiagnosticForNode(node.name || node, message, getDisplayName(node)));

            symbol = createSymbol(SymbolFlags.None, name);
        }
    }
    else {
        symbol = createSymbol(SymbolFlags.None, &quot;__missing&quot;);
    }

    addDeclarationToSymbol(symbol, node, includes);
    symbol.parent = parent;

    return symbol;
}
</code></pre>
<p>Which SymbolTable is populated is driven by the first argument to this function. e.g. when adding a declaration to a <em>container</em> of kind <code>SyntaxKind.ClassDeclaration</code> or <code>SyntaxKind.ClassExpression</code> the function <code>declareClassMember</code> will get called which has the following code:</p>
<pre><code class="language-typescript">function declareClassMember(node: Declaration, symbolFlags: SymbolFlags, symbolExcludes: SymbolFlags) {
    return node.flags &amp; NodeFlags.Static
        ? declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes)
        : declareSymbol(container.symbol.members, container.symbol, node, symbolFlags, symbolExcludes);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="binder-error-reporting"><a class="header" href="#binder-error-reporting">Binder Error Reporting</a></h3>
<p>Binding errors are added to the sourceFile’s list of <code>bindDiagnostics</code>.</p>
<p>An example error detected during binding is the use of <code>eval</code> or <code>arguments</code> as a variable name in <code>use strict</code> scenario. The relevant code is presented in its entirety below (<code>checkStrictModeEvalOrArguments</code> is called from multiple places, call stacks originating from <code>bindWorker</code> which calls different functions for different node <code>SyntaxKind</code>):</p>
<pre><code class="language-typescript">function checkStrictModeEvalOrArguments(contextNode: Node, name: Node) {
    if (name &amp;&amp; name.kind === SyntaxKind.Identifier) {
        let identifier = &lt;Identifier&gt;name;
        if (isEvalOrArgumentsIdentifier(identifier)) {
            // We check first if the name is inside class declaration or class expression; if so give explicit message
            // otherwise report generic error message.
            let span = getErrorSpanForNode(file, name);
            file.bindDiagnostics.push(createFileDiagnostic(file, span.start, span.length,
                getStrictModeEvalOrArgumentsMessage(contextNode), identifier.text));
        }
    }
}

function isEvalOrArgumentsIdentifier(node: Node): boolean {
    return node.kind === SyntaxKind.Identifier &amp;&amp;
        ((&lt;Identifier&gt;node).text === &quot;eval&quot; || (&lt;Identifier&gt;node).text === &quot;arguments&quot;);
}

function getStrictModeEvalOrArgumentsMessage(node: Node) {
    // Provide specialized messages to help the user understand why we think they're in
    // strict mode.
    if (getContainingClass(node)) {
        return Diagnostics.Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode;
    }

    if (file.externalModuleIndicator) {
        return Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode;
    }

    return Diagnostics.Invalid_use_of_0_in_strict_mode;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="checker"><a class="header" href="#checker">Checker</a></h2>
<p>Like we mentioned before <em>checker</em> is the thing that makes TypeScript uniquely more powerful than <em>just another JavaScript transpiler</em>. The checker is located in <code>checker.ts</code> and at this moment it is 23k+ lines of TypeScript (largest part of the compiler).</p>
<h3 id="usage-by-program-1"><a class="header" href="#usage-by-program-1">Usage by Program</a></h3>
<p>The <code>checker</code> is initialized by <code>program</code>. The following is a sampling of the call stack (we showed the same one when looking at <code>binder</code>):</p>
<pre><code>program.getTypeChecker -&gt;
    ts.createTypeChecker (in checker)-&gt;
        initializeTypeChecker (in checker) -&gt;
            for each SourceFile `ts.bindSourceFile` (in binder)
            // followed by
            for each SourceFile `ts.mergeSymbolTable` (in checker)
</code></pre>
<h3 id="association-with-emitter"><a class="header" href="#association-with-emitter">Association with Emitter</a></h3>
<p>True type checking happens once a call is made to <code>getDiagnostics</code>. This function is called e.g. once a request is made to <code>Program.emit</code>, in which case the checker returns an <code>EmitResolver</code> (program calls the checkers <code>getEmitResolver</code> function) which is just a set of functions local to <code>createTypeChecker</code>. We will mention this again when we look at the emitter.</p>
<p>Here is the call stack right down to <code>checkSourceFile</code> (a function local to <code>createTypeChecker</code>).</p>
<pre><code>program.emit -&gt;
    emitWorker (program local) -&gt;
        createTypeChecker.getEmitResolver -&gt;
            // First call the following functions local to createTypeChecker
            call getDiagnostics -&gt;
                getDiagnosticsWorker -&gt;
                    checkSourceFile

            // then
            return resolver
            (already initialized in createTypeChecker using a call to local createResolver())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="global-namespace-merging"><a class="header" href="#global-namespace-merging">Global Namespace Merging</a></h3>
<p>Within <code>initializeTypeChecker</code> the following code exists:</p>
<pre><code class="language-typescript">// Initialize global symbol table
forEach(host.getSourceFiles(), file =&gt; {
    if (!isExternalModule(file)) {
        mergeSymbolTable(globals, file.locals);
    }
});
</code></pre>
<p>Which basically merges all the <code>global</code> symbols into the <code>let globals: SymbolTable = {};</code> (in <code>createTypeChecker</code>) SymbolTable. <code>mergeSymbolTable</code> primarily calls <code>mergeSymbol</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="checker-error-reporting"><a class="header" href="#checker-error-reporting">Checker error reporting</a></h3>
<p>The checker uses the local <code>error</code> function to report errors. Here is the function:</p>
<pre><code class="language-typescript">function error(location: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {
    let diagnostic = location
        ? createDiagnosticForNode(location, message, arg0, arg1, arg2)
        : createCompilerDiagnostic(message, arg0, arg1, arg2);
    diagnostics.add(diagnostic);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="emitter"><a class="header" href="#emitter">Emitter</a></h2>
<p>There are two <code>emitters</code> provided with the TypeScript compiler:</p>
<ul>
<li><code>emitter.ts</code>: this is the emitter you are most likely to be interested in. Its the TS -&gt; JavaScript emitter.</li>
<li><code>declarationEmitter.ts</code>: this is the emitter used to create a <em>declaration file</em> (a <code>.d.ts</code>) for a <em>TypeScript source file</em> (a <code>.ts</code> file).</li>
</ul>
<p>We will look at <code>emitter.ts</code> in this section.</p>
<h3 id="usage-by-program-2"><a class="header" href="#usage-by-program-2">Usage by <code>program</code></a></h3>
<p>Program provides an <code>emit</code> function. This function primarily delegates to <code>emitFiles</code> function in <code>emitter.ts</code>. Here is the call stack:</p>
<pre><code>Program.emit -&gt;
    `emitWorker` (local in program.ts createProgram) -&gt;
        `emitFiles` (function in emitter.ts)
</code></pre>
<p>One thing that the <code>emitWorker</code> provides to the emitter (via an argument to <code>emitFiles</code>) is an <code>EmitResolver</code>. <code>EmitResolver</code> is provided by the program’s TypeChecker, basically it is a subset of <em>local</em> functions from <code>createChecker</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="emitfiles"><a class="header" href="#emitfiles"><code>emitFiles</code></a></h3>
<p>Defined in <code>emitter.ts</code> here is the function signature:</p>
<pre><code class="language-typescript">// targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature
export function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile?: SourceFile): EmitResult {
</code></pre>
<p><code>EmitHost</code> is just a simplified (as in narrowed down) version of <code>CompilerHost</code> (and is at runtime actually a <code>CompilerHost</code> for many use cases).</p>
<p>The most interesting call stack from <code>emitFiles</code> is the following:</p>
<pre><code>emitFiles -&gt;
    emitFile(jsFilePath, targetSourceFile) -&gt;
        emitJavaScript(jsFilePath, targetSourceFile);
</code></pre>
<h3 id="emitjavascript"><a class="header" href="#emitjavascript"><code>emitJavaScript</code></a></h3>
<p>There is a lot of good comments in this function so we present it below :</p>
<pre><code class="language-typescript">function emitJavaScript(jsFilePath: string, root?: SourceFile) {
    let writer = createTextWriter(newLine);
    let write = writer.write;
    let writeTextOfNode = writer.writeTextOfNode;
    let writeLine = writer.writeLine;
    let increaseIndent = writer.increaseIndent;
    let decreaseIndent = writer.decreaseIndent;

    let currentSourceFile: SourceFile;
    // name of an exporter function if file is a System external module
    // System.register([...], function (&lt;exporter&gt;) {...})
    // exporting in System modules looks like:
    // export var x; ... x = 1
    // =&gt;
    // var x;... exporter(&quot;x&quot;, x = 1)
    let exportFunctionForFile: string;

    let generatedNameSet: Map&lt;string&gt; = {};
    let nodeToGeneratedName: string[] = [];
    let computedPropertyNamesToGeneratedNames: string[];

    let extendsEmitted = false;
    let decorateEmitted = false;
    let paramEmitted = false;
    let awaiterEmitted = false;
    let tempFlags = 0;
    let tempVariables: Identifier[];
    let tempParameters: Identifier[];
    let externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];
    let exportSpecifiers: Map&lt;ExportSpecifier[]&gt;;
    let exportEquals: ExportAssignment;
    let hasExportStars: boolean;

    /** Write emitted output to disk */
    let writeEmittedFiles = writeJavaScriptFile;

    let detachedCommentsInfo: { nodePos: number; detachedCommentEndPos: number }[];

    let writeComment = writeCommentRange;

    /** Emit a node */
    let emit = emitNodeWithoutSourceMap;

    /** Called just before starting emit of a node */
    let emitStart = function (node: Node) { };

    /** Called once the emit of the node is done */
    let emitEnd = function (node: Node) { };

    /** Emit the text for the given token that comes after startPos
      * This by default writes the text provided with the given tokenKind
      * but if optional emitFn callback is provided the text is emitted using the callback instead of default text
      * @param tokenKind the kind of the token to search and emit
      * @param startPos the position in the source to start searching for the token
      * @param emitFn if given will be invoked to emit the text instead of actual token emit */
    let emitToken = emitTokenText;

    /** Called to before starting the lexical scopes as in function/class in the emitted code because of node
      * @param scopeDeclaration node that starts the lexical scope
      * @param scopeName Optional name of this scope instead of deducing one from the declaration node */
    let scopeEmitStart = function(scopeDeclaration: Node, scopeName?: string) { };

    /** Called after coming out of the scope */
    let scopeEmitEnd = function() { };

    /** Sourcemap data that will get encoded */
    let sourceMapData: SourceMapData;

    if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {
        initializeEmitterWithSourceMaps();
    }

    if (root) {
        // Do not call emit directly. It does not set the currentSourceFile.
        emitSourceFile(root);
    }
    else {
        forEach(host.getSourceFiles(), sourceFile =&gt; {
            if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                emitSourceFile(sourceFile);
            }
        });
    }

    writeLine();
    writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);
    return;

    /// BUNCH OF LOCAL FUNCTIONS
}
</code></pre>
<p>Basically it sets up a bunch of locals (these functions form the <em>bulk</em> of <code>emitter.ts</code>) and then hands off to a local function <code>emitSourceFile</code> which kicks off the emit. The <code>emitSourceFile</code> function just sets up the <code>currentSourceFile</code> and in turn hands off to a local <code>emit</code> function.</p>
<pre><code class="language-typescript">function emitSourceFile(sourceFile: SourceFile): void {
    currentSourceFile = sourceFile;
    exportFunctionForFile = undefined;
    emit(sourceFile);
}
</code></pre>
<p>The <code>emit</code> function handles <em>comment</em> emit + <em>actual JavaScript</em> emit. The <em>actual JavaScript</em> emit is the job of <code>emitJavaScriptWorker</code> function.</p>
<h3 id="emitjavascriptworker"><a class="header" href="#emitjavascriptworker"><code>emitJavaScriptWorker</code></a></h3>
<p>The complete function:</p>
<pre><code class="language-typescript">function emitJavaScriptWorker(node: Node) {
    // Check if the node can be emitted regardless of the ScriptTarget
    switch (node.kind) {
        case SyntaxKind.Identifier:
            return emitIdentifier(&lt;Identifier&gt;node);
        case SyntaxKind.Parameter:
            return emitParameter(&lt;ParameterDeclaration&gt;node);
        case SyntaxKind.MethodDeclaration:
        case SyntaxKind.MethodSignature:
            return emitMethod(&lt;MethodDeclaration&gt;node);
        case SyntaxKind.GetAccessor:
        case SyntaxKind.SetAccessor:
            return emitAccessor(&lt;AccessorDeclaration&gt;node);
        case SyntaxKind.ThisKeyword:
            return emitThis(node);
        case SyntaxKind.SuperKeyword:
            return emitSuper(node);
        case SyntaxKind.NullKeyword:
            return write(&quot;null&quot;);
        case SyntaxKind.TrueKeyword:
            return write(&quot;true&quot;);
        case SyntaxKind.FalseKeyword:
            return write(&quot;false&quot;);
        case SyntaxKind.NumericLiteral:
        case SyntaxKind.StringLiteral:
        case SyntaxKind.RegularExpressionLiteral:
        case SyntaxKind.NoSubstitutionTemplateLiteral:
        case SyntaxKind.TemplateHead:
        case SyntaxKind.TemplateMiddle:
        case SyntaxKind.TemplateTail:
            return emitLiteral(&lt;LiteralExpression&gt;node);
        case SyntaxKind.TemplateExpression:
            return emitTemplateExpression(&lt;TemplateExpression&gt;node);
        case SyntaxKind.TemplateSpan:
            return emitTemplateSpan(&lt;TemplateSpan&gt;node);
        case SyntaxKind.JsxElement:
        case SyntaxKind.JsxSelfClosingElement:
            return emitJsxElement(&lt;JsxElement|JsxSelfClosingElement&gt;node);
        case SyntaxKind.JsxText:
            return emitJsxText(&lt;JsxText&gt;node);
        case SyntaxKind.JsxExpression:
            return emitJsxExpression(&lt;JsxExpression&gt;node);
        case SyntaxKind.QualifiedName:
            return emitQualifiedName(&lt;QualifiedName&gt;node);
        case SyntaxKind.ObjectBindingPattern:
            return emitObjectBindingPattern(&lt;BindingPattern&gt;node);
        case SyntaxKind.ArrayBindingPattern:
            return emitArrayBindingPattern(&lt;BindingPattern&gt;node);
        case SyntaxKind.BindingElement:
            return emitBindingElement(&lt;BindingElement&gt;node);
        case SyntaxKind.ArrayLiteralExpression:
            return emitArrayLiteral(&lt;ArrayLiteralExpression&gt;node);
        case SyntaxKind.ObjectLiteralExpression:
            return emitObjectLiteral(&lt;ObjectLiteralExpression&gt;node);
        case SyntaxKind.PropertyAssignment:
            return emitPropertyAssignment(&lt;PropertyDeclaration&gt;node);
        case SyntaxKind.ShorthandPropertyAssignment:
            return emitShorthandPropertyAssignment(&lt;ShorthandPropertyAssignment&gt;node);
        case SyntaxKind.ComputedPropertyName:
            return emitComputedPropertyName(&lt;ComputedPropertyName&gt;node);
        case SyntaxKind.PropertyAccessExpression:
            return emitPropertyAccess(&lt;PropertyAccessExpression&gt;node);
        case SyntaxKind.ElementAccessExpression:
            return emitIndexedAccess(&lt;ElementAccessExpression&gt;node);
        case SyntaxKind.CallExpression:
            return emitCallExpression(&lt;CallExpression&gt;node);
        case SyntaxKind.NewExpression:
            return emitNewExpression(&lt;NewExpression&gt;node);
        case SyntaxKind.TaggedTemplateExpression:
            return emitTaggedTemplateExpression(&lt;TaggedTemplateExpression&gt;node);
        case SyntaxKind.TypeAssertionExpression:
            return emit((&lt;TypeAssertion&gt;node).expression);
        case SyntaxKind.AsExpression:
            return emit((&lt;AsExpression&gt;node).expression);
        case SyntaxKind.ParenthesizedExpression:
            return emitParenExpression(&lt;ParenthesizedExpression&gt;node);
        case SyntaxKind.FunctionDeclaration:
        case SyntaxKind.FunctionExpression:
        case SyntaxKind.ArrowFunction:
            return emitFunctionDeclaration(&lt;FunctionLikeDeclaration&gt;node);
        case SyntaxKind.DeleteExpression:
            return emitDeleteExpression(&lt;DeleteExpression&gt;node);
        case SyntaxKind.TypeOfExpression:
            return emitTypeOfExpression(&lt;TypeOfExpression&gt;node);
        case SyntaxKind.VoidExpression:
            return emitVoidExpression(&lt;VoidExpression&gt;node);
        case SyntaxKind.AwaitExpression:
            return emitAwaitExpression(&lt;AwaitExpression&gt;node);
        case SyntaxKind.PrefixUnaryExpression:
            return emitPrefixUnaryExpression(&lt;PrefixUnaryExpression&gt;node);
        case SyntaxKind.PostfixUnaryExpression:
            return emitPostfixUnaryExpression(&lt;PostfixUnaryExpression&gt;node);
        case SyntaxKind.BinaryExpression:
            return emitBinaryExpression(&lt;BinaryExpression&gt;node);
        case SyntaxKind.ConditionalExpression:
            return emitConditionalExpression(&lt;ConditionalExpression&gt;node);
        case SyntaxKind.SpreadElementExpression:
            return emitSpreadElementExpression(&lt;SpreadElementExpression&gt;node);
        case SyntaxKind.YieldExpression:
            return emitYieldExpression(&lt;YieldExpression&gt;node);
        case SyntaxKind.OmittedExpression:
            return;
        case SyntaxKind.Block:
        case SyntaxKind.ModuleBlock:
            return emitBlock(&lt;Block&gt;node);
        case SyntaxKind.VariableStatement:
            return emitVariableStatement(&lt;VariableStatement&gt;node);
        case SyntaxKind.EmptyStatement:
            return write(&quot;;&quot;);
        case SyntaxKind.ExpressionStatement:
            return emitExpressionStatement(&lt;ExpressionStatement&gt;node);
        case SyntaxKind.IfStatement:
            return emitIfStatement(&lt;IfStatement&gt;node);
        case SyntaxKind.DoStatement:
            return emitDoStatement(&lt;DoStatement&gt;node);
        case SyntaxKind.WhileStatement:
            return emitWhileStatement(&lt;WhileStatement&gt;node);
        case SyntaxKind.ForStatement:
            return emitForStatement(&lt;ForStatement&gt;node);
        case SyntaxKind.ForOfStatement:
        case SyntaxKind.ForInStatement:
            return emitForInOrForOfStatement(&lt;ForInStatement&gt;node);
        case SyntaxKind.ContinueStatement:
        case SyntaxKind.BreakStatement:
            return emitBreakOrContinueStatement(&lt;BreakOrContinueStatement&gt;node);
        case SyntaxKind.ReturnStatement:
            return emitReturnStatement(&lt;ReturnStatement&gt;node);
        case SyntaxKind.WithStatement:
            return emitWithStatement(&lt;WithStatement&gt;node);
        case SyntaxKind.SwitchStatement:
            return emitSwitchStatement(&lt;SwitchStatement&gt;node);
        case SyntaxKind.CaseClause:
        case SyntaxKind.DefaultClause:
            return emitCaseOrDefaultClause(&lt;CaseOrDefaultClause&gt;node);
        case SyntaxKind.LabeledStatement:
            return emitLabelledStatement(&lt;LabeledStatement&gt;node);
        case SyntaxKind.ThrowStatement:
            return emitThrowStatement(&lt;ThrowStatement&gt;node);
        case SyntaxKind.TryStatement:
            return emitTryStatement(&lt;TryStatement&gt;node);
        case SyntaxKind.CatchClause:
            return emitCatchClause(&lt;CatchClause&gt;node);
        case SyntaxKind.DebuggerStatement:
            return emitDebuggerStatement(node);
        case SyntaxKind.VariableDeclaration:
            return emitVariableDeclaration(&lt;VariableDeclaration&gt;node);
        case SyntaxKind.ClassExpression:
            return emitClassExpression(&lt;ClassExpression&gt;node);
        case SyntaxKind.ClassDeclaration:
            return emitClassDeclaration(&lt;ClassDeclaration&gt;node);
        case SyntaxKind.InterfaceDeclaration:
            return emitInterfaceDeclaration(&lt;InterfaceDeclaration&gt;node);
        case SyntaxKind.EnumDeclaration:
            return emitEnumDeclaration(&lt;EnumDeclaration&gt;node);
        case SyntaxKind.EnumMember:
            return emitEnumMember(&lt;EnumMember&gt;node);
        case SyntaxKind.ModuleDeclaration:
            return emitModuleDeclaration(&lt;ModuleDeclaration&gt;node);
        case SyntaxKind.ImportDeclaration:
            return emitImportDeclaration(&lt;ImportDeclaration&gt;node);
        case SyntaxKind.ImportEqualsDeclaration:
            return emitImportEqualsDeclaration(&lt;ImportEqualsDeclaration&gt;node);
        case SyntaxKind.ExportDeclaration:
            return emitExportDeclaration(&lt;ExportDeclaration&gt;node);
        case SyntaxKind.ExportAssignment:
            return emitExportAssignment(&lt;ExportAssignment&gt;node);
        case SyntaxKind.SourceFile:
            return emitSourceFileNode(&lt;SourceFile&gt;node);
    }
}
</code></pre>
<p>Recursion is done by simply calling other <code>emitFoo</code> function from these functions as needed e.g. from <code>emitFunctionDeclaration</code> :</p>
<pre><code class="language-typescript">function emitFunctionDeclaration(node: FunctionLikeDeclaration) {
    if (nodeIsMissing(node.body)) {
        return emitOnlyPinnedOrTripleSlashComments(node);
    }

    if (node.kind !== SyntaxKind.MethodDeclaration &amp;&amp; node.kind !== SyntaxKind.MethodSignature) {
        // Methods will emit the comments as part of emitting method declaration
        emitLeadingComments(node);
    }

    // For targeting below es6, emit functions-like declaration including arrow function using function keyword.
    // When targeting ES6, emit arrow function natively in ES6 by omitting function keyword and using fat arrow instead
    if (!shouldEmitAsArrowFunction(node)) {
        if (isES6ExportedDeclaration(node)) {
            write(&quot;export &quot;);
            if (node.flags &amp; NodeFlags.Default) {
                write(&quot;default &quot;);
            }
        }

        write(&quot;function&quot;);
        if (languageVersion &gt;= ScriptTarget.ES6 &amp;&amp; node.asteriskToken) {
            write(&quot;*&quot;);
        }
        write(&quot; &quot;);
    }

    if (shouldEmitFunctionName(node)) {
        emitDeclarationName(node);
    }

    emitSignatureAndBody(node);
    if (languageVersion &lt; ScriptTarget.ES6 &amp;&amp; node.kind === SyntaxKind.FunctionDeclaration &amp;&amp; node.parent === currentSourceFile &amp;&amp; node.name) {
        emitExportMemberAssignments((&lt;FunctionDeclaration&gt;node).name);
    }
    if (node.kind !== SyntaxKind.MethodDeclaration &amp;&amp; node.kind !== SyntaxKind.MethodSignature) {
        emitTrailingComments(node);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="emitter-sourcemaps"><a class="header" href="#emitter-sourcemaps">Emitter SourceMaps</a></h3>
<p>We said that the bulk of the <code>emitter.ts</code> is the local function <code>emitJavaScript</code> (we showed the initialization routine of this function before). It basically sets up a bunch of locals and hits off to <code>emitSourceFile</code>. The following is a revisiting of the function, this time focusing on <code>SourceMap</code> stuff:</p>
<pre><code class="language-typescript">function emitJavaScript(jsFilePath: string, root?: SourceFile) {

    // STUFF ........... removed

    let writeComment = writeCommentRange;

    /** Write emitted output to disk */
    let writeEmittedFiles = writeJavaScriptFile;

    /** Emit a node */
    let emit = emitNodeWithoutSourceMap;

    /** Called just before starting emit of a node */
    let emitStart = function (node: Node) { };

    /** Called once the emit of the node is done */
    let emitEnd = function (node: Node) { };

    /** Emit the text for the given token that comes after startPos
      * This by default writes the text provided with the given tokenKind
      * but if optional emitFn callback is provided the text is emitted using the callback instead of default text
      * @param tokenKind the kind of the token to search and emit
      * @param startPos the position in the source to start searching for the token
      * @param emitFn if given will be invoked to emit the text instead of actual token emit */
    let emitToken = emitTokenText;

    /** Called to before starting the lexical scopes as in function/class in the emitted code because of node
      * @param scopeDeclaration node that starts the lexical scope
      * @param scopeName Optional name of this scope instead of deducing one from the declaration node */
    let scopeEmitStart = function(scopeDeclaration: Node, scopeName?: string) { };

    /** Called after coming out of the scope */
    let scopeEmitEnd = function() { };

    /** Sourcemap data that will get encoded */
    let sourceMapData: SourceMapData;

    if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {
        initializeEmitterWithSourceMaps();
    }

    if (root) {
        // Do not call emit directly. It does not set the currentSourceFile.
        emitSourceFile(root);
    }
    else {
        forEach(host.getSourceFiles(), sourceFile =&gt; {
            if (!isExternalModuleOrDeclarationFile(sourceFile)) {
                emitSourceFile(sourceFile);
            }
        });
    }

    writeLine();
    writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);
    return;

    /// BUNCH OF LOCAL FUNCTIONS
</code></pre>
<p>The important function call here : <code>initializeEmitterWithSourceMaps</code> which is a function local to <code>emitJavaScript</code> that overrides some locals that were already defined here. At the bottom of <code>initializeEmitterWithSourceMaps</code> you will notice the overriding:</p>
<pre><code class="language-typescript">    // end of `initializeEmitterWithSourceMaps`

    writeEmittedFiles = writeJavaScriptAndSourceMapFile;
    emit = emitNodeWithSourceMap;
    emitStart = recordEmitNodeStartSpan;
    emitEnd = recordEmitNodeEndSpan;
    emitToken = writeTextWithSpanRecord;
    scopeEmitStart = recordScopeNameOfNode;
    scopeEmitEnd = recordScopeNameEnd;
    writeComment = writeCommentRangeWithMap;
</code></pre>
<p>This means that the bulk of emitter code can not care about <code>SourceMap</code> and just use these local functions the same way with or without SourceMaps.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>TypeScript is <a href="https://github.com/Microsoft/TypeScript">OSS and on GitHub</a> and the team welcomes community input.</p>
<h3 id="setup-4"><a class="header" href="#setup-4">Setup</a></h3>
<p>Super easy:</p>
<pre><code class="language-bash">git clone https://github.com/Microsoft/TypeScript.git
cd TypeScript
npm install -g jake
npm install
</code></pre>
<h3 id="setup-fork"><a class="header" href="#setup-fork">Setup Fork</a></h3>
<p>You would obviously need to setup Microsoft/TypeScript as an <code>upstream</code> remote and your own <em>fork</em> (use the GitHub <em>fork</em> button) as <code>origin</code>:</p>
<pre><code class="language-bash">git remote rm origin
git remote rm upstream
git remote add upstream https://github.com/Microsoft/TypeScript.git
git remote add origin https://github.com/armanriazi/TypeScript.git
</code></pre>
<p>Additionally I like to work off branches like <code>bas/</code> to have it show up cleaner in the branch listings.</p>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>There are lots of <code>test</code> and <code>build</code> options in their JakeFile. You can run <em>all</em> tests with <code>jake runtests</code></p>
<h3 id="baselines"><a class="header" href="#baselines">Baselines</a></h3>
<p>Baselines are used to manage if there are any changes in the <em>expected</em> output of the TypeScript compiler. Baselines are located in <code>tests/baselines</code>.</p>
<ul>
<li>Reference (<em>expected</em>) baselines: <code>tests/baselines/reference</code></li>
<li>Generated (<em>in this test run</em>) baselines : <code>tests/baselines/local</code> (this folder is in <strong>.gitignore</strong>)</li>
</ul>
<blockquote>
<p>If there are any differences between these folders tests will fail. You can diff the two folders with tools like BeyondCompare or KDiff3.</p>
</blockquote>
<p>If you think these changes in generated files are valid then accept baselines using <code>jake baseline-accept</code>. The changes to <code>reference</code> baselines will now show as a git diff you can commit.</p>
<blockquote>
<p>Note that if you don’t run <em>all</em> tests then use <code>jake baseline-accept[soft]</code> which will only copy over the new files and not delete the whole <code>reference</code> directory.</p>
</blockquote>
<h3 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h3>
<p>There are different categories for different scenarios and even different test infrastructures. Here are a few of these explained.</p>
<h4 id="compiler-tests"><a class="header" href="#compiler-tests">Compiler Tests</a></h4>
<p>These ensure that compiling a file :</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
generates errors as expected</li>
<li><input disabled="" type="checkbox" checked=""/>
generated JS as expected</li>
<li><input disabled="" type="checkbox" checked=""/>
types are identified as expected</li>
<li><input disabled="" type="checkbox" checked=""/>
symbols are identified as expected</li>
</ul>
<p>These expectations are validated using the baselines infrastructure.</p>
<h5 id="creating-a-compiler-test"><a class="header" href="#creating-a-compiler-test">Creating a Compiler Test</a></h5>
<p>Test can be created by adding a new file <code>yourtest.ts</code> to <code>tests/cases/compiler</code>. As soon as you do so and run the tests you should get baseline failure. Accept these baselines (to get them to show up in git), and tweak them to be what you <em>expect</em> them to be … now get the tests to pass.</p>
<p>Run all of these in isolation using <code>jake runtests tests=compiler</code>, or just your new file using <code>jake runtests tests=compiler/yourtest</code></p>
<p>I will even often do <code>jake runtests tests=compiler/yourtest || jake baseline-accept[soft]</code> and get the diff in <code>git</code>.</p>
<h3 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging Tests</a></h3>
<p><code>jake runtests-browser tests=theNameOfYourTest</code> and debugging in-browser usually works pretty well.</p>
<p>🌹🌹🌹</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notiations"><a class="header" href="#notiations">Notiations</a></h1>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Caret ^</li>
<li><input disabled="" type="checkbox" checked=""/>
Angle Braket &lt;&gt;</li>
<li><input disabled="" type="checkbox" checked=""/>
Exclamation mark (!) </li>
<li><input disabled="" type="checkbox" checked=""/>
Ternary operator (?:)</li>
<li><input disabled="" type="checkbox" checked=""/>
We can use <strong>backticks</strong> to make printing less complex.e.g., <code>return </code>We received ${one}, also ${two}``</li>
<li><input disabled="" type="checkbox" checked=""/>
Spread Object,Cloning object properties with spread syntax …</li>
<li><input disabled="" type="checkbox" checked=""/>
Actually, double exclamation !! is not an operator. It’s just the char! repeated twice. A useful notation to make code more readable. Because we could also write Boolean(value) with the same effect. !!false === false, Boolean(false) === false // they really equals to each other.</li>
</ul>
<h1 id="oe"><a class="header" href="#oe">OE</a></h1>
<p>Operating Environment. I’d like to use the term Operating System, but that is not necessarily what I mean here. Think Browser,Node.js,WScriptHost etc.</p>
<h1 id="incremental-parsing"><a class="header" href="#incremental-parsing">Incremental Parsing</a></h1>
<p>Re-Parsing as the user edits the code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
